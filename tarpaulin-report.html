<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","access_control.rs"],"content":"use crate::ContractError;\nuse channel_manager::channel::ChannelsManager;\nuse cosmwasm_std::{Addr, Deps};\nuse omniflix_channel_types::channel::{ChannelId, Role};\nuse omniflix_std::types::omniflix::onft::v1beta1::{Onft, OnftQuerier};\n\n/// Validates if the sender has the required permissions to perform an action on a channel\n///\n/// # Arguments\n/// * `deps` - Dependencies for accessing storage and querier\n/// * `channel_id` - Identifier of the channel\n/// * `sender` - Address of the account attempting the action\n/// * `channels_collection_id` - Collection ID containing the channel NFTs\n/// * `required_role` - Minimum role required to perform the action\n///\n/// # Returns\n/// * `Ok(())` if the sender either:\n///   - Owns the channel NFT (has admin privileges)\n///   - Is a collaborator with sufficient role permissions\n/// * `Err(ContractError::Unauthorized)` if the sender lacks required permissions\npub fn validate_permissions(\n    deps: Deps,\n    channel_id: ChannelId,\n    sender: Addr,\n    channels_collection_id: String,\n    required_role: Role,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let channel_details = channels.get_channel_details(deps.storage, channel_id.clone())?;\n    let channel_onft_id = channel_details.onft_id;\n\n    // First check if they own the channel NFT\n    if let Ok(_channel_onft) = get_onft_with_owner(\n        deps,\n        channels_collection_id,\n        channel_onft_id,\n        sender.to_string(),\n    ) {\n        // Channel owner (NFT holder) has admin privileges\n        return Ok(());\n    }\n\n    // If not the owner, check if user is a collaborator with sufficient privileges\n    if let Ok(collaborator) = channels.get_collaborator(deps.storage, channel_id, sender) {\n        if has_sufficient_privileges(collaborator.role, required_role) {\n            return Ok(());\n        }\n    }\n\n    // If neither owner nor collaborator with sufficient privileges, return error\n    Err(ContractError::Unauthorized {})\n}\n\n// Helper function to check role hierarchy\nfn has_sufficient_privileges(actual_role: Role, required_role: Role) -\u003e bool {\n    match (actual_role, required_role) {\n        // Admin can do everything\n        (Role::Admin, _) =\u003e true,\n\n        // Moderator can do moderator and publisher tasks\n        (Role::Moderator, Role::Moderator | Role::Publisher) =\u003e true,\n\n        // Publisher can only do publisher tasks\n        (Role::Publisher, Role::Publisher) =\u003e true,\n\n        // All other combinations are insufficient privileges\n        _ =\u003e false,\n    }\n}\n\npub fn get_onft_with_owner(\n    deps: Deps,\n    collection_id: String,\n    onft_id: String,\n    owner: String,\n) -\u003e Result\u003cOnft, ContractError\u003e {\n    let onft_querier = OnftQuerier::new(\u0026deps.querier);\n    let onft_response = onft_querier\n        .onft(collection_id.clone(), onft_id.clone())\n        .map_err(|_| ContractError::OnftNotFound {\n            collection_id: collection_id.clone(),\n            onft_id: onft_id.clone(),\n        })?;\n\n    let onft = onft_response\n        .onft\n        .ok_or_else(|| ContractError::OnftNotFound {\n            collection_id: collection_id.clone(),\n            onft_id: onft_id.clone(),\n        })?;\n\n    if onft.owner != owner {\n        return Err(ContractError::OnftNotOwned {\n            collection_id,\n            onft_id,\n        });\n    }\n\n    Ok(onft)\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":302}},{"line":28,"address":[],"length":0,"stats":{"Line":302}},{"line":29,"address":[],"length":0,"stats":{"Line":604}},{"line":40,"address":[],"length":0,"stats":{"Line":288}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":312}},{"line":77,"address":[],"length":0,"stats":{"Line":312}},{"line":78,"address":[],"length":0,"stats":{"Line":624}},{"line":79,"address":[],"length":0,"stats":{"Line":312}},{"line":80,"address":[],"length":0,"stats":{"Line":312}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":311}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":299}}],"covered":23,"coverable":28},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","bank_helpers.rs"],"content":"use cosmwasm_std::{Addr, Attribute, Coin, CosmosMsg, Decimal, Uint128};\nuse cw_utils::NativeBalance;\n\nuse crate::ContractError;\n\n/// Validates that the received payment matches the expected amount\npub fn check_payment(expected: Vec\u003cCoin\u003e, received: Vec\u003cCoin\u003e) -\u003e Result\u003c(), ContractError\u003e {\n    let mut expected_balance = NativeBalance::default();\n    for coin in expected.clone() {\n        expected_balance += coin;\n    }\n\n    let mut received_balance = NativeBalance::default();\n    for coin in received.clone() {\n        received_balance += coin;\n    }\n\n    expected_balance.normalize();\n    received_balance.normalize();\n\n    if expected_balance != received_balance {\n        return Err(ContractError::PaymentError { expected, received });\n    }\n\n    Ok(())\n}\n\n/// Creates a bank message for sending coins to a recipient, handling zero amounts gracefully\n///\n/// This helper function wraps the creation of a bank send message with validation:\n/// - If the input amount contains zero coins, returns an empty vector to avoid transaction failures\n/// - If the amount is non-zero, returns a vector containing the bank send message\n///\n/// # Arguments\n/// * `recipient` - The address that will receive the coins\n/// * `amount` - Vector of coins to send\n///\n/// # Returns\n/// * `Vec\u003cCosmosMsg\u003e` - Empty vector if amount is zero, otherwise vector containing the bank message\npub fn bank_msg_wrapper(recipient: Addr, amount: Vec\u003cCoin\u003e) -\u003e Vec\u003cCosmosMsg\u003e {\n    let mut final_amount = NativeBalance::default();\n    for coin in amount.clone() {\n        final_amount += coin;\n    }\n    // Remove any zero coins\n    final_amount.normalize();\n    // If the final amount is empty, return an empty vec\n    if final_amount.is_empty() {\n        return vec![];\n    }\n    let bank_msg: CosmosMsg = CosmosMsg::Bank(cosmwasm_std::BankMsg::Send {\n        to_address: recipient.into_string(),\n        amount: final_amount.0,\n    });\n    vec![bank_msg]\n}\n\n/// Distributes funds among collaborators according to their shares\n/// and sends any remaining amount to the channel payment address\npub fn distribute_funds_with_shares(\n    collaborators: Vec\u003c(Addr, Decimal)\u003e,\n    amount: Coin,\n    channel_payment_address: Addr,\n) -\u003e Result\u003c(Vec\u003cCosmosMsg\u003e, Vec\u003cAttribute\u003e), ContractError\u003e {\n    let mut bank_msgs: Vec\u003cCosmosMsg\u003e = vec![];\n    let mut remaining_amount = amount.clone().amount;\n    let mut attributes: Vec\u003cAttribute\u003e = vec![];\n\n    for (collaborator, share) in collaborators.clone() {\n        // Create a decimal from the share\n        let share_amount = Decimal::from_ratio(remaining_amount, Uint128::one()) * share;\n        let uint_share_amount = share_amount.to_uint_floor();\n        let share_amount_coin = Coin {\n            denom: amount.denom.clone(),\n            amount: uint_share_amount,\n        };\n        bank_msgs.extend(bank_msg_wrapper(\n            collaborator.clone(),\n            vec![share_amount_coin.clone()],\n        ));\n        remaining_amount -= uint_share_amount;\n        attributes.push(Attribute::new(\n            collaborator.to_string(),\n            share_amount_coin.to_string(),\n        ));\n    }\n\n    if !remaining_amount.is_zero() {\n        let remaining_amount_coin = Coin {\n            denom: amount.denom.clone(),\n            amount: remaining_amount,\n        };\n        bank_msgs.extend(bank_msg_wrapper(\n            channel_payment_address.clone(),\n            vec![remaining_amount_coin.clone()],\n        ));\n        attributes.push(Attribute::new(\n            channel_payment_address.to_string(),\n            remaining_amount_coin.to_string(),\n        ));\n    }\n\n    Ok((bank_msgs, attributes))\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":135}},{"line":8,"address":[],"length":0,"stats":{"Line":135}},{"line":9,"address":[],"length":0,"stats":{"Line":311}},{"line":10,"address":[],"length":0,"stats":{"Line":88}},{"line":13,"address":[],"length":0,"stats":{"Line":135}},{"line":14,"address":[],"length":0,"stats":{"Line":307}},{"line":15,"address":[],"length":0,"stats":{"Line":86}},{"line":18,"address":[],"length":0,"stats":{"Line":135}},{"line":19,"address":[],"length":0,"stats":{"Line":135}},{"line":21,"address":[],"length":0,"stats":{"Line":135}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":25,"address":[],"length":0,"stats":{"Line":132}},{"line":40,"address":[],"length":0,"stats":{"Line":59}},{"line":41,"address":[],"length":0,"stats":{"Line":59}},{"line":42,"address":[],"length":0,"stats":{"Line":83}},{"line":43,"address":[],"length":0,"stats":{"Line":12}},{"line":46,"address":[],"length":0,"stats":{"Line":59}},{"line":48,"address":[],"length":0,"stats":{"Line":59}},{"line":49,"address":[],"length":0,"stats":{"Line":47}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":52,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}}],"covered":47,"coverable":47},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\nuse omniflix_channel_types::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ExecuteMsg,\n        query: QueryMsg,\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","contract.rs"],"content":"use crate::access_control::validate_permissions;\nuse crate::bank_helpers::{bank_msg_wrapper, check_payment, distribute_funds_with_shares};\nuse crate::error::ContractError;\nuse crate::helpers::{\n    filter_assets_to_remove, generate_create_denom_msg, generate_mint_onft_msg,\n    get_collection_creation_fee, validate_asset_metadata, validate_asset_source,\n    validate_channel_collection_details, validate_channel_details, validate_channel_metadata,\n    validate_channel_token_details, validate_reserved_usernames,\n};\nuse crate::random::generate_random_id_with_prefix;\nuse crate::state::{CHANNEL_TOKEN_DETAILS, CONFIG};\nuse crate::string_validation::{validate_string, StringValidationType};\nuse asset_manager::assets::AssetsManager;\nuse asset_manager::playlists::PlaylistsManager;\nuse channel_manager::channel::ChannelsManager;\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    to_json_binary, Addr, Binary, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response,\n    StdResult,\n};\nuse cw_utils::must_pay;\nuse omniflix_channel_types::asset::{Asset, AssetKey, AssetMetadata, AssetSource, Flag, Playlist};\nuse omniflix_channel_types::channel::{\n    ChannelCollaborator, ChannelDetails, ChannelMetadata, ChannelOnftData, Role,\n};\nuse omniflix_channel_types::config::{AuthDetails, ChannelConractConfig};\nuse omniflix_channel_types::msg::{\n    AssetResponse, ChannelResponse, CollaboratorInfo, ExecuteMsg, InstantiateMsg, QueryMsg,\n    ReservedUsername,\n};\nuse pauser::PauseState;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Validate the admin address provided in the instantiation message\n    let protocol_admin = deps\n        .api\n        .addr_validate(\u0026msg.clone().protocol_admin.into_string())?;\n    //Initialize the pause state and set the initial pausers\n    let pause_state = PauseState::new()?;\n    pause_state.set_pausers(\n        deps.storage,\n        info.sender.clone(),\n        vec![protocol_admin.clone()],\n    )?;\n\n    // Validate the fee collector address, or default to the admin address if validation fails\n    let fee_collector = deps\n        .api\n        .addr_validate(\u0026msg.fee_collector.clone().into_string())?;\n\n    // Validate the channel token details\n    validate_channel_token_details(msg.channel_token_details.clone())?;\n\n    // Save the channel token details\n    CHANNEL_TOKEN_DETAILS.save(deps.storage, \u0026msg.channel_token_details)?;\n\n    // Validate the channel collection details\n    validate_channel_collection_details(msg.channels_collection_details.clone())?;\n\n    // Save channel CONFIG\n    let channel_contract_config = ChannelConractConfig {\n        auth_details: AuthDetails {\n            protocol_admin: protocol_admin.clone(),\n            fee_collector: fee_collector.clone(),\n        },\n        accepted_tip_denoms: msg.accepted_tip_denoms.clone(),\n        channels_collection_id: msg.channels_collection_details.collection_id.clone(),\n        channel_creation_fee: msg.channel_creation_fee.clone(),\n    };\n    // Save the channel CONFIG to the contract state\n    CONFIG.save(deps.storage, \u0026channel_contract_config)?;\n\n    // Query the collection creation fee from onft module\n    let collection_creation_fee = get_collection_creation_fee(deps.as_ref())?;\n\n    // Check if the payment provided in the message matches the required creation fee\n    check_payment(\n        [collection_creation_fee.clone()].to_vec(),\n        info.funds.clone(),\n    )?;\n\n    let channels_manager = ChannelsManager::new();\n    validate_reserved_usernames(msg.reserved_usernames.clone(), deps.api)?;\n    channels_manager.add_reserved_usernames(deps.storage, msg.reserved_usernames.clone())?;\n\n    // Prepare the message to create a new ONFT denom (collection)\n    let onft_creation_message: CosmosMsg = generate_create_denom_msg(\n        msg.channels_collection_details.clone(),\n        env.contract.address.clone().to_string(),\n        collection_creation_fee,\n    );\n\n    let response = Response::new()\n        .add_message(onft_creation_message)\n        .add_attribute(\"action\", \"instantiate\")\n        .add_attribute(\n            \"channels_collection_id\",\n            msg.channels_collection_details.collection_id.clone(),\n        )\n        .add_attribute(\n            \"channels_collection_name\",\n            msg.channels_collection_details.collection_name.clone(),\n        )\n        .add_attribute(\n            \"channels_collection_symbol\",\n            msg.channels_collection_details.collection_symbol.clone(),\n        );\n\n    Ok(response)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::AdminRemoveAssets {\n            asset_keys,\n            refresh_flags,\n        } =\u003e remove_assets(deps, info, asset_keys, refresh_flags),\n        ExecuteMsg::AssetFlag {\n            channel_id,\n            publish_id,\n            flag,\n        } =\u003e flag_asset(deps, info, channel_id, publish_id, flag),\n        ExecuteMsg::Pause {} =\u003e pause(deps, info),\n        ExecuteMsg::Unpause {} =\u003e unpause(deps, info),\n        ExecuteMsg::SetPausers { pausers } =\u003e set_pausers(deps, info, pausers),\n        ExecuteMsg::AssetPublish {\n            asset_source,\n            salt,\n            channel_id,\n            playlist_name,\n            is_visible,\n            metadata,\n        } =\u003e publish(\n            deps,\n            env,\n            info,\n            asset_source,\n            salt,\n            channel_id,\n            playlist_name,\n            is_visible,\n            metadata,\n        ),\n        ExecuteMsg::AssetUnpublish {\n            publish_id,\n            channel_id,\n        } =\u003e unpublish(deps, info, publish_id, channel_id),\n        ExecuteMsg::PlaylistRefresh {\n            channel_id,\n            playlist_name,\n        } =\u003e refresh_playlist(deps, info, channel_id, playlist_name),\n        ExecuteMsg::PlaylistCreate {\n            playlist_name,\n            channel_id,\n        } =\u003e create_playlist(deps, info, channel_id, playlist_name),\n        ExecuteMsg::ChannelCreate {\n            user_name,\n            channel_name,\n            salt,\n            description,\n            profile_picture,\n            banner_picture,\n            payment_address,\n        } =\u003e create_channel(\n            deps,\n            env,\n            info,\n            salt,\n            description,\n            payment_address,\n            user_name,\n            channel_name,\n            profile_picture,\n            banner_picture,\n        ),\n        ExecuteMsg::ChannelUpdateDetails {\n            channel_id,\n            description,\n            channel_name,\n            profile_picture,\n            banner_picture,\n            payment_address,\n        } =\u003e update_channel_details(\n            deps,\n            info,\n            channel_id,\n            description,\n            channel_name,\n            profile_picture,\n            banner_picture,\n            payment_address,\n        ),\n\n        ExecuteMsg::PlaylistDelete {\n            playlist_name,\n            channel_id,\n        } =\u003e delete_playlist(deps, info, channel_id, playlist_name),\n        ExecuteMsg::PlaylistRemoveAsset {\n            publish_id,\n            channel_id,\n            playlist_name,\n        } =\u003e remove_asset_from_playlist(deps, info, publish_id, channel_id, playlist_name),\n        ExecuteMsg::AdminSetConfig {\n            channel_creation_fee,\n            protocol_admin,\n            fee_collector,\n        } =\u003e set_config(\n            deps,\n            info,\n            channel_creation_fee,\n            protocol_admin,\n            fee_collector,\n        ),\n        ExecuteMsg::PlaylistAddAsset {\n            publish_id,\n            asset_channel_id,\n            channel_id,\n            playlist_name,\n        } =\u003e add_asset_to_playlist(\n            deps,\n            info,\n            asset_channel_id,\n            publish_id,\n            channel_id,\n            playlist_name,\n        ),\n        ExecuteMsg::AssetUpdateDetails {\n            publish_id,\n            channel_id,\n            is_visible,\n            name,\n            description,\n            media_uri,\n        } =\u003e update_asset_details(\n            deps,\n            info,\n            publish_id,\n            channel_id,\n            is_visible,\n            name,\n            description,\n            media_uri,\n        ),\n        ExecuteMsg::ChannelDelete { channel_id } =\u003e delete_channel(deps, info, channel_id),\n        ExecuteMsg::AdminManageReservedUsernames {\n            add_usernames,\n            remove_usernames,\n        } =\u003e manage_reserved_usernames(deps, info, add_usernames, remove_usernames),\n        ExecuteMsg::ChannelTip {\n            channel_id, amount, ..\n        } =\u003e tip_channel(deps, info, channel_id, amount),\n        ExecuteMsg::ChannelAddCollaborator {\n            channel_id,\n            collaborator_address,\n            collaborator_details,\n        } =\u003e add_collaborator(\n            deps,\n            info,\n            channel_id,\n            collaborator_address,\n            collaborator_details,\n        ),\n        ExecuteMsg::ChannelRemoveCollaborator {\n            channel_id,\n            collaborator_address,\n        } =\u003e remove_collaborator(deps, info, channel_id, collaborator_address),\n        ExecuteMsg::ChannelFollow { channel_id } =\u003e follow_channel(deps, info, channel_id),\n        ExecuteMsg::ChannelUnfollow { channel_id } =\u003e unfollow_channel(deps, info, channel_id),\n    }\n}\n\n#[allow(clippy::too_many_arguments)]\nfn create_channel(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    salt: Binary,\n    description: Option\u003cString\u003e,\n    payment_address: Addr,\n    user_name: String,\n    channel_name: String,\n    profile_picture: Option\u003cString\u003e,\n    banner_picture: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    // Check if the payment provided in the message matches the required creation fee\n    check_payment(config.channel_creation_fee.clone(), info.funds.clone())?;\n\n    // Generate a random channel onft ID\n    let onft_id = generate_random_id_with_prefix(\u0026salt, \u0026env, \"onft\");\n\n    // Generate a random channel ID\n    let channel_id = generate_random_id_with_prefix(\u0026salt, \u0026env, \"channel\");\n\n    let channels_manager = ChannelsManager::new();\n\n    let channel_details = ChannelDetails {\n        channel_id: channel_id.clone(),\n        user_name: user_name.clone(),\n        onft_id: onft_id.clone(),\n        payment_address: deps.api.addr_validate(\u0026payment_address.into_string())?,\n    };\n    let channel_metadata = ChannelMetadata {\n        channel_name: channel_name.clone(),\n        description: description.clone(),\n        profile_picture: profile_picture.clone(),\n        banner_picture: banner_picture.clone(),\n    };\n    validate_channel_details(channel_details.clone())?;\n    validate_channel_metadata(channel_metadata.clone())?;\n\n    // Check if the username is reserved\n    match channels_manager.get_reserved_status(deps.storage, user_name.clone())? {\n        None =\u003e {\n            // Username is not reserved, proceed with channel creation\n        }\n        Some(reserved_addr) =\u003e {\n            if reserved_addr != Some(info.sender.clone()) {\n                // Username is reserved but not assigned to anyone\n                return Err(ContractError::UserNameReserved {});\n            }\n            // Username is reserved for a specific address\n            if reserved_addr != Some(info.sender.clone()) {\n                return Err(ContractError::UserNameReserved {});\n            }\n            // Sender matches the reserved address, remove the reservation\n            channels_manager.remove_reserved_usernames(deps.storage, vec![user_name.clone()])?;\n        }\n    }\n    // Add the new channel to the collection\n    // Checks for uniqueness of the channel ID and username\n    channels_manager.add_channel(\n        deps.storage,\n        channel_id.clone(),\n        channel_details.clone(),\n        channel_metadata.clone(),\n    )?;\n\n    // Create the onft data for the channel. This data will be stored in the onft's data field\n    let onft_data = ChannelOnftData {\n        channel_id: channel_id.clone(),\n        user_name: user_name.clone(),\n        onft_id: onft_id.clone(),\n    };\n\n    let string_onft_data =\n        serde_json::to_string(\u0026onft_data).map_err(|_| ContractError::InvalidOnftData {})?;\n\n    // Generate the mint message and its attributes\n    let (mint_onft_msg, nft_attributes) = generate_mint_onft_msg(\n        onft_id.clone(),\n        config.channels_collection_id.clone(),\n        env.contract.address.clone().to_string(),\n        info.sender.clone().to_string(),\n        string_onft_data,\n        user_name.clone(),\n        CHANNEL_TOKEN_DETAILS.load(deps.storage)?,\n    );\n\n    // Pay the channel creation fee to the fee collector\n    let bank_channel_fee_msg = bank_msg_wrapper(\n        config.auth_details.fee_collector,\n        config.channel_creation_fee,\n    );\n\n    let response = Response::new()\n        .add_message(mint_onft_msg)\n        .add_messages(bank_channel_fee_msg)\n        .add_attribute(\"action\", \"register_channel\")\n        .add_attributes(nft_attributes)\n        .add_attribute(\"channel_id\", channel_id.clone());\n\n    Ok(response)\n}\n\nfn follow_channel(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    channels_manager.add_follower(deps.storage, channel_id.clone(), info.sender.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"follow_channel\")\n        .add_attribute(\"channel_id\", channel_id);\n    Ok(response)\n}\n\nfn unfollow_channel(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    channels_manager.remove_follower(deps.storage, channel_id.clone(), info.sender.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"unfollow_channel\")\n        .add_attribute(\"channel_id\", channel_id);\n    Ok(response)\n}\n\nfn delete_channel(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    let channels_manager = ChannelsManager::new();\n    let assets_manager = AssetsManager::new();\n    let playlist_manager = PlaylistsManager::new();\n    // Check if the sender has admin permissions\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Admin,\n    )?;\n\n    channels_manager.delete_channel(deps.storage, channel_id.clone())?;\n    assets_manager.delete_assets_by_channel_id(deps.storage, channel_id.clone())?;\n    playlist_manager.delete_playlists_by_channel_id(deps.storage, channel_id.clone());\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"delete_channel\")\n        .add_attribute(\"channel_id\", channel_id);\n\n    Ok(response)\n}\n\n#[allow(clippy::too_many_arguments)]\nfn publish(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    asset_source: AssetSource,\n    salt: Binary,\n    channel_id: String,\n    playlist_name: Option\u003cString\u003e,\n    is_visible: bool,\n    metadata: AssetMetadata,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let publish_id = generate_random_id_with_prefix(\u0026salt, \u0026env, \"publish\");\n\n    validate_asset_source(deps.as_ref(), asset_source.clone(), info.sender.clone())?;\n\n    validate_asset_metadata(metadata.clone())?;\n\n    // Define the asset to be published\n    let asset = Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n        asset_source: asset_source.clone(),\n        is_visible,\n    };\n\n    // Add asset to the channel's asset list\n    let assets_manager = AssetsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    assets_manager.add_asset(deps.storage, asset_key.clone(), asset.clone(), metadata)?;\n\n    if let Some(playlist_name) = playlist_name.clone() {\n        if is_visible {\n            let playlists_manager = PlaylistsManager::new();\n            playlists_manager.add_asset_to_playlist(\n                deps.storage,\n                channel_id.clone(),\n                playlist_name.clone(),\n                asset_key,\n            )?;\n        }\n    }\n\n    let mut response = Response::new()\n        .add_attribute(\"action\", \"publish\")\n        .add_attribute(\"publish_id\", publish_id)\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"asset_source\", asset_source.to_string());\n\n    if let Some(playlist_name) = playlist_name {\n        response = response.add_attribute(\"playlist_name\", playlist_name);\n    }\n    Ok(response)\n}\n\nfn unpublish(\n    deps: DepsMut,\n    info: MessageInfo,\n    publish_id: String,\n    channel_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let assets_manager = AssetsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    assets_manager.delete_assets(deps.storage, vec![asset_key.clone()])?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"unpublish\")\n        .add_attribute(\"publish_id\", publish_id)\n        .add_attribute(\"channel_id\", channel_id);\n\n    Ok(response)\n}\n\nfn refresh_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlists_manager = PlaylistsManager::new();\n    let playlist_asset_keys = playlists_manager\n        .get_playlist(deps.storage, channel_id.clone(), playlist_name.clone())?\n        .assets;\n    let asset_keys_to_remove = filter_assets_to_remove(deps.storage, playlist_asset_keys.clone());\n\n    playlists_manager.remove_assets_from_playlist(\n        deps.storage,\n        channel_id.clone(),\n        playlist_name.clone(),\n        asset_keys_to_remove.clone(),\n    )?;\n    let removed_publish_ids: Vec\u003cString\u003e = asset_keys_to_remove\n        .iter()\n        .map(|asset_key| asset_key.1.clone())\n        .collect();\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"refresh_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name)\n        .add_attribute(\"removed_publish_ids\", removed_publish_ids.join(\", \"));\n\n    Ok(response)\n}\n\nfn create_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlists_manager = PlaylistsManager::new();\n    playlists_manager.add_new_playlist(deps.storage, channel_id.clone(), playlist_name.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"create_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name);\n\n    Ok(response)\n}\n\nfn pause(deps: DepsMut, info: MessageInfo) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.pause(deps.storage, \u0026info.sender)?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"pause\")\n        .add_attribute(\"pauser\", info.sender.clone().to_string());\n    Ok(response)\n}\n\nfn unpause(deps: DepsMut, info: MessageInfo) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.unpause(deps.storage, \u0026info.sender)?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"unpause\")\n        .add_attribute(\"pauser\", info.sender.clone().to_string());\n    Ok(response)\n}\n\nfn set_pausers(\n    deps: DepsMut,\n    info: MessageInfo,\n    pausers: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    // Validate pauser addresses\n    let validated_pausers: Vec\u003cAddr\u003e = pausers\n        .iter()\n        .map(|pauser| deps.api.addr_validate(pauser))\n        .collect::\u003cResult\u003cVec\u003cAddr\u003e, _\u003e\u003e()?;\n\n    for pauser in pausers.clone() {\n        deps.api.addr_validate(\u0026pauser)?;\n    }\n    pause_state.set_pausers(deps.storage, info.sender.clone(), validated_pausers)?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"set_pausers\")\n        .add_attribute(\"pauser\", info.sender.clone().to_string());\n    Ok(response)\n}\n\nfn add_collaborator(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    collaborator_address: String,\n    collaborator_details: ChannelCollaborator,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Admin,\n    )?;\n\n    // Validate the collaborator address\n    let collaborator_address = deps.api.addr_validate(\u0026collaborator_address)?;\n    let channels_manager = ChannelsManager::new();\n\n    // Add the collaborator to the channel\n    channels_manager.add_collaborator(\n        deps.storage,\n        channel_id.clone(),\n        collaborator_address.clone(),\n        collaborator_details.clone(),\n    )?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"add_collaborator\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"collaborator_address\", collaborator_address)\n        .add_attribute(\"share\", collaborator_details.share.to_string());\n\n    Ok(response)\n}\n\nfn remove_collaborator(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    collaborator_address: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Admin,\n    )?;\n\n    // Validate the collaborator address\n    let collaborator_address = deps.api.addr_validate(\u0026collaborator_address)?;\n\n    // Remove the collaborator from the channel\n    let channels_manager = ChannelsManager::new();\n    channels_manager.remove_collaborator(\n        deps.storage,\n        channel_id.clone(),\n        collaborator_address.clone(),\n    )?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"remove_collaborator\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"collaborator_address\", collaborator_address);\n\n    Ok(response)\n}\n\n#[allow(clippy::too_many_arguments)]\nfn update_channel_details(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    description: Option\u003cString\u003e,\n    channel_name: Option\u003cString\u003e,\n    profile_picture: Option\u003cString\u003e,\n    banner_picture: Option\u003cString\u003e,\n    payment_address: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n    let config = CONFIG.load(deps.storage)?;\n    let channels_collection_id = config.channels_collection_id.clone();\n\n    let channel_manager = ChannelsManager::new();\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        channels_collection_id.clone(),\n        Role::Admin,\n    )?;\n\n    let mut channel_metadata =\n        channel_manager.get_channel_metadata(deps.storage, channel_id.clone())?;\n\n    if let Some(description) = description.clone() {\n        channel_metadata.description = Some(description.clone());\n    }\n\n    if let Some(channel_name) = channel_name.clone() {\n        channel_metadata.channel_name = channel_name.clone();\n    }\n\n    if let Some(profile_picture) = profile_picture.clone() {\n        channel_metadata.profile_picture = Some(profile_picture.clone());\n    }\n\n    if let Some(banner_picture) = banner_picture.clone() {\n        channel_metadata.banner_picture = Some(banner_picture.clone());\n    }\n    validate_channel_metadata(channel_metadata.clone())?;\n\n    channel_manager.update_channel_metadata(\n        deps.storage,\n        channel_id.clone(),\n        channel_metadata.clone(),\n    )?;\n\n    if let Some(payment_address) = payment_address.clone() {\n        let payment_address = deps.api.addr_validate(\u0026payment_address)?;\n        channel_manager.update_payment_address(\n            deps.storage,\n            channel_id.clone(),\n            payment_address,\n        )?;\n    }\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"update_channel_details\")\n        .add_attribute(\"channel_id\", channel_id);\n\n    Ok(response)\n}\n\nfn delete_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlist_manager = PlaylistsManager::new();\n    playlist_manager.delete_playlist(deps.storage, channel_id.clone(), playlist_name.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"delete_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name);\n\n    Ok(response)\n}\nfn add_asset_to_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    asset_channel_id: String,\n    publish_id: String,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlist_manager = PlaylistsManager::new();\n\n    // Load the asset\n    let assets_manager = AssetsManager::new();\n    let asset_key = (asset_channel_id.clone(), publish_id.clone());\n    let asset = assets_manager.get_asset(deps.storage, asset_key.clone())?;\n\n    // Verify that the asset is visible\n    if !asset.is_visible {\n        return Err(ContractError::AssetNotVisible {});\n    }\n\n    // Add asset to playlist\n    playlist_manager.add_asset_to_playlist(\n        deps.storage,\n        channel_id.clone(),\n        playlist_name.clone(),\n        asset_key.clone(),\n    )?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"add_asset_to_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name)\n        .add_attribute(\"publish_id\", publish_id);\n\n    Ok(response)\n}\nfn remove_asset_from_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    publish_id: String,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlists_manager = PlaylistsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    // Remove the asset from the playlist\n    playlists_manager.remove_assets_from_playlist(\n        deps.storage,\n        channel_id.clone(),\n        playlist_name.clone(),\n        [asset_key.clone()].to_vec(),\n    )?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"remove_asset_from_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name)\n        .add_attribute(\"publish_id\", publish_id);\n\n    Ok(response)\n}\n#[allow(clippy::too_many_arguments)]\nfn update_asset_details(\n    deps: DepsMut,\n    info: MessageInfo,\n    publish_id: String,\n    channel_id: String,\n    is_visible: Option\u003cbool\u003e,\n    name: Option\u003cString\u003e,\n    description: Option\u003cString\u003e,\n    media_uri: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let assets_manager = AssetsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    let mut asset = assets_manager.get_asset(deps.storage, asset_key.clone())?;\n    let mut metadata = assets_manager.get_asset_metadata(deps.storage, asset_key.clone())?;\n    // Validate the asset name\n    if let Some(name) = name {\n        validate_string(\u0026name, StringValidationType::AssetName)?;\n        metadata.name = name;\n    }\n    // Validate the asset description\n    if let Some(description) = description {\n        validate_string(\u0026description, StringValidationType::Description)?;\n        metadata.description = description;\n    }\n    // Validate the asset media URI\n    if let Some(media_uri) = media_uri {\n        validate_string(\u0026media_uri, StringValidationType::Link)?;\n        metadata.media_uri = media_uri;\n    }\n    if let Some(is_visible) = is_visible {\n        asset.is_visible = is_visible;\n    }\n\n    assets_manager.update_asset(deps.storage, asset_key.clone(), asset.clone())?;\n    assets_manager.update_asset_metadata(deps.storage, asset_key.clone(), metadata.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"update_asset_details\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"publish_id\", publish_id)\n        .add_attribute(\"is_visible\", asset.is_visible.to_string())\n        .add_attribute(\"name\", metadata.name.clone())\n        .add_attribute(\"description\", metadata.description.clone())\n        .add_attribute(\"media_uri\", metadata.media_uri.clone());\n\n    Ok(response)\n}\n\nfn set_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_creation_fee: Option\u003cVec\u003cCoin\u003e\u003e,\n    protocol_admin: Option\u003cString\u003e,\n    fee_collector: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.auth_details.protocol_admin {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(protocol_admin) = protocol_admin {\n        let protocol_admin = deps.api.addr_validate(\u0026protocol_admin)?;\n        config.auth_details.protocol_admin = protocol_admin;\n    }\n\n    if let Some(fee_collector) = fee_collector {\n        let fee_collector = deps.api.addr_validate(\u0026fee_collector)?;\n        config.auth_details.fee_collector = fee_collector;\n    }\n\n    if let Some(channel_creation_fee) = channel_creation_fee {\n        config.channel_creation_fee = channel_creation_fee;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"set_config\")\n        .add_attribute(\n            \"protocol_admin\",\n            config.auth_details.protocol_admin.to_string(),\n        )\n        .add_attribute(\n            \"fee_collector\",\n            config.auth_details.fee_collector.to_string(),\n        );\n\n    Ok(response)\n}\n\nfn manage_reserved_usernames(\n    deps: DepsMut,\n    info: MessageInfo,\n    add_usernames: Option\u003cVec\u003cReservedUsername\u003e\u003e,\n    remove_usernames: Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.auth_details.protocol_admin {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let channels_manager = ChannelsManager::new();\n\n    let mut attrs = vec![(\n        \"action\".to_string(),\n        \"manage_reserved_usernames\".to_string(),\n    )];\n    if let Some(add_usernames) = add_usernames {\n        validate_reserved_usernames(add_usernames.clone(), deps.api)?;\n        channels_manager.add_reserved_usernames(deps.storage, add_usernames.clone())?;\n        for username in add_usernames {\n            attrs.push((\"add_username\".to_string(), username.username)); // Directly push owned username\n        }\n    }\n    if let Some(remove_usernames) = remove_usernames {\n        for username in remove_usernames {\n            channels_manager.remove_reserved_usernames(deps.storage, vec![username.clone()])?;\n            attrs.push((\"remove_username\".to_string(), username)); // Directly push owned username\n        }\n    }\n\n    let response = Response::new().add_attributes(attrs);\n\n    Ok(response)\n}\n\nfn tip_channel(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    amount: Coin,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n    let config = CONFIG.load(deps.storage)?;\n    let accepted_tip_denoms = config.accepted_tip_denoms.clone();\n    if !accepted_tip_denoms.contains(\u0026amount.denom) {\n        return Err(ContractError::InvalidTipDenom {});\n    }\n\n    let sent_amount = must_pay(\u0026info, \u0026amount.denom)?;\n\n    if sent_amount != amount.amount {\n        return Err(ContractError::InvalidTipAmount {});\n    }\n\n    let channels_manager = ChannelsManager::new();\n    let channel_details = channels_manager.get_channel_details(deps.storage, channel_id.clone())?;\n    let channel_payment_address = channel_details.payment_address.clone();\n    // Calculates the shares of the collaborators\n    let collaborator_shares =\n        channels_manager.get_collaborator_shares(deps.storage, channel_id.clone())?;\n    // Distributes the funds to the collaborators and remaining to the channel payment address\n    let (bank_msgs, attributes) =\n        distribute_funds_with_shares(collaborator_shares, amount.clone(), channel_payment_address)?;\n\n    let response = Response::new()\n        .add_messages(bank_msgs)\n        .add_attributes(attributes)\n        .add_attribute(\"action\", \"tip_creator\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"amount\", amount.to_string());\n\n    Ok(response)\n}\n\nfn remove_assets(\n    deps: DepsMut,\n    info: MessageInfo,\n    asset_keys: Vec\u003cAssetKey\u003e,\n    refresh_flags: Option\u003cbool\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    if info.sender != config.auth_details.protocol_admin {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let mut deleted_assets: Vec\u003cAssetKey\u003e = Vec::new();\n    deleted_assets.extend(asset_keys.clone());\n\n    // First remove the assets specified in the message\n    let assets_manager = AssetsManager::new();\n    assets_manager.delete_assets(deps.storage, asset_keys)?;\n\n    // Refresh the flags if set\n    // If the flag is set to true, all flags of all assets will be removed\n    if let Some(refresh_flags) = refresh_flags {\n        if refresh_flags {\n            assets_manager.remove_all_flags(deps.storage)?;\n        }\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"remove_assets\")\n        .add_attribute(\"admin\", config.auth_details.protocol_admin.to_string()))\n}\n\nfn flag_asset(\n    deps: DepsMut,\n    _info: MessageInfo,\n    channel_id: String,\n    publish_id: String,\n    flag: Flag,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let assets_manager = AssetsManager::new();\n    assets_manager.add_flag(\n        deps.storage,\n        channel_id.clone(),\n        publish_id.clone(),\n        flag.clone(),\n    )?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"asset_flag\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"publish_id\", publish_id)\n        .add_attribute(\"flag\", flag.to_string()))\n}\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Channel { channel_id } =\u003e to_json_binary(\u0026query_channel(deps, channel_id)?),\n        QueryMsg::IsPaused {} =\u003e to_json_binary(\u0026query_is_paused(deps)?),\n        QueryMsg::Pausers {} =\u003e to_json_binary(\u0026query_pausers(deps)?),\n        QueryMsg::ChannelDetails { channel_id } =\u003e {\n            to_json_binary(\u0026query_channel_details(deps, channel_id)?)\n        }\n        QueryMsg::ChannelMetadata { channel_id } =\u003e {\n            to_json_binary(\u0026query_channel_metadata(deps, channel_id)?)\n        }\n        QueryMsg::Playlist {\n            channel_id,\n            playlist_name,\n        } =\u003e to_json_binary(\u0026query_playlist(deps, channel_id, playlist_name)?),\n        QueryMsg::Channels { start_after, limit } =\u003e {\n            to_json_binary(\u0026query_channels(deps, start_after, limit)?)\n        }\n        QueryMsg::ChannelId { user_name } =\u003e to_json_binary(\u0026query_channel_id(deps, user_name)?),\n        QueryMsg::Playlists {\n            channel_id,\n            start_after,\n            limit,\n        } =\u003e to_json_binary(\u0026query_playlists(deps, channel_id, start_after, limit)?),\n        QueryMsg::Config {} =\u003e to_json_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::Assets {\n            channel_id,\n            start_after,\n            limit,\n        } =\u003e to_json_binary(\u0026query_assets(deps, channel_id, start_after, limit)?),\n        QueryMsg::Asset {\n            channel_id,\n            publish_id,\n        } =\u003e to_json_binary(\u0026query_asset(deps, channel_id, publish_id)?),\n        QueryMsg::ReservedUsernames { start_after, limit } =\u003e {\n            to_json_binary(\u0026query_reserved_usernames(deps, start_after, limit)?)\n        }\n        QueryMsg::GetChannelCollaborator {\n            channel_id,\n            collaborator_address,\n        } =\u003e to_json_binary(\u0026query_channel_collaborator(\n            deps,\n            channel_id,\n            collaborator_address,\n        )?),\n        QueryMsg::GetChannelCollaborators {\n            channel_id,\n            start_after,\n            limit,\n        } =\u003e to_json_binary(\u0026query_channel_collaborators(\n            deps,\n            channel_id,\n            start_after,\n            limit,\n        )?),\n        QueryMsg::FollowersCount { channel_id } =\u003e {\n            to_json_binary(\u0026query_followers_count(deps, channel_id)?)\n        }\n        QueryMsg::Followers {\n            channel_id,\n            start_after,\n            limit,\n        } =\u003e to_json_binary(\u0026query_followers(deps, channel_id, start_after, limit)?),\n    }\n}\n\nfn query_channel_details(deps: Deps, channel_id: String) -\u003e Result\u003cChannelDetails, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    let channel_details = channels_manager.get_channel_details(deps.storage, channel_id.clone())?;\n    Ok(channel_details)\n}\n\nfn query_channel_metadata(\n    deps: Deps,\n    channel_id: String,\n) -\u003e Result\u003cChannelMetadata, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    let channel_metadata =\n        channels_manager.get_channel_metadata(deps.storage, channel_id.clone())?;\n    Ok(channel_metadata)\n}\n\nfn query_channel(deps: Deps, channel_id: String) -\u003e Result\u003cChannelResponse, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    let channel_details = channels_manager.get_channel_details(deps.storage, channel_id.clone())?;\n    let channel_metadata =\n        channels_manager.get_channel_metadata(deps.storage, channel_id.clone())?;\n    let channel_collaborators =\n        channels_manager.get_channel_collaborators(deps.storage, channel_id.clone(), None, None)?;\n    let follower_count = channels_manager.get_followers_count(deps.storage, channel_id.clone())?;\n\n    Ok(ChannelResponse {\n        channel_id: channel_details.channel_id,\n        user_name: channel_details.user_name,\n        onft_id: channel_details.onft_id,\n        payment_address: channel_details.payment_address.to_string(),\n        channel_name: channel_metadata.channel_name,\n        description: channel_metadata.description,\n        profile_picture: channel_metadata.profile_picture,\n        banner_picture: channel_metadata.banner_picture,\n        collaborators: channel_collaborators,\n        follower_count,\n    })\n}\n\nfn query_channels(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cChannelResponse\u003e, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    let channels_list = channels_manager.get_channels_list(deps.storage, start_after, limit)?;\n    let channels = channels_list\n        .iter()\n        .map(|channel| query_channel(deps, channel.channel_id.clone()))\n        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n    Ok(channels)\n}\n\nfn query_playlist(\n    deps: Deps,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cPlaylist, ContractError\u003e {\n    let playlists_manager = PlaylistsManager::new();\n    let playlist =\n        playlists_manager.get_playlist(deps.storage, channel_id.clone(), playlist_name.clone())?;\n    Ok(playlist)\n}\n\nfn query_playlists(\n    deps: Deps,\n    channel_id: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cPlaylist\u003e, ContractError\u003e {\n    let playlists_manager = PlaylistsManager::new();\n    let playlists = playlists_manager.get_all_playlists(\n        deps.storage,\n        channel_id.clone(),\n        start_after,\n        limit,\n    )?;\n    Ok(playlists)\n}\n\nfn query_channel_id(deps: Deps, user_name: String) -\u003e Result\u003cString, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let channel_id = channels.get_channel_id(deps.storage, user_name.clone())?;\n    Ok(channel_id)\n}\n\nfn query_is_paused(deps: Deps) -\u003e Result\u003cbool, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    let is_paused = pause_state.is_paused(deps.storage)?;\n    Ok(is_paused)\n}\n\nfn query_pausers(deps: Deps) -\u003e Result\u003cVec\u003cString\u003e, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    let pausers = pause_state.get_pausers(deps.storage)?;\n    let pauser_strings = pausers.iter().map(|addr| addr.to_string()).collect();\n    Ok(pauser_strings)\n}\n\nfn query_assets(\n    deps: Deps,\n    channel_id: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cAssetResponse\u003e, ContractError\u003e {\n    let assets_manager = AssetsManager::new();\n    let assets_list =\n        assets_manager.get_all_assets(deps.storage, channel_id.clone(), start_after, limit)?;\n    Ok(assets_list)\n}\n\nfn query_asset(\n    deps: Deps,\n    channel_id: String,\n    publish_id: String,\n) -\u003e Result\u003cAssetResponse, ContractError\u003e {\n    let assets_manager = AssetsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    let asset = assets_manager.get_asset(deps.storage, asset_key.clone())?;\n    let flags = assets_manager.get_all_flags_for_asset(deps.storage, channel_id, publish_id)?;\n    let metadata = assets_manager.get_asset_metadata(deps.storage, asset_key.clone())?;\n    Ok(AssetResponse {\n        asset,\n        flags,\n        metadata,\n    })\n}\nfn query_reserved_usernames(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cReservedUsername\u003e, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let reserved_usernames = channels.get_reserved_usernames(deps.storage, start_after, limit)?;\n    Ok(reserved_usernames)\n}\n\nfn query_channel_collaborator(\n    deps: Deps,\n    channel_id: String,\n    collaborator_address: Addr,\n) -\u003e Result\u003cCollaboratorInfo, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let collaborator =\n        channels.get_collaborator(deps.storage, channel_id, collaborator_address.clone())?;\n    Ok(CollaboratorInfo {\n        address: collaborator_address.to_string(),\n        role: collaborator.role.to_string(),\n        share: collaborator.share,\n    })\n}\n\nfn query_channel_collaborators(\n    deps: Deps,\n    channel_id: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cCollaboratorInfo\u003e, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let collaborators =\n        channels.get_channel_collaborators(deps.storage, channel_id, start_after, limit)?;\n    Ok(collaborators)\n}\n\nfn query_followers_count(deps: Deps, channel_id: String) -\u003e Result\u003cu64, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let count = channels.get_followers_count(deps.storage, channel_id)?;\n    Ok(count)\n}\n\nfn query_followers(\n    deps: Deps,\n    channel_id: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cAddr\u003e, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let followers = channels.get_followers(deps.storage, channel_id, start_after, limit)?;\n    Ok(followers)\n}\n\n#[cfg(test)]\nmod tests {}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":72}},{"line":41,"address":[],"length":0,"stats":{"Line":144}},{"line":42,"address":[],"length":0,"stats":{"Line":72}},{"line":43,"address":[],"length":0,"stats":{"Line":72}},{"line":45,"address":[],"length":0,"stats":{"Line":72}},{"line":53,"address":[],"length":0,"stats":{"Line":144}},{"line":54,"address":[],"length":0,"stats":{"Line":72}},{"line":55,"address":[],"length":0,"stats":{"Line":72}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":72}},{"line":64,"address":[],"length":0,"stats":{"Line":72}},{"line":68,"address":[],"length":0,"stats":{"Line":72}},{"line":72,"address":[],"length":0,"stats":{"Line":72}},{"line":73,"address":[],"length":0,"stats":{"Line":72}},{"line":74,"address":[],"length":0,"stats":{"Line":72}},{"line":77,"address":[],"length":0,"stats":{"Line":72}},{"line":80,"address":[],"length":0,"stats":{"Line":144}},{"line":88,"address":[],"length":0,"stats":{"Line":70}},{"line":89,"address":[],"length":0,"stats":{"Line":70}},{"line":90,"address":[],"length":0,"stats":{"Line":70}},{"line":94,"address":[],"length":0,"stats":{"Line":70}},{"line":95,"address":[],"length":0,"stats":{"Line":70}},{"line":96,"address":[],"length":0,"stats":{"Line":70}},{"line":99,"address":[],"length":0,"stats":{"Line":70}},{"line":100,"address":[],"length":0,"stats":{"Line":70}},{"line":104,"address":[],"length":0,"stats":{"Line":70}},{"line":108,"address":[],"length":0,"stats":{"Line":70}},{"line":112,"address":[],"length":0,"stats":{"Line":70}},{"line":115,"address":[],"length":0,"stats":{"Line":70}},{"line":119,"address":[],"length":0,"stats":{"Line":395}},{"line":125,"address":[],"length":0,"stats":{"Line":395}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":126}},{"line":140,"address":[],"length":0,"stats":{"Line":126}},{"line":141,"address":[],"length":0,"stats":{"Line":126}},{"line":142,"address":[],"length":0,"stats":{"Line":126}},{"line":143,"address":[],"length":0,"stats":{"Line":126}},{"line":144,"address":[],"length":0,"stats":{"Line":126}},{"line":146,"address":[],"length":0,"stats":{"Line":126}},{"line":147,"address":[],"length":0,"stats":{"Line":126}},{"line":148,"address":[],"length":0,"stats":{"Line":126}},{"line":149,"address":[],"length":0,"stats":{"Line":126}},{"line":150,"address":[],"length":0,"stats":{"Line":126}},{"line":151,"address":[],"length":0,"stats":{"Line":126}},{"line":152,"address":[],"length":0,"stats":{"Line":126}},{"line":153,"address":[],"length":0,"stats":{"Line":126}},{"line":154,"address":[],"length":0,"stats":{"Line":126}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":19}},{"line":166,"address":[],"length":0,"stats":{"Line":19}},{"line":167,"address":[],"length":0,"stats":{"Line":19}},{"line":169,"address":[],"length":0,"stats":{"Line":64}},{"line":170,"address":[],"length":0,"stats":{"Line":64}},{"line":171,"address":[],"length":0,"stats":{"Line":64}},{"line":172,"address":[],"length":0,"stats":{"Line":64}},{"line":173,"address":[],"length":0,"stats":{"Line":64}},{"line":174,"address":[],"length":0,"stats":{"Line":64}},{"line":175,"address":[],"length":0,"stats":{"Line":64}},{"line":177,"address":[],"length":0,"stats":{"Line":64}},{"line":178,"address":[],"length":0,"stats":{"Line":64}},{"line":179,"address":[],"length":0,"stats":{"Line":64}},{"line":180,"address":[],"length":0,"stats":{"Line":64}},{"line":181,"address":[],"length":0,"stats":{"Line":64}},{"line":182,"address":[],"length":0,"stats":{"Line":64}},{"line":183,"address":[],"length":0,"stats":{"Line":64}},{"line":184,"address":[],"length":0,"stats":{"Line":64}},{"line":185,"address":[],"length":0,"stats":{"Line":64}},{"line":186,"address":[],"length":0,"stats":{"Line":64}},{"line":189,"address":[],"length":0,"stats":{"Line":7}},{"line":190,"address":[],"length":0,"stats":{"Line":7}},{"line":191,"address":[],"length":0,"stats":{"Line":7}},{"line":192,"address":[],"length":0,"stats":{"Line":7}},{"line":193,"address":[],"length":0,"stats":{"Line":7}},{"line":194,"address":[],"length":0,"stats":{"Line":7}},{"line":196,"address":[],"length":0,"stats":{"Line":7}},{"line":197,"address":[],"length":0,"stats":{"Line":7}},{"line":198,"address":[],"length":0,"stats":{"Line":7}},{"line":199,"address":[],"length":0,"stats":{"Line":7}},{"line":200,"address":[],"length":0,"stats":{"Line":7}},{"line":201,"address":[],"length":0,"stats":{"Line":7}},{"line":202,"address":[],"length":0,"stats":{"Line":7}},{"line":203,"address":[],"length":0,"stats":{"Line":7}},{"line":207,"address":[],"length":0,"stats":{"Line":3}},{"line":208,"address":[],"length":0,"stats":{"Line":3}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":5}},{"line":217,"address":[],"length":0,"stats":{"Line":5}},{"line":218,"address":[],"length":0,"stats":{"Line":5}},{"line":220,"address":[],"length":0,"stats":{"Line":5}},{"line":221,"address":[],"length":0,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":5}},{"line":223,"address":[],"length":0,"stats":{"Line":5}},{"line":224,"address":[],"length":0,"stats":{"Line":5}},{"line":227,"address":[],"length":0,"stats":{"Line":111}},{"line":228,"address":[],"length":0,"stats":{"Line":111}},{"line":229,"address":[],"length":0,"stats":{"Line":111}},{"line":230,"address":[],"length":0,"stats":{"Line":111}},{"line":232,"address":[],"length":0,"stats":{"Line":111}},{"line":233,"address":[],"length":0,"stats":{"Line":111}},{"line":234,"address":[],"length":0,"stats":{"Line":111}},{"line":235,"address":[],"length":0,"stats":{"Line":111}},{"line":236,"address":[],"length":0,"stats":{"Line":111}},{"line":237,"address":[],"length":0,"stats":{"Line":111}},{"line":240,"address":[],"length":0,"stats":{"Line":5}},{"line":241,"address":[],"length":0,"stats":{"Line":5}},{"line":242,"address":[],"length":0,"stats":{"Line":5}},{"line":243,"address":[],"length":0,"stats":{"Line":5}},{"line":244,"address":[],"length":0,"stats":{"Line":5}},{"line":245,"address":[],"length":0,"stats":{"Line":5}},{"line":247,"address":[],"length":0,"stats":{"Line":5}},{"line":248,"address":[],"length":0,"stats":{"Line":5}},{"line":249,"address":[],"length":0,"stats":{"Line":5}},{"line":250,"address":[],"length":0,"stats":{"Line":5}},{"line":251,"address":[],"length":0,"stats":{"Line":5}},{"line":252,"address":[],"length":0,"stats":{"Line":5}},{"line":253,"address":[],"length":0,"stats":{"Line":5}},{"line":254,"address":[],"length":0,"stats":{"Line":5}},{"line":256,"address":[],"length":0,"stats":{"Line":4}},{"line":258,"address":[],"length":0,"stats":{"Line":8}},{"line":259,"address":[],"length":0,"stats":{"Line":8}},{"line":260,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":5}},{"line":265,"address":[],"length":0,"stats":{"Line":16}},{"line":266,"address":[],"length":0,"stats":{"Line":16}},{"line":267,"address":[],"length":0,"stats":{"Line":16}},{"line":269,"address":[],"length":0,"stats":{"Line":16}},{"line":270,"address":[],"length":0,"stats":{"Line":16}},{"line":271,"address":[],"length":0,"stats":{"Line":16}},{"line":272,"address":[],"length":0,"stats":{"Line":16}},{"line":273,"address":[],"length":0,"stats":{"Line":16}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":64}},{"line":297,"address":[],"length":0,"stats":{"Line":128}},{"line":298,"address":[],"length":0,"stats":{"Line":1}},{"line":300,"address":[],"length":0,"stats":{"Line":126}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":62}},{"line":309,"address":[],"length":0,"stats":{"Line":62}},{"line":311,"address":[],"length":0,"stats":{"Line":62}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":325,"address":[],"length":0,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":61}},{"line":329,"address":[],"length":0,"stats":{"Line":59}},{"line":330,"address":[],"length":0,"stats":{"Line":56}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":57}},{"line":349,"address":[],"length":0,"stats":{"Line":57}},{"line":350,"address":[],"length":0,"stats":{"Line":57}},{"line":351,"address":[],"length":0,"stats":{"Line":57}},{"line":352,"address":[],"length":0,"stats":{"Line":57}},{"line":357,"address":[],"length":0,"stats":{"Line":56}},{"line":358,"address":[],"length":0,"stats":{"Line":56}},{"line":359,"address":[],"length":0,"stats":{"Line":56}},{"line":362,"address":[],"length":0,"stats":{"Line":56}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":56}},{"line":379,"address":[],"length":0,"stats":{"Line":56}},{"line":382,"address":[],"length":0,"stats":{"Line":56}},{"line":383,"address":[],"length":0,"stats":{"Line":56}},{"line":384,"address":[],"length":0,"stats":{"Line":56}},{"line":386,"address":[],"length":0,"stats":{"Line":56}},{"line":387,"address":[],"length":0,"stats":{"Line":56}},{"line":389,"address":[],"length":0,"stats":{"Line":56}},{"line":392,"address":[],"length":0,"stats":{"Line":4}},{"line":397,"address":[],"length":0,"stats":{"Line":4}},{"line":398,"address":[],"length":0,"stats":{"Line":6}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":425,"address":[],"length":0,"stats":{"Line":8}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":6}},{"line":442,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":1}},{"line":448,"address":[],"length":0,"stats":{"Line":1}},{"line":450,"address":[],"length":0,"stats":{"Line":1}},{"line":454,"address":[],"length":0,"stats":{"Line":126}},{"line":465,"address":[],"length":0,"stats":{"Line":252}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":252}},{"line":478,"address":[],"length":0,"stats":{"Line":125}},{"line":480,"address":[],"length":0,"stats":{"Line":127}},{"line":482,"address":[],"length":0,"stats":{"Line":123}},{"line":486,"address":[],"length":0,"stats":{"Line":123}},{"line":487,"address":[],"length":0,"stats":{"Line":123}},{"line":488,"address":[],"length":0,"stats":{"Line":123}},{"line":493,"address":[],"length":0,"stats":{"Line":123}},{"line":494,"address":[],"length":0,"stats":{"Line":123}},{"line":495,"address":[],"length":0,"stats":{"Line":123}},{"line":497,"address":[],"length":0,"stats":{"Line":125}},{"line":499,"address":[],"length":0,"stats":{"Line":2}},{"line":500,"address":[],"length":0,"stats":{"Line":2}},{"line":501,"address":[],"length":0,"stats":{"Line":2}},{"line":502,"address":[],"length":0,"stats":{"Line":2}},{"line":503,"address":[],"length":0,"stats":{"Line":2}},{"line":504,"address":[],"length":0,"stats":{"Line":2}},{"line":509,"address":[],"length":0,"stats":{"Line":122}},{"line":511,"address":[],"length":0,"stats":{"Line":122}},{"line":512,"address":[],"length":0,"stats":{"Line":122}},{"line":513,"address":[],"length":0,"stats":{"Line":122}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":516,"address":[],"length":0,"stats":{"Line":1}},{"line":518,"address":[],"length":0,"stats":{"Line":122}},{"line":521,"address":[],"length":0,"stats":{"Line":4}},{"line":527,"address":[],"length":0,"stats":{"Line":8}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":8}},{"line":540,"address":[],"length":0,"stats":{"Line":3}},{"line":541,"address":[],"length":0,"stats":{"Line":3}},{"line":542,"address":[],"length":0,"stats":{"Line":4}},{"line":544,"address":[],"length":0,"stats":{"Line":2}},{"line":546,"address":[],"length":0,"stats":{"Line":2}},{"line":547,"address":[],"length":0,"stats":{"Line":2}},{"line":549,"address":[],"length":0,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":4}},{"line":558,"address":[],"length":0,"stats":{"Line":8}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":8}},{"line":571,"address":[],"length":0,"stats":{"Line":3}},{"line":572,"address":[],"length":0,"stats":{"Line":3}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":3}},{"line":585,"address":[],"length":0,"stats":{"Line":7}},{"line":588,"address":[],"length":0,"stats":{"Line":3}},{"line":590,"address":[],"length":0,"stats":{"Line":3}},{"line":591,"address":[],"length":0,"stats":{"Line":3}},{"line":592,"address":[],"length":0,"stats":{"Line":3}},{"line":594,"address":[],"length":0,"stats":{"Line":3}},{"line":597,"address":[],"length":0,"stats":{"Line":19}},{"line":603,"address":[],"length":0,"stats":{"Line":38}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":38}},{"line":616,"address":[],"length":0,"stats":{"Line":18}},{"line":617,"address":[],"length":0,"stats":{"Line":20}},{"line":619,"address":[],"length":0,"stats":{"Line":16}},{"line":621,"address":[],"length":0,"stats":{"Line":16}},{"line":622,"address":[],"length":0,"stats":{"Line":16}},{"line":624,"address":[],"length":0,"stats":{"Line":16}},{"line":627,"address":[],"length":0,"stats":{"Line":2}},{"line":628,"address":[],"length":0,"stats":{"Line":4}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":2}},{"line":633,"address":[],"length":0,"stats":{"Line":2}},{"line":634,"address":[],"length":0,"stats":{"Line":2}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":16}},{"line":677,"address":[],"length":0,"stats":{"Line":32}},{"line":688,"address":[],"length":0,"stats":{"Line":30}},{"line":699,"address":[],"length":0,"stats":{"Line":13}},{"line":701,"address":[],"length":0,"stats":{"Line":13}},{"line":702,"address":[],"length":0,"stats":{"Line":13}},{"line":703,"address":[],"length":0,"stats":{"Line":13}},{"line":705,"address":[],"length":0,"stats":{"Line":13}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":7}},{"line":754,"address":[],"length":0,"stats":{"Line":14}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":14}},{"line":769,"address":[],"length":0,"stats":{"Line":4}},{"line":770,"address":[],"length":0,"stats":{"Line":4}},{"line":772,"address":[],"length":0,"stats":{"Line":1}},{"line":776,"address":[],"length":0,"stats":{"Line":1}},{"line":780,"address":[],"length":0,"stats":{"Line":1}},{"line":784,"address":[],"length":0,"stats":{"Line":1}},{"line":787,"address":[],"length":0,"stats":{"Line":3}},{"line":789,"address":[],"length":0,"stats":{"Line":1}},{"line":790,"address":[],"length":0,"stats":{"Line":1}},{"line":791,"address":[],"length":0,"stats":{"Line":1}},{"line":792,"address":[],"length":0,"stats":{"Line":1}},{"line":795,"address":[],"length":0,"stats":{"Line":2}},{"line":796,"address":[],"length":0,"stats":{"Line":1}},{"line":804,"address":[],"length":0,"stats":{"Line":1}},{"line":806,"address":[],"length":0,"stats":{"Line":1}},{"line":808,"address":[],"length":0,"stats":{"Line":1}},{"line":811,"address":[],"length":0,"stats":{"Line":3}},{"line":817,"address":[],"length":0,"stats":{"Line":6}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":6}},{"line":830,"address":[],"length":0,"stats":{"Line":2}},{"line":831,"address":[],"length":0,"stats":{"Line":3}},{"line":833,"address":[],"length":0,"stats":{"Line":1}},{"line":835,"address":[],"length":0,"stats":{"Line":1}},{"line":836,"address":[],"length":0,"stats":{"Line":1}},{"line":838,"address":[],"length":0,"stats":{"Line":1}},{"line":840,"address":[],"length":0,"stats":{"Line":111}},{"line":848,"address":[],"length":0,"stats":{"Line":222}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":222}},{"line":861,"address":[],"length":0,"stats":{"Line":111}},{"line":864,"address":[],"length":0,"stats":{"Line":111}},{"line":865,"address":[],"length":0,"stats":{"Line":111}},{"line":866,"address":[],"length":0,"stats":{"Line":111}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":110}},{"line":875,"address":[],"length":0,"stats":{"Line":110}},{"line":876,"address":[],"length":0,"stats":{"Line":110}},{"line":877,"address":[],"length":0,"stats":{"Line":110}},{"line":878,"address":[],"length":0,"stats":{"Line":110}},{"line":881,"address":[],"length":0,"stats":{"Line":108}},{"line":883,"address":[],"length":0,"stats":{"Line":108}},{"line":884,"address":[],"length":0,"stats":{"Line":108}},{"line":885,"address":[],"length":0,"stats":{"Line":108}},{"line":887,"address":[],"length":0,"stats":{"Line":108}},{"line":889,"address":[],"length":0,"stats":{"Line":4}},{"line":896,"address":[],"length":0,"stats":{"Line":8}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":8}},{"line":909,"address":[],"length":0,"stats":{"Line":3}},{"line":910,"address":[],"length":0,"stats":{"Line":3}},{"line":912,"address":[],"length":0,"stats":{"Line":3}},{"line":913,"address":[],"length":0,"stats":{"Line":3}},{"line":914,"address":[],"length":0,"stats":{"Line":3}},{"line":915,"address":[],"length":0,"stats":{"Line":3}},{"line":916,"address":[],"length":0,"stats":{"Line":3}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":5}},{"line":938,"address":[],"length":0,"stats":{"Line":10}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":10}},{"line":951,"address":[],"length":0,"stats":{"Line":4}},{"line":952,"address":[],"length":0,"stats":{"Line":4}},{"line":953,"address":[],"length":0,"stats":{"Line":4}},{"line":954,"address":[],"length":0,"stats":{"Line":3}},{"line":956,"address":[],"length":0,"stats":{"Line":3}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":3}},{"line":961,"address":[],"length":0,"stats":{"Line":4}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":1}},{"line":966,"address":[],"length":0,"stats":{"Line":4}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":1}},{"line":970,"address":[],"length":0,"stats":{"Line":5}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":3}},{"line":977,"address":[],"length":0,"stats":{"Line":3}},{"line":979,"address":[],"length":0,"stats":{"Line":3}},{"line":980,"address":[],"length":0,"stats":{"Line":3}},{"line":981,"address":[],"length":0,"stats":{"Line":3}},{"line":982,"address":[],"length":0,"stats":{"Line":3}},{"line":983,"address":[],"length":0,"stats":{"Line":3}},{"line":984,"address":[],"length":0,"stats":{"Line":3}},{"line":986,"address":[],"length":0,"stats":{"Line":3}},{"line":989,"address":[],"length":0,"stats":{"Line":5}},{"line":996,"address":[],"length":0,"stats":{"Line":10}},{"line":999,"address":[],"length":0,"stats":{"Line":2}},{"line":1002,"address":[],"length":0,"stats":{"Line":3}},{"line":1003,"address":[],"length":0,"stats":{"Line":3}},{"line":1007,"address":[],"length":0,"stats":{"Line":4}},{"line":1008,"address":[],"length":0,"stats":{"Line":2}},{"line":1012,"address":[],"length":0,"stats":{"Line":4}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":2}},{"line":1022,"address":[],"length":0,"stats":{"Line":2}},{"line":1026,"address":[],"length":0,"stats":{"Line":2}},{"line":1029,"address":[],"length":0,"stats":{"Line":2}},{"line":1032,"address":[],"length":0,"stats":{"Line":8}},{"line":1038,"address":[],"length":0,"stats":{"Line":16}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":16}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":8}},{"line":1049,"address":[],"length":0,"stats":{"Line":8}},{"line":1050,"address":[],"length":0,"stats":{"Line":8}},{"line":1051,"address":[],"length":0,"stats":{"Line":8}},{"line":1053,"address":[],"length":0,"stats":{"Line":6}},{"line":1054,"address":[],"length":0,"stats":{"Line":2}},{"line":1055,"address":[],"length":0,"stats":{"Line":4}},{"line":1056,"address":[],"length":0,"stats":{"Line":16}},{"line":1057,"address":[],"length":0,"stats":{"Line":4}},{"line":1060,"address":[],"length":0,"stats":{"Line":9}},{"line":1061,"address":[],"length":0,"stats":{"Line":8}},{"line":1062,"address":[],"length":0,"stats":{"Line":1}},{"line":1063,"address":[],"length":0,"stats":{"Line":2}},{"line":1067,"address":[],"length":0,"stats":{"Line":5}},{"line":1069,"address":[],"length":0,"stats":{"Line":5}},{"line":1072,"address":[],"length":0,"stats":{"Line":5}},{"line":1078,"address":[],"length":0,"stats":{"Line":10}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":10}},{"line":1083,"address":[],"length":0,"stats":{"Line":1}},{"line":1086,"address":[],"length":0,"stats":{"Line":4}},{"line":1089,"address":[],"length":0,"stats":{"Line":1}},{"line":1092,"address":[],"length":0,"stats":{"Line":2}},{"line":1093,"address":[],"length":0,"stats":{"Line":2}},{"line":1096,"address":[],"length":0,"stats":{"Line":2}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":2}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":2}},{"line":1103,"address":[],"length":0,"stats":{"Line":2}},{"line":1104,"address":[],"length":0,"stats":{"Line":2}},{"line":1106,"address":[],"length":0,"stats":{"Line":2}},{"line":1107,"address":[],"length":0,"stats":{"Line":2}},{"line":1109,"address":[],"length":0,"stats":{"Line":2}},{"line":1112,"address":[],"length":0,"stats":{"Line":3}},{"line":1118,"address":[],"length":0,"stats":{"Line":6}},{"line":1120,"address":[],"length":0,"stats":{"Line":1}},{"line":1123,"address":[],"length":0,"stats":{"Line":2}},{"line":1124,"address":[],"length":0,"stats":{"Line":2}},{"line":1127,"address":[],"length":0,"stats":{"Line":2}},{"line":1128,"address":[],"length":0,"stats":{"Line":3}},{"line":1132,"address":[],"length":0,"stats":{"Line":1}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1138,"address":[],"length":0,"stats":{"Line":1}},{"line":1139,"address":[],"length":0,"stats":{"Line":1}},{"line":1140,"address":[],"length":0,"stats":{"Line":1}},{"line":1143,"address":[],"length":0,"stats":{"Line":1}},{"line":1150,"address":[],"length":0,"stats":{"Line":2}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":1}},{"line":1154,"address":[],"length":0,"stats":{"Line":1}},{"line":1155,"address":[],"length":0,"stats":{"Line":1}},{"line":1156,"address":[],"length":0,"stats":{"Line":1}},{"line":1157,"address":[],"length":0,"stats":{"Line":1}},{"line":1158,"address":[],"length":0,"stats":{"Line":1}},{"line":1161,"address":[],"length":0,"stats":{"Line":1}},{"line":1162,"address":[],"length":0,"stats":{"Line":1}},{"line":1163,"address":[],"length":0,"stats":{"Line":1}},{"line":1164,"address":[],"length":0,"stats":{"Line":1}},{"line":1165,"address":[],"length":0,"stats":{"Line":1}},{"line":1168,"address":[],"length":0,"stats":{"Line":47}},{"line":1169,"address":[],"length":0,"stats":{"Line":47}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[],"length":0,"stats":{"Line":7}},{"line":1174,"address":[],"length":0,"stats":{"Line":8}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":10}},{"line":1181,"address":[],"length":0,"stats":{"Line":10}},{"line":1182,"address":[],"length":0,"stats":{"Line":10}},{"line":1183,"address":[],"length":0,"stats":{"Line":1}},{"line":1184,"address":[],"length":0,"stats":{"Line":1}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1188,"address":[],"length":0,"stats":{"Line":7}},{"line":1189,"address":[],"length":0,"stats":{"Line":7}},{"line":1190,"address":[],"length":0,"stats":{"Line":7}},{"line":1191,"address":[],"length":0,"stats":{"Line":7}},{"line":1192,"address":[],"length":0,"stats":{"Line":3}},{"line":1194,"address":[],"length":0,"stats":{"Line":3}},{"line":1195,"address":[],"length":0,"stats":{"Line":3}},{"line":1196,"address":[],"length":0,"stats":{"Line":3}},{"line":1197,"address":[],"length":0,"stats":{"Line":3}},{"line":1199,"address":[],"length":0,"stats":{"Line":5}},{"line":1200,"address":[],"length":0,"stats":{"Line":5}},{"line":1201,"address":[],"length":0,"stats":{"Line":5}},{"line":1202,"address":[],"length":0,"stats":{"Line":8}},{"line":1203,"address":[],"length":0,"stats":{"Line":8}},{"line":1206,"address":[],"length":0,"stats":{"Line":1}},{"line":1207,"address":[],"length":0,"stats":{"Line":1}},{"line":1208,"address":[],"length":0,"stats":{"Line":1}},{"line":1209,"address":[],"length":0,"stats":{"Line":1}},{"line":1210,"address":[],"length":0,"stats":{"Line":1}},{"line":1211,"address":[],"length":0,"stats":{"Line":1}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1218,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":1}},{"line":1224,"address":[],"length":0,"stats":{"Line":1}},{"line":1227,"address":[],"length":0,"stats":{"Line":1}},{"line":1228,"address":[],"length":0,"stats":{"Line":1}},{"line":1229,"address":[],"length":0,"stats":{"Line":1}},{"line":1230,"address":[],"length":0,"stats":{"Line":1}},{"line":1234,"address":[],"length":0,"stats":{"Line":7}},{"line":1235,"address":[],"length":0,"stats":{"Line":7}},{"line":1236,"address":[],"length":0,"stats":{"Line":14}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":1}},{"line":1251,"address":[],"length":0,"stats":{"Line":1}},{"line":1252,"address":[],"length":0,"stats":{"Line":2}},{"line":1253,"address":[],"length":0,"stats":{"Line":1}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":1}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":1}},{"line":1259,"address":[],"length":0,"stats":{"Line":1}},{"line":1260,"address":[],"length":0,"stats":{"Line":1}},{"line":1261,"address":[],"length":0,"stats":{"Line":1}},{"line":1262,"address":[],"length":0,"stats":{"Line":1}},{"line":1263,"address":[],"length":0,"stats":{"Line":1}},{"line":1264,"address":[],"length":0,"stats":{"Line":1}},{"line":1265,"address":[],"length":0,"stats":{"Line":1}},{"line":1266,"address":[],"length":0,"stats":{"Line":1}},{"line":1267,"address":[],"length":0,"stats":{"Line":1}},{"line":1268,"address":[],"length":0,"stats":{"Line":1}},{"line":1269,"address":[],"length":0,"stats":{"Line":1}},{"line":1273,"address":[],"length":0,"stats":{"Line":1}},{"line":1278,"address":[],"length":0,"stats":{"Line":1}},{"line":1279,"address":[],"length":0,"stats":{"Line":2}},{"line":1280,"address":[],"length":0,"stats":{"Line":1}},{"line":1282,"address":[],"length":0,"stats":{"Line":1}},{"line":1284,"address":[],"length":0,"stats":{"Line":1}},{"line":1287,"address":[],"length":0,"stats":{"Line":10}},{"line":1292,"address":[],"length":0,"stats":{"Line":10}},{"line":1293,"address":[],"length":0,"stats":{"Line":10}},{"line":1294,"address":[],"length":0,"stats":{"Line":10}},{"line":1298,"address":[],"length":0,"stats":{"Line":7}},{"line":1304,"address":[],"length":0,"stats":{"Line":7}},{"line":1305,"address":[],"length":0,"stats":{"Line":14}},{"line":1306,"address":[],"length":0,"stats":{"Line":7}},{"line":1307,"address":[],"length":0,"stats":{"Line":7}},{"line":1308,"address":[],"length":0,"stats":{"Line":7}},{"line":1309,"address":[],"length":0,"stats":{"Line":7}},{"line":1314,"address":[],"length":0,"stats":{"Line":0}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1323,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":3}},{"line":1339,"address":[],"length":0,"stats":{"Line":3}},{"line":1340,"address":[],"length":0,"stats":{"Line":3}},{"line":1341,"address":[],"length":0,"stats":{"Line":3}},{"line":1345,"address":[],"length":0,"stats":{"Line":5}},{"line":1350,"address":[],"length":0,"stats":{"Line":5}},{"line":1351,"address":[],"length":0,"stats":{"Line":5}},{"line":1352,"address":[],"length":0,"stats":{"Line":10}},{"line":1353,"address":[],"length":0,"stats":{"Line":5}},{"line":1354,"address":[],"length":0,"stats":{"Line":5}},{"line":1355,"address":[],"length":0,"stats":{"Line":5}},{"line":1356,"address":[],"length":0,"stats":{"Line":5}},{"line":1357,"address":[],"length":0,"stats":{"Line":5}},{"line":1358,"address":[],"length":0,"stats":{"Line":5}},{"line":1361,"address":[],"length":0,"stats":{"Line":8}},{"line":1366,"address":[],"length":0,"stats":{"Line":8}},{"line":1367,"address":[],"length":0,"stats":{"Line":16}},{"line":1371,"address":[],"length":0,"stats":{"Line":1}},{"line":1376,"address":[],"length":0,"stats":{"Line":1}},{"line":1377,"address":[],"length":0,"stats":{"Line":1}},{"line":1378,"address":[],"length":0,"stats":{"Line":1}},{"line":1386,"address":[],"length":0,"stats":{"Line":0}},{"line":1392,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1398,"address":[],"length":0,"stats":{"Line":1}},{"line":1399,"address":[],"length":0,"stats":{"Line":1}},{"line":1400,"address":[],"length":0,"stats":{"Line":2}},{"line":1404,"address":[],"length":0,"stats":{"Line":1}},{"line":1410,"address":[],"length":0,"stats":{"Line":1}},{"line":1411,"address":[],"length":0,"stats":{"Line":2}}],"covered":515,"coverable":619},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","error.rs"],"content":"use asset_manager::error::AssetError;\nuse asset_manager::error::PlaylistError;\nuse channel_manager::error::ChannelError;\nuse cosmwasm_std::{Coin, StdError};\nuse cw_utils::PaymentError;\nuse pauser::PauseError;\nuse thiserror::Error;\n\nuse crate::string_validation::StringValidationError;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(transparent)]\n    Pause(#[from] PauseError),\n\n    #[error(transparent)]\n    Channel(#[from] ChannelError),\n\n    #[error(transparent)]\n    Playlist(#[from] PlaylistError),\n\n    #[error(transparent)]\n    Asset(#[from] AssetError),\n\n    #[error(transparent)]\n    Payment(#[from] PaymentError),\n\n    #[error(transparent)]\n    StringValidationError(#[from] StringValidationError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Invalid minter code id\")]\n    InvalidMinterCodeId {},\n\n    #[error(\"Invalid Mint Denom\")]\n    InvalidMintDenom {},\n\n    #[error(\"Mint denom not allowed\")]\n    MintDenomNotAllowed {},\n\n    #[error(\"Missing creation fee\")]\n    MissingCreationFee {},\n\n    #[error(\"Missing minter creation fee\")]\n    MissingMinterCreationFee {},\n\n    #[error(\"Payment error\")]\n    PaymentError {\n        expected: Vec\u003cCoin\u003e,\n        received: Vec\u003cCoin\u003e,\n    },\n\n    #[error(\"Invalid ONFT data\")]\n    InvalidOnftData {},\n\n    #[error(\"Asset to be published not found\")]\n    AssetNotFound {},\n\n    #[error(\"ONFT not found collection_id: {collection_id} onft_id: {onft_id}\")]\n    OnftNotFound {\n        collection_id: String,\n        onft_id: String,\n    },\n\n    #[error(\"ONFT not owned collection_id: {collection_id} onft_id: {onft_id}\")]\n    OnftNotOwned {\n        collection_id: String,\n        onft_id: String,\n    },\n\n    #[error(\"Failed to fetch collection creation fee\")]\n    CollectionCreationFeeError {},\n\n    #[error(\"Username already taken\")]\n    UserNameAlreadyTaken {},\n\n    #[error(\"Username does not exist\")]\n    UserNameNotFound {},\n\n    #[error(\"Invalid channel query\")]\n    InvalidChannelQuery {},\n\n    #[error(\"Asset is not visible\")]\n    AssetNotVisible {},\n\n    #[error(\"Invalid user name\")]\n    InvalidUserName {},\n\n    #[error(\"Invalid description\")]\n    InvalidDescription {},\n\n    #[error(\"Username reserved\")]\n    UserNameReserved {},\n\n    #[error(\"Invalid link\")]\n    InvalidLink {},\n\n    #[error(\"Invalid channel name\")]\n    InvalidChannelName {},\n\n    #[error(\"Invalid tip denom\")]\n    InvalidTipDenom {},\n\n    #[error(\"Invalid tip amount\")]\n    InvalidTipAmount {},\n}\n\nimpl From\u003cContractError\u003e for StdError {\n    fn from(err: ContractError) -\u003e StdError {\n        StdError::generic_err(err.to_string())\n    }\n}\n","traces":[{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","helpers.rs"],"content":"use crate::access_control::get_onft_with_owner;\nuse crate::string_validation::{validate_string, StringValidationType};\nuse crate::ContractError;\nuse asset_manager::assets::AssetsManager;\nuse cosmwasm_std::{Addr, Api, Coin, Deps, Uint128};\nuse cosmwasm_std::{CosmosMsg, Storage};\nuse omniflix_channel_types::asset::{AssetKey, AssetMetadata, AssetSource};\nuse omniflix_channel_types::channel::{ChannelDetails, ChannelMetadata};\nuse omniflix_channel_types::msg::{\n    ChannelTokenDetails, ChannelsCollectionDetails, ReservedUsername,\n};\nuse omniflix_std::types::omniflix::onft::v1beta1::{Metadata, OnftQuerier};\nuse std::str::FromStr;\n\npub fn get_collection_creation_fee(deps: Deps) -\u003e Result\u003cCoin, ContractError\u003e {\n    let onft_querier = OnftQuerier::new(\u0026deps.querier);\n    let collection_creation_fee = onft_querier\n        .params()\n        .map_err(|_| ContractError::CollectionCreationFeeError {})?\n        .params\n        .ok_or_else(|| ContractError::CollectionCreationFeeError {})?\n        .denom_creation_fee\n        .ok_or_else(|| ContractError::CollectionCreationFeeError {})?;\n    // Convert omniflix std Coin to cosmwasm Coin\n    let collection_creation_fee = Coin {\n        denom: collection_creation_fee.denom,\n        amount: Uint128::from_str(\u0026collection_creation_fee.amount)\n            .map_err(|_| ContractError::CollectionCreationFeeError {})?,\n    };\n    Ok(collection_creation_fee)\n}\n/// Purpose: Filters out assets that do not exist in storage or are not visible\npub fn filter_assets_to_remove(storage: \u0026dyn Storage, asset_keys: Vec\u003cAssetKey\u003e) -\u003e Vec\u003cAssetKey\u003e {\n    let asset_manager = AssetsManager::new();\n\n    asset_keys\n        .into_iter()\n        .filter(\n            |asset_key| match asset_manager.get_asset(storage, asset_key.clone()) {\n                Ok(asset) =\u003e !asset.is_visible,\n                Err(_) =\u003e true,\n            },\n        )\n        .collect()\n}\n\n/// Validates the channel metadata, including optional fields\npub fn validate_channel_metadata(metadata: ChannelMetadata) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\u0026metadata.channel_name, StringValidationType::ChannelName)?;\n\n    if let Some(description) = \u0026metadata.description {\n        validate_string(description, StringValidationType::Description)?;\n    }\n    if let Some(profile_picture) = \u0026metadata.profile_picture {\n        validate_string(profile_picture, StringValidationType::Link)?;\n    }\n    if let Some(banner_picture) = \u0026metadata.banner_picture {\n        validate_string(banner_picture, StringValidationType::Link)?;\n    }\n\n    Ok(())\n}\n\npub fn validate_channel_details(details: ChannelDetails) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\u0026details.user_name, StringValidationType::Username)?;\n    Ok(())\n}\n\n/// Validates reserved usernames with their associated addresses\npub fn validate_reserved_usernames(\n    reserved_usernames: Vec\u003cReservedUsername\u003e,\n    api: \u0026dyn Api,\n) -\u003e Result\u003cVec\u003cReservedUsername\u003e, ContractError\u003e {\n    reserved_usernames\n        .into_iter()\n        .map(|reserved_username| {\n            validate_string(\n                \u0026reserved_username.username.clone(),\n                StringValidationType::Username,\n            )?;\n            if let Some(address) = \u0026reserved_username.address {\n                api.addr_validate(address.as_ref())?;\n            }\n            Ok(reserved_username)\n        })\n        .collect()\n}\n\npub fn validate_asset_source(\n    deps: Deps,\n    asset_source: AssetSource,\n    owner: Addr,\n) -\u003e Result\u003c(), ContractError\u003e {\n    match asset_source {\n        AssetSource::Nft {\n            collection_id,\n            onft_id,\n        } =\u003e {\n            get_onft_with_owner(deps, collection_id, onft_id, owner.to_string())?;\n            Ok(())\n        }\n        AssetSource::OffChain {} =\u003e Ok(()),\n    }\n}\n\npub fn validate_asset_metadata(metadata: AssetMetadata) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\u0026metadata.name, StringValidationType::AssetName)?;\n    validate_string(\u0026metadata.description, StringValidationType::Description)?;\n    validate_string(\u0026metadata.media_uri, StringValidationType::Link)?;\n    Ok(())\n}\n\npub fn validate_channel_token_details(\n    channel_token_details: ChannelTokenDetails,\n) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\u0026channel_token_details.media_uri, StringValidationType::Link)?;\n    validate_string(\n        \u0026channel_token_details.preview_uri,\n        StringValidationType::Link,\n    )?;\n    validate_string(\n        \u0026channel_token_details.description,\n        StringValidationType::Description,\n    )?;\n    Ok(())\n}\n\npub fn validate_channel_collection_details(\n    collection_details: ChannelsCollectionDetails,\n) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\n        \u0026collection_details.description,\n        StringValidationType::Description,\n    )?;\n    validate_string(\u0026collection_details.preview_uri, StringValidationType::Link)?;\n    validate_string(\u0026collection_details.uri, StringValidationType::Link)?;\n    Ok(())\n}\n\npub fn generate_mint_onft_msg(\n    onft_id: String,\n    denom_id: String,\n    contract_address: String,\n    recipient: String,\n    onft_data: String,\n    user_name: String,\n    channel_token_details: ChannelTokenDetails,\n) -\u003e (CosmosMsg, Vec\u003c(String, String)\u003e) {\n    // Create the mint message\n    let mint_onft_msg: CosmosMsg = omniflix_std::types::omniflix::onft::v1beta1::MsgMintOnft {\n        id: onft_id.clone(),\n        denom_id: denom_id.clone(),\n        sender: contract_address,\n        recipient: recipient.clone(),\n        data: onft_data.clone(),\n        metadata: Some(Metadata {\n            media_uri: channel_token_details.media_uri,\n            name: user_name.clone(),\n            description: channel_token_details.description,\n            preview_uri: channel_token_details.preview_uri,\n            uri_hash: channel_token_details.uri_hash,\n        }),\n        nsfw: channel_token_details.nsfw,\n        extensible: channel_token_details.extensible,\n        royalty_share: channel_token_details.royalty_share,\n        transferable: channel_token_details.transferable,\n    }\n    .into();\n\n    // Generate detailed attributes\n    let attributes = vec![\n        // ONFT\n        (\"denom_id\".to_string(), denom_id.clone()),\n        (\"onft_id\".to_string(), onft_id.clone()),\n        (\"owner\".to_string(), recipient.clone()),\n        // Metadata\n        (\"name\".to_string(), user_name.clone()),\n        (\"description\".to_string(), \"\".to_string()),\n        (\"media_uri\".to_string(), \"\".to_string()),\n        (\"preview_uri\".to_string(), \"\".to_string()),\n        (\"uri_hash\".to_string(), \"\".to_string()),\n        // Other\n        (\"nsfw\".to_string(), \"false\".to_string()),\n        (\"data\".to_string(), onft_data.clone()),\n        (\"extensible\".to_string(), \"false\".to_string()),\n        (\"royalty_share\".to_string(), \"0\".to_string()),\n        (\"transferable\".to_string(), \"true\".to_string()),\n        (\"created_at\".to_string(), \"\".to_string()),\n    ];\n\n    (mint_onft_msg, attributes)\n}\n\npub fn generate_create_denom_msg(\n    collection_details: ChannelsCollectionDetails,\n    contract_address: String,\n    creation_fee: Coin,\n) -\u003e CosmosMsg {\n    omniflix_std::types::omniflix::onft::v1beta1::MsgCreateDenom {\n        id: collection_details.collection_id,\n        name: collection_details.collection_name,\n        symbol: collection_details.collection_symbol,\n        description: collection_details.description,\n        preview_uri: collection_details.preview_uri,\n        schema: collection_details.schema,\n        sender: contract_address,\n        creation_fee: Some(creation_fee.into()),\n        uri: collection_details.uri,\n        uri_hash: \"\".to_string(),\n        data: \"\".to_string(),\n        royalty_receivers: vec![],\n    }\n    .into()\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":72}},{"line":16,"address":[],"length":0,"stats":{"Line":72}},{"line":17,"address":[],"length":0,"stats":{"Line":144}},{"line":18,"address":[],"length":0,"stats":{"Line":72}},{"line":19,"address":[],"length":0,"stats":{"Line":144}},{"line":21,"address":[],"length":0,"stats":{"Line":72}},{"line":23,"address":[],"length":0,"stats":{"Line":72}},{"line":30,"address":[],"length":0,"stats":{"Line":72}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":64}},{"line":49,"address":[],"length":0,"stats":{"Line":65}},{"line":51,"address":[],"length":0,"stats":{"Line":126}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":63}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":62}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":60}},{"line":64,"address":[],"length":0,"stats":{"Line":61}},{"line":65,"address":[],"length":0,"stats":{"Line":62}},{"line":66,"address":[],"length":0,"stats":{"Line":60}},{"line":70,"address":[],"length":0,"stats":{"Line":76}},{"line":74,"address":[],"length":0,"stats":{"Line":76}},{"line":76,"address":[],"length":0,"stats":{"Line":153}},{"line":77,"address":[],"length":0,"stats":{"Line":77}},{"line":78,"address":[],"length":0,"stats":{"Line":77}},{"line":79,"address":[],"length":0,"stats":{"Line":77}},{"line":81,"address":[],"length":0,"stats":{"Line":77}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":75}},{"line":89,"address":[],"length":0,"stats":{"Line":125}},{"line":94,"address":[],"length":0,"stats":{"Line":125}},{"line":96,"address":[],"length":0,"stats":{"Line":13}},{"line":97,"address":[],"length":0,"stats":{"Line":13}},{"line":98,"address":[],"length":0,"stats":{"Line":13}},{"line":99,"address":[],"length":0,"stats":{"Line":15}},{"line":100,"address":[],"length":0,"stats":{"Line":11}},{"line":102,"address":[],"length":0,"stats":{"Line":112}},{"line":106,"address":[],"length":0,"stats":{"Line":123}},{"line":107,"address":[],"length":0,"stats":{"Line":123}},{"line":108,"address":[],"length":0,"stats":{"Line":123}},{"line":109,"address":[],"length":0,"stats":{"Line":123}},{"line":110,"address":[],"length":0,"stats":{"Line":123}},{"line":113,"address":[],"length":0,"stats":{"Line":72}},{"line":116,"address":[],"length":0,"stats":{"Line":72}},{"line":118,"address":[],"length":0,"stats":{"Line":72}},{"line":119,"address":[],"length":0,"stats":{"Line":72}},{"line":122,"address":[],"length":0,"stats":{"Line":72}},{"line":123,"address":[],"length":0,"stats":{"Line":72}},{"line":125,"address":[],"length":0,"stats":{"Line":72}},{"line":128,"address":[],"length":0,"stats":{"Line":72}},{"line":132,"address":[],"length":0,"stats":{"Line":72}},{"line":133,"address":[],"length":0,"stats":{"Line":72}},{"line":135,"address":[],"length":0,"stats":{"Line":72}},{"line":136,"address":[],"length":0,"stats":{"Line":72}},{"line":137,"address":[],"length":0,"stats":{"Line":72}},{"line":140,"address":[],"length":0,"stats":{"Line":56}},{"line":151,"address":[],"length":0,"stats":{"Line":56}},{"line":152,"address":[],"length":0,"stats":{"Line":56}},{"line":154,"address":[],"length":0,"stats":{"Line":56}},{"line":155,"address":[],"length":0,"stats":{"Line":56}},{"line":156,"address":[],"length":0,"stats":{"Line":56}},{"line":163,"address":[],"length":0,"stats":{"Line":56}},{"line":164,"address":[],"length":0,"stats":{"Line":56}},{"line":165,"address":[],"length":0,"stats":{"Line":56}},{"line":166,"address":[],"length":0,"stats":{"Line":56}},{"line":171,"address":[],"length":0,"stats":{"Line":56}},{"line":173,"address":[],"length":0,"stats":{"Line":56}},{"line":174,"address":[],"length":0,"stats":{"Line":56}},{"line":175,"address":[],"length":0,"stats":{"Line":56}},{"line":177,"address":[],"length":0,"stats":{"Line":56}},{"line":178,"address":[],"length":0,"stats":{"Line":56}},{"line":179,"address":[],"length":0,"stats":{"Line":56}},{"line":180,"address":[],"length":0,"stats":{"Line":56}},{"line":181,"address":[],"length":0,"stats":{"Line":56}},{"line":183,"address":[],"length":0,"stats":{"Line":56}},{"line":184,"address":[],"length":0,"stats":{"Line":56}},{"line":185,"address":[],"length":0,"stats":{"Line":56}},{"line":186,"address":[],"length":0,"stats":{"Line":56}},{"line":187,"address":[],"length":0,"stats":{"Line":56}},{"line":188,"address":[],"length":0,"stats":{"Line":56}},{"line":191,"address":[],"length":0,"stats":{"Line":56}},{"line":194,"address":[],"length":0,"stats":{"Line":70}},{"line":200,"address":[],"length":0,"stats":{"Line":70}},{"line":201,"address":[],"length":0,"stats":{"Line":70}},{"line":202,"address":[],"length":0,"stats":{"Line":70}},{"line":203,"address":[],"length":0,"stats":{"Line":70}},{"line":204,"address":[],"length":0,"stats":{"Line":70}},{"line":205,"address":[],"length":0,"stats":{"Line":70}},{"line":207,"address":[],"length":0,"stats":{"Line":70}},{"line":208,"address":[],"length":0,"stats":{"Line":70}},{"line":209,"address":[],"length":0,"stats":{"Line":70}},{"line":210,"address":[],"length":0,"stats":{"Line":70}},{"line":211,"address":[],"length":0,"stats":{"Line":70}}],"covered":98,"coverable":99},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","lib.rs"],"content":"pub mod access_control;\npub mod contract;\nmod error;\npub mod helpers;\npub mod random;\npub mod state;\npub mod string_validation;\npub use crate::error::ContractError;\npub mod bank_helpers;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","random.rs"],"content":"use cosmwasm_std::{Binary, Env};\nuse rand_core::{RngCore, SeedableRng};\nuse rand_xoshiro::Xoshiro128PlusPlus;\nuse sha2::{Digest, Sha256};\n\n/// Converts a byte to an alphanumeric character using a predefined charset\nfn byte_to_alphanumeric(byte: u8) -\u003e char {\n    const CHARSET: \u0026[u8] = b\"abcdefghijklmnopqrstuvwxyz0123456789\";\n    CHARSET[(byte % CHARSET.len() as u8) as usize] as char\n}\n\n/// Generates a random ID with a given prefix using blockchain-based entropy\n///\n/// This is a pseudorandom generator that uses blockchain data (block time, tx index, height)\n/// combined with a provided salt to generate deterministic but unpredictable IDs.\n///\n/// # Arguments\n/// * `salt` - Additional entropy source provided by the caller\n/// * `env` - Blockchain environment containing block data\n/// * `prefix` - String prefix to prepend to the generated ID\n///\n/// # Returns\n/// A string containing the prefix followed by 32 pseudorandom alphanumeric characters\npub fn generate_random_id_with_prefix(salt: \u0026Binary, env: \u0026Env, prefix: \u0026str) -\u003e String {\n    // Extract relevant data from the environment\n    let tx_index: u32 = env.transaction.as_ref().map_or(0, |tx| tx.index);\n    let block_time = env.block.time.nanos();\n    let height = env.block.height;\n\n    // Generate a SHA-256 hash of the salt, block time, tx_index, and height\n    let hash = Sha256::digest(format!(\"{}{}{}{}\", block_time, tx_index, height, salt).as_bytes());\n\n    // Use the first 16 bytes from the hash as seed\n    let randomness: [u8; 16] = hash[..16].try_into().unwrap();\n\n    // Generate a random ID using the randomness\n    let mut id = String::with_capacity(32);\n    let mut rng = Xoshiro128PlusPlus::from_seed(randomness);\n    for _ in 0..32 {\n        id.push(byte_to_alphanumeric(rng.next_u32() as u8));\n    }\n\n    // Prefix the result\n    format!(\"{}{}\", prefix, \u0026id)\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":7968}},{"line":9,"address":[],"length":0,"stats":{"Line":7968}},{"line":24,"address":[],"length":0,"stats":{"Line":249}},{"line":26,"address":[],"length":0,"stats":{"Line":747}},{"line":27,"address":[],"length":0,"stats":{"Line":249}},{"line":28,"address":[],"length":0,"stats":{"Line":249}},{"line":31,"address":[],"length":0,"stats":{"Line":249}},{"line":34,"address":[],"length":0,"stats":{"Line":249}},{"line":37,"address":[],"length":0,"stats":{"Line":249}},{"line":38,"address":[],"length":0,"stats":{"Line":249}},{"line":39,"address":[],"length":0,"stats":{"Line":16185}},{"line":40,"address":[],"length":0,"stats":{"Line":7968}},{"line":44,"address":[],"length":0,"stats":{"Line":249}}],"covered":13,"coverable":13},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","state.rs"],"content":"use cw_storage_plus::Item;\nuse omniflix_channel_types::{\n    config::{AuthDetails, ChannelConractConfig},\n    msg::ChannelTokenDetails,\n};\n\npub type ChannelsCollectionId = String;\n\n// Define storage items\npub const CONFIG: Item\u003cChannelConractConfig\u003e = Item::new(\"chcfg\");\npub const AUTH_DETAILS: Item\u003cAuthDetails\u003e = Item::new(\"auth\");\npub const CHANNEL_TOKEN_DETAILS: Item\u003cChannelTokenDetails\u003e = Item::new(\"ch_tkn_details\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","string_validation.rs"],"content":"use thiserror::Error;\n\nuse crate::ContractError;\n\n// Configuration for string validation\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct StringValidationConfig {\n    min_length: usize,\n    max_length: usize,\n    allow_numbers: bool,\n    allow_uppercase: bool,\n    allow_spaces: bool,\n    allow_special_chars: bool,\n    required_prefixes: Vec\u003cString\u003e, // Required prefixes for the string\n    required_suffixes: Vec\u003cString\u003e, // Required suffixes for the string\n    must_contain: Vec\u003cString\u003e,      // Substrings that must be present\n    allow_empty: bool,              // Whether empty strings are allowed\n}\n\n// Define string validation errors\n#[derive(Error, Debug, PartialEq, Eq)]\npub enum StringValidationError {\n    #[error(\"Invalid length sent: {sent} min_length: {min_length} max_length: {max_length}\")]\n    InvalidLength {\n        sent: String,\n        min_length: usize,\n        max_length: usize,\n    },\n    #[error(\"Invalid prefix sent: {sent} required: {required:?}\")]\n    InvalidPrefix { sent: String, required: Vec\u003cString\u003e },\n    #[error(\"Invalid suffix sent: {sent} required: {required:?}\")]\n    InvalidSuffix { sent: String, required: Vec\u003cString\u003e },\n    #[error(\"Invalid must contain sent: {sent} required: {required:?}\")]\n    InvalidMustContain { sent: String, required: Vec\u003cString\u003e },\n    #[error(\"Uppercase characters not allowed sent: {sent}\")]\n    UppercaseNotAllowed { sent: String },\n    #[error(\"Numbers not allowed sent: {sent}\")]\n    NumbersNotAllowed { sent: String },\n    #[error(\"Spaces not allowed sent: {sent}\")]\n    SpacesNotAllowed { sent: String },\n    #[error(\"Special characters not allowed sent: {sent}\")]\n    SpecialCharsNotAllowed { sent: String },\n}\n\n// Default configuration for string validation\nimpl Default for StringValidationConfig {\n    fn default() -\u003e Self {\n        StringValidationConfig {\n            min_length: 3,\n            max_length: 32,\n            allow_numbers: false,\n            allow_uppercase: false,\n            allow_spaces: false,\n            allow_special_chars: false,\n            required_prefixes: vec![],\n            required_suffixes: vec![],\n            must_contain: vec![],\n            allow_empty: false,\n        }\n    }\n}\n\n// Types of string validation\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum StringValidationType {\n    Username,\n    ChannelName,\n    Description,\n    Link,\n    AssetName,\n}\n\n// Get configuration based on validation type\nimpl StringValidationType {\n    fn get_config(\u0026self) -\u003e StringValidationConfig {\n        match self {\n            StringValidationType::Username =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 32,\n                allow_numbers: false,\n                allow_uppercase: false,\n                allow_spaces: false,\n                allow_special_chars: false,\n                ..Default::default()\n            },\n            StringValidationType::ChannelName =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 32,\n                allow_numbers: true,\n                allow_uppercase: true,\n                allow_spaces: false,\n                allow_special_chars: false,\n                ..Default::default()\n            },\n            StringValidationType::Description =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 256,\n                allow_numbers: true,\n                allow_uppercase: true,\n                allow_spaces: true,\n                allow_special_chars: true,\n                allow_empty: true,\n                ..Default::default()\n            },\n            StringValidationType::Link =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 256,\n                allow_numbers: true,\n                allow_uppercase: true,\n                allow_spaces: false,\n                allow_special_chars: true,\n                required_prefixes: vec![\n                    \"http://\".to_string(),\n                    \"https://\".to_string(),\n                    \"ipfs://\".to_string(),\n                ],\n                must_contain: vec![],\n                ..Default::default()\n            },\n            StringValidationType::AssetName =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 64,\n                allow_numbers: true,\n                allow_uppercase: true,\n                allow_spaces: true,\n                allow_special_chars: false,\n                ..Default::default()\n            },\n        }\n    }\n}\n\n// Validate a string based on the specified validation type\npub fn validate_string(\n    input: \u0026str,\n    validation_type: StringValidationType,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let config = validation_type.get_config();\n\n    if config.allow_empty \u0026\u0026 input.is_empty() {\n        return Ok(());\n    }\n\n    // Check length\n    if !(config.min_length..=config.max_length).contains(\u0026input.len()) {\n        return Err(ContractError::StringValidationError(\n            StringValidationError::InvalidLength {\n                sent: input.to_string(),\n                min_length: config.min_length,\n                max_length: config.max_length,\n            },\n        ));\n    }\n\n    // Check required prefixes\n    if !config.required_prefixes.is_empty() {\n        let has_valid_prefix = config\n            .required_prefixes\n            .iter()\n            .any(|prefix| input.starts_with(prefix));\n        if !has_valid_prefix {\n            return Err(ContractError::StringValidationError(\n                StringValidationError::InvalidPrefix {\n                    sent: input.to_string(),\n                    required: config.required_prefixes.clone(),\n                },\n            ));\n        }\n    }\n\n    // Check required suffixes\n    if !config.required_suffixes.is_empty() {\n        let has_valid_suffix = config\n            .required_suffixes\n            .iter()\n            .any(|suffix| input.ends_with(suffix));\n        if !has_valid_suffix {\n            return Err(ContractError::StringValidationError(\n                StringValidationError::InvalidSuffix {\n                    sent: input.to_string(),\n                    required: config.required_suffixes.clone(),\n                },\n            ));\n        }\n    }\n\n    // Check must contain substrings\n    for required_substring in \u0026config.must_contain {\n        if !input.contains(required_substring) {\n            return Err(ContractError::StringValidationError(\n                StringValidationError::InvalidMustContain {\n                    sent: input.to_string(),\n                    required: config.must_contain.clone(),\n                },\n            ));\n        }\n    }\n\n    // Special case: check for dots in http/https links but not in ipfs links\n    if let StringValidationType::Link = validation_type {\n        if (input.starts_with(\"http://\") || input.starts_with(\"https://\")) \u0026\u0026 !input.contains('.') {\n            return Err(ContractError::StringValidationError(\n                StringValidationError::InvalidMustContain {\n                    sent: input.to_string(),\n                    required: vec![\".\".to_string()],\n                },\n            ));\n        }\n    }\n\n    // Check character restrictions\n    for c in input.chars() {\n        match c {\n            c if c.is_ascii_lowercase() =\u003e continue,\n            c if c.is_ascii_uppercase() =\u003e {\n                if !config.allow_uppercase {\n                    return Err(ContractError::StringValidationError(\n                        StringValidationError::UppercaseNotAllowed {\n                            sent: input.to_string(),\n                        },\n                    ));\n                }\n            }\n            c if c.is_ascii_digit() =\u003e {\n                if !config.allow_numbers {\n                    return Err(ContractError::StringValidationError(\n                        StringValidationError::NumbersNotAllowed {\n                            sent: input.to_string(),\n                        },\n                    ));\n                }\n            }\n            ' ' =\u003e {\n                if !config.allow_spaces {\n                    return Err(ContractError::StringValidationError(\n                        StringValidationError::SpacesNotAllowed {\n                            sent: input.to_string(),\n                        },\n                    ));\n                }\n            }\n            c if !c.is_ascii_alphanumeric() \u0026\u0026 c != ' ' =\u003e {\n                if !config.allow_special_chars {\n                    return Err(ContractError::StringValidationError(\n                        StringValidationError::SpecialCharsNotAllowed {\n                            sent: input.to_string(),\n                        },\n                    ));\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_username() {\n        // Test valid username\n        assert!(validate_string(\"validname\", StringValidationType::Username).is_ok());\n\n        // Test invalid cases\n        assert!(validate_string(\"ab\", StringValidationType::Username).is_err()); // too short\n        assert!(validate_string(\"a\".repeat(33).as_str(), StringValidationType::Username).is_err()); // too long\n        assert!(validate_string(\"Invalid123\", StringValidationType::Username).is_err()); // numbers not allowed\n        assert!(validate_string(\"Invalid!\", StringValidationType::Username).is_err()); // special chars not allowed\n        assert!(validate_string(\"invalid name\", StringValidationType::Username).is_err());\n        // spaces not allowed\n    }\n\n    #[test]\n    fn test_validate_channel_name() {\n        // Test valid channel names\n        assert!(validate_string(\"Channel123\", StringValidationType::ChannelName).is_ok());\n        assert!(validate_string(\"channelname\", StringValidationType::ChannelName).is_ok());\n\n        // Test invalid cases\n        assert!(validate_string(\"ch\", StringValidationType::ChannelName).is_err()); // too short\n        assert!(\n            validate_string(\"a\".repeat(33).as_str(), StringValidationType::ChannelName).is_err()\n        ); // too long\n        assert!(validate_string(\"channel!\", StringValidationType::ChannelName).is_err()); // special chars not allowed\n        assert!(validate_string(\"channel name\", StringValidationType::ChannelName).is_err());\n        // spaces not allowed\n    }\n\n    #[test]\n    fn test_validate_description() {\n        // Test valid descriptions\n        assert!(\n            validate_string(\"Valid description 123!\", StringValidationType::Description).is_ok()\n        );\n        assert!(validate_string(\"Short desc\", StringValidationType::Description).is_ok());\n\n        // Test invalid cases\n        assert!(validate_string(\"ab\", StringValidationType::Description).is_err()); // too short\n        assert!(\n            validate_string(\"a\".repeat(257).as_str(), StringValidationType::Description).is_err()\n        ); // too long\n    }\n\n    #[test]\n    fn test_validate_link() {\n        // Test valid links\n        assert!(validate_string(\"https://example.com\", StringValidationType::Link).is_ok());\n        assert!(validate_string(\"http://test.org/path\", StringValidationType::Link).is_ok());\n        assert!(validate_string(\n            \"https://sub.domain.com/path?query=123\",\n            StringValidationType::Link\n        )\n        .is_ok());\n\n        // Test invalid links\n        assert!(validate_string(\"not-a-url\", StringValidationType::Link).is_err());\n        assert!(validate_string(\"ftp://invalid.com\", StringValidationType::Link).is_err());\n        assert!(validate_string(\"https://\", StringValidationType::Link).is_err());\n        assert!(validate_string(\"https://nodot\", StringValidationType::Link).is_err());\n        assert!(validate_string(\n            \"ipfs://QmNqaukWqEJg8rE7T1nKDxJomvGcJF39S6HQJqm9F9PoiH\",\n            StringValidationType::Link\n        )\n        .is_ok());\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":1097}},{"line":55,"address":[],"length":0,"stats":{"Line":1097}},{"line":56,"address":[],"length":0,"stats":{"Line":1097}},{"line":57,"address":[],"length":0,"stats":{"Line":1097}},{"line":75,"address":[],"length":0,"stats":{"Line":1097}},{"line":76,"address":[],"length":0,"stats":{"Line":1097}},{"line":112,"address":[],"length":0,"stats":{"Line":422}},{"line":117,"address":[],"length":0,"stats":{"Line":422}},{"line":134,"address":[],"length":0,"stats":{"Line":1097}},{"line":138,"address":[],"length":0,"stats":{"Line":1097}},{"line":140,"address":[],"length":0,"stats":{"Line":1432}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":1097}},{"line":146,"address":[],"length":0,"stats":{"Line":10}},{"line":147,"address":[],"length":0,"stats":{"Line":10}},{"line":148,"address":[],"length":0,"stats":{"Line":10}},{"line":149,"address":[],"length":0,"stats":{"Line":10}},{"line":150,"address":[],"length":0,"stats":{"Line":10}},{"line":156,"address":[],"length":0,"stats":{"Line":1087}},{"line":157,"address":[],"length":0,"stats":{"Line":420}},{"line":158,"address":[],"length":0,"stats":{"Line":420}},{"line":160,"address":[],"length":0,"stats":{"Line":1262}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":1085}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":1085}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":1085}},{"line":201,"address":[],"length":0,"stats":{"Line":1252}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":23079}},{"line":213,"address":[],"length":0,"stats":{"Line":2423}},{"line":214,"address":[],"length":0,"stats":{"Line":59958}},{"line":215,"address":[],"length":0,"stats":{"Line":3547}},{"line":216,"address":[],"length":0,"stats":{"Line":266}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":224,"address":[],"length":0,"stats":{"Line":2791}},{"line":225,"address":[],"length":0,"stats":{"Line":21}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":305}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":242,"address":[],"length":0,"stats":{"Line":9692}},{"line":243,"address":[],"length":0,"stats":{"Line":2423}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":1075}}],"covered":53,"coverable":69},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","asset-manager","src","assets.rs"],"content":"use crate::error::AssetError;\nuse cosmwasm_std::{Order, StdResult, Storage};\nuse cw_storage_plus::{Bound, Map};\n\nuse omniflix_channel_types::{\n    asset::{Asset, AssetKey, AssetMetadata, Flag, FlagKey, PublishId},\n    channel::ChannelId,\n    msg::{AssetResponse, FlagInfo},\n};\n\npub struct AssetsManager {\n    pub assets: Map\u003cAssetKey, Asset\u003e,\n    pub asset_metadata: Map\u003cAssetKey, AssetMetadata\u003e,\n    pub flags: Map\u003cFlagKey, u64\u003e,\n}\n\nconst PAGINATION_LIMIT: u32 = 50;\n\nimpl AssetsManager {\n    /// Create a new `Assets` instance.\n    pub const fn new() -\u003e Self {\n        AssetsManager {\n            assets: Map::new(\"assets\"),\n            asset_metadata: Map::new(\"asset_metadata\"),\n            flags: Map::new(\"flags\"),\n        }\n    }\n\n    /// Add a new asset, ensuring it does not already exist.\n    pub fn add_asset(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        key: AssetKey,\n        asset: Asset,\n        metadata: AssetMetadata,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        if self.assets.has(store, key.clone()) {\n            return Err(AssetError::AssetAlreadyExists {});\n        }\n\n        self.assets\n            .save(store, key.clone(), \u0026asset)\n            .map_err(|_| AssetError::SaveAssetError {})?;\n        self.asset_metadata\n            .save(store, key, \u0026metadata)\n            .map_err(|_| AssetError::SaveAssetMetadataError {})?;\n\n        Ok(())\n    }\n\n    /// Retrieve an asset by its key.\n    pub fn get_asset(\u0026self, store: \u0026dyn Storage, key: AssetKey) -\u003e Result\u003cAsset, AssetError\u003e {\n        self.assets\n            .load(store, key)\n            .map_err(|_| AssetError::AssetNotFound {})\n    }\n\n    pub fn get_asset_metadata(\n        \u0026self,\n        store: \u0026dyn Storage,\n        key: AssetKey,\n    ) -\u003e Result\u003cAssetMetadata, AssetError\u003e {\n        self.asset_metadata\n            .load(store, key)\n            .map_err(|_| AssetError::AssetMetadataNotFound {})\n    }\n\n    /// Delete an asset by its key.\n    pub fn delete_assets(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        keys: Vec\u003cAssetKey\u003e,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        for key in keys {\n            if self.assets.load(store, key.clone()).is_err() {\n                return Err(AssetError::AssetNotFound {});\n            }\n            self.assets.remove(store, key.clone());\n            self.asset_metadata.remove(store, key);\n        }\n        Ok(())\n    }\n\n    pub fn get_all_assets(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        start_after: Option\u003cPublishId\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cAssetResponse\u003e\u003e {\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(Bound::exclusive);\n\n        let assets = self\n            .assets\n            .prefix(channel_id.clone())\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|result| {\n                result.map(|(_, asset)| {\n                    let flags = self\n                        .get_all_flags_for_asset(\n                            store,\n                            channel_id.clone(),\n                            asset.publish_id.clone(),\n                        )\n                        .unwrap_or_default();\n                    let metadata = self\n                        .get_asset_metadata(store, (channel_id.clone(), asset.publish_id.clone()))\n                        .unwrap_or_default();\n\n                    AssetResponse {\n                        asset: asset.clone(),\n                        flags,\n                        metadata,\n                    }\n                })\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .unwrap_or_default();\n\n        Ok(assets)\n    }\n\n    /// Update an existing asset by its key.\n    pub fn update_asset(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        key: AssetKey,\n        updated_asset: Asset,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        if !self.assets.has(store, key.clone()) {\n            return Err(AssetError::AssetNotFound {});\n        }\n\n        self.assets\n            .save(store, key, \u0026updated_asset)\n            .map_err(|_| AssetError::SaveAssetError {})?;\n\n        Ok(())\n    }\n\n    pub fn update_asset_metadata(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        key: AssetKey,\n        metadata: AssetMetadata,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        if !self.assets.has(store, key.clone()) {\n            return Err(AssetError::AssetNotFound {});\n        }\n\n        self.asset_metadata\n            .save(store, key, \u0026metadata)\n            .map_err(|_| AssetError::SaveAssetMetadataError {})?;\n        Ok(())\n    }\n\n    /// Delete all assets for a specific channel.\n    pub fn delete_assets_by_channel_id(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        self.assets.prefix(channel_id.clone()).clear(store, None);\n        self.asset_metadata\n            .prefix(channel_id.clone())\n            .clear(store, None);\n        Ok(())\n    }\n\n    pub fn add_flag(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        publish_id: PublishId,\n        flag: Flag,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        let key = (flag.to_key(), (channel_id, publish_id));\n        let flagged_count = self.flags.load(store, key.clone()).unwrap_or(0);\n        // save the new count\n        self.flags\n            .save(store, key, \u0026(flagged_count + 1))\n            .map_err(|_| AssetError::SaveFlagError {})?;\n        Ok(())\n    }\n\n    pub fn get_flag_count(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        publish_id: PublishId,\n        flag: Flag,\n    ) -\u003e Result\u003cu64, AssetError\u003e {\n        // Check if the asset exists\n        if !self\n            .assets\n            .has(store, (channel_id.clone(), publish_id.clone()))\n        {\n            return Err(AssetError::AssetNotFound {});\n        }\n        let key = (flag.to_key(), (channel_id.clone(), publish_id.clone()));\n        let flag_count = self.flags.load(store, key).unwrap_or(0);\n        Ok(flag_count)\n    }\n\n    pub fn get_all_flags_for_asset(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        publish_id: PublishId,\n    ) -\u003e Result\u003cVec\u003cFlagInfo\u003e, AssetError\u003e {\n        let mut flags = Vec::new();\n        for flag in Flag::values() {\n            let flag_count =\n                self.get_flag_count(store, channel_id.clone(), publish_id.clone(), flag.clone())?;\n            flags.push(FlagInfo {\n                flag: flag.clone(),\n                count: flag_count,\n            });\n        }\n        Ok(flags)\n    }\n    pub fn remove_all_flags(\u0026self, store: \u0026mut dyn Storage) -\u003e Result\u003c(), AssetError\u003e {\n        self.flags.clear(store);\n        Ok(())\n    }\n}\n\n// #[cfg(test)]\n// mod tests {\n//     use super::*;\n//     use cosmwasm_std::testing::MockStorage;\n//     use omniflix_channel_types::asset::AssetSource;\n\n//     #[test]\n//     fn test_get_all_assets_with_limit() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n\n//         // Generate 100 assets and add them to the storage\n//         for i in 0..100 {\n//             let publish_id = format!(\"asset{}\", i);\n//             let asset = Asset {\n//                 publish_id: publish_id.clone(),\n//                 channel_id: channel_id.clone(),\n//                 is_visible: true,\n//                 asset_source: AssetSource::Nft {\n//                     collection_id: \"collection_id\".to_string(),\n//                     onft_id: \"onft_id\".to_string(),\n//                 },\n//                 name: \"name\".to_string(),\n//                 description: \"description\".to_string(),\n//                 media_uri: \"http://www.media.com\".to_string(),\n//             };\n//             assets\n//                 .add_asset(\u0026mut storage, (channel_id.clone(), publish_id), asset)\n//                 .unwrap();\n//         }\n\n//         // Test with a limit of 25\n//         let assets_page_1 = assets\n//             .get_all_assets(\u0026storage, channel_id.clone(), None, Some(25))\n//             .unwrap();\n//         assert_eq!(assets_page_1.len(), 25); // Should return exactly 25 assets\n\n//         // Test with a limit of 15\n//         let assets_page_2 = assets\n//             .get_all_assets(\u0026storage, channel_id.clone(), None, Some(15))\n//             .unwrap();\n//         assert_eq!(assets_page_2.len(), 15); // Should return exactly 15 assets\n\n//         // Test with a limit \u003e MAX_LIMIT\n//         let assets_page_3 = assets\n//             .get_all_assets(\n//                 \u0026storage,\n//                 channel_id.clone(),\n//                 None,\n//                 Some(PAGINATION_LIMIT + 1),\n//             )\n//             .unwrap();\n//         assert_eq!(assets_page_3.len(), PAGINATION_LIMIT as usize); // Should return exactly 25 assets\n//     }\n\n//     #[test]\n//     fn test_get_all_assets_with_start_after() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n\n//         // Generate 100 assets and add them to the storage\n//         for i in 0..100 {\n//             let publish_id = format!(\"asset{}\", i);\n//             let asset = Asset {\n//                 publish_id: publish_id.clone(),\n//                 channel_id: channel_id.clone(),\n//                 is_visible: true,\n//                 asset_source: AssetSource::Nft {\n//                     collection_id: \"collection_id\".to_string(),\n//                     onft_id: \"onft_id\".to_string(),\n//                 },\n//                 name: \"name\".to_string(),\n//                 description: \"description\".to_string(),\n//                 media_uri: \"http://www.media.com\".to_string(),\n//             };\n//             assets\n//                 .add_asset(\u0026mut storage, (channel_id.clone(), publish_id), asset)\n//                 .unwrap();\n//         }\n\n//         // Test start_after with publish_id \"asset50\"\n//         let assets_start_after = assets\n//             .get_all_assets(\n//                 \u0026storage,\n//                 channel_id.clone(),\n//                 Some(\"asset50\".to_string()),\n//                 Some(20),\n//             )\n//             .unwrap();\n//         assert_eq!(assets_start_after.len(), 20); // Should return assets starting after \"asset50\"\n\n//         // Ensure the first asset in the result is \"asset51\"\n//         assert_eq!(\n//             assets_start_after[0].asset.publish_id,\n//             \"asset51\".to_string()\n//         );\n//     }\n\n//     #[test]\n//     fn test_get_all_assets_with_limit_and_start_after() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n\n//         // Generate 100 assets and add them to the storage\n//         for i in 0..100 {\n//             let publish_id = format!(\"asset{}\", i);\n//             let asset = Asset {\n//                 publish_id: publish_id.clone(),\n//                 channel_id: channel_id.clone(),\n//                 is_visible: true,\n//                 asset_source: AssetSource::Nft {\n//                     collection_id: \"collection_id\".to_string(),\n//                     onft_id: \"onft_id\".to_string(),\n//                 },\n//                 name: \"name\".to_string(),\n//                 description: \"description\".to_string(),\n//                 media_uri: \"http://www.media.com\".to_string(),\n//             };\n//             assets\n//                 .add_asset(\u0026mut storage, (channel_id.clone(), publish_id), asset)\n//                 .unwrap();\n//         }\n\n//         // Test with a limit of 30 and start_after with publish_id \"asset40\"\n//         let assets_with_start_after_and_limit = assets\n//             .get_all_assets(\n//                 \u0026storage,\n//                 channel_id.clone(),\n//                 Some(\"asset40\".to_string()),\n//                 Some(20),\n//             )\n//             .unwrap();\n//         assert_eq!(assets_with_start_after_and_limit.len(), 20); // Should return 20 assets\n\n//         // Ensure the first asset in the result is \"asset41\"\n//         assert_eq!(\n//             assets_with_start_after_and_limit[0].asset.publish_id,\n//             \"asset41\".to_string()\n//         );\n//     }\n//     #[test]\n//     fn test_add_asset() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset\n//         let add_result = assets.add_asset(\n//             \u0026mut storage,\n//             (channel_id.clone(), publish_id.clone()),\n//             asset.clone(),\n//         );\n//         assert!(add_result.is_ok());\n\n//         // Try adding the same asset again (should fail)\n//         let add_result_again =\n//             assets.add_asset(\u0026mut storage, (channel_id.clone(), publish_id), asset);\n//         assert!(add_result_again.is_err()); // AssetAlreadyExists error\n//     }\n\n//     #[test]\n//     fn test_get_asset() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset to storage\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id.clone()),\n//                 asset,\n//             )\n//             .unwrap();\n\n//         // Retrieve the asset\n//         let retrieved_asset = assets\n//             .get_asset(\u0026storage, (channel_id.clone(), publish_id.clone()))\n//             .unwrap();\n//         assert_eq!(retrieved_asset.publish_id, publish_id);\n//     }\n\n//     #[test]\n//     fn test_delete_asset() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id.clone()),\n//                 asset,\n//             )\n//             .unwrap();\n\n//         // Delete the asset\n//         let delete_result =\n//             assets.delete_assets(\u0026mut storage, vec![(channel_id.clone(), publish_id.clone())]);\n//         assert!(delete_result.is_ok());\n\n//         // Try to get the deleted asset (should fail)\n//         let get_result = assets.get_asset(\u0026storage, (channel_id.clone(), publish_id.clone()));\n//         assert!(get_result.is_err()); // AssetNotFound error\n//     }\n\n//     #[test]\n//     fn test_update_asset() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id.clone()),\n//                 asset,\n//             )\n//             .unwrap();\n\n//         // Update the asset\n//         let updated_asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: false, // Changing visibility\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"new_collection\".to_string(),\n//                 onft_id: \"new_onft_id\".to_string(),\n//             },\n//             name: \"new_name\".to_string(),\n//             description: \"new_description\".to_string(),\n//             media_uri: \"http://www.media1.com\".to_string(),\n//         };\n//         let update_result = assets.update_asset(\n//             \u0026mut storage,\n//             (channel_id.clone(), publish_id.clone()),\n//             updated_asset,\n//         );\n//         assert!(update_result.is_ok());\n\n//         // Retrieve the updated asset\n//         let retrieved_asset = assets\n//             .get_asset(\u0026storage, (channel_id.clone(), publish_id.clone()))\n//             .unwrap();\n//         assert!(!retrieved_asset.is_visible); // Asset should be updated\n//     }\n\n//     #[test]\n//     fn test_delete_assets_by_channel_id() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id1 = \"asset1\".to_string();\n//         let publish_id2 = \"asset2\".to_string();\n//         let asset1 = Asset {\n//             publish_id: publish_id1.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n//         let asset2 = Asset {\n//             publish_id: publish_id2.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the assets\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id1.clone()),\n//                 asset1,\n//             )\n//             .unwrap();\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id2.clone()),\n//                 asset2,\n//             )\n//             .unwrap();\n\n//         // Delete all assets for the channel\n//         let delete_result = assets.delete_assets_by_channel_id(\u0026mut storage, channel_id.clone());\n//         assert!(delete_result.is_ok());\n\n//         // Try to retrieve the assets (should fail)\n//         let get_result1 = assets.get_asset(\u0026storage, (channel_id.clone(), publish_id1.clone()));\n//         let get_result2 = assets.get_asset(\u0026storage, (channel_id.clone(), publish_id2.clone()));\n//         assert!(get_result1.is_err());\n//         assert!(get_result2.is_err());\n//     }\n\n//     #[test]\n//     fn test_asset_exists() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id.clone()),\n//                 asset,\n//             )\n//             .unwrap();\n\n//         // Check if the asset exists\n//         let exists = assets.asset_exists(\u0026storage, (channel_id.clone(), publish_id.clone()));\n//         assert!(exists);\n\n//         // Check for an asset that doesn't exist\n//         let exists_not_found =\n//             assets.asset_exists(\u0026storage, (channel_id.clone(), \"nonexistent\".to_string()));\n//         assert!(!exists_not_found);\n//     }\n// }\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":258}},{"line":23,"address":[],"length":0,"stats":{"Line":258}},{"line":24,"address":[],"length":0,"stats":{"Line":258}},{"line":25,"address":[],"length":0,"stats":{"Line":258}},{"line":30,"address":[],"length":0,"stats":{"Line":123}},{"line":37,"address":[],"length":0,"stats":{"Line":123}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":123}},{"line":42,"address":[],"length":0,"stats":{"Line":123}},{"line":43,"address":[],"length":0,"stats":{"Line":123}},{"line":44,"address":[],"length":0,"stats":{"Line":123}},{"line":45,"address":[],"length":0,"stats":{"Line":123}},{"line":46,"address":[],"length":0,"stats":{"Line":123}},{"line":48,"address":[],"length":0,"stats":{"Line":123}},{"line":52,"address":[],"length":0,"stats":{"Line":124}},{"line":53,"address":[],"length":0,"stats":{"Line":124}},{"line":54,"address":[],"length":0,"stats":{"Line":124}},{"line":55,"address":[],"length":0,"stats":{"Line":251}},{"line":58,"address":[],"length":0,"stats":{"Line":9}},{"line":63,"address":[],"length":0,"stats":{"Line":9}},{"line":64,"address":[],"length":0,"stats":{"Line":9}},{"line":65,"address":[],"length":0,"stats":{"Line":18}},{"line":69,"address":[],"length":0,"stats":{"Line":5}},{"line":74,"address":[],"length":0,"stats":{"Line":13}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":94,"address":[],"length":0,"stats":{"Line":3}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":156,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":30}},{"line":196,"address":[],"length":0,"stats":{"Line":30}},{"line":197,"address":[],"length":0,"stats":{"Line":30}},{"line":198,"address":[],"length":0,"stats":{"Line":30}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":30}},{"line":203,"address":[],"length":0,"stats":{"Line":30}},{"line":204,"address":[],"length":0,"stats":{"Line":30}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":213,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":66}},{"line":215,"address":[],"length":0,"stats":{"Line":30}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":30}},{"line":218,"address":[],"length":0,"stats":{"Line":30}},{"line":219,"address":[],"length":0,"stats":{"Line":30}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}}],"covered":91,"coverable":99},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","asset-manager","src","error.rs"],"content":"use thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum PlaylistError {\n    #[error(\"Playlist not found\")]\n    PlaylistNotFound {},\n\n    #[error(\"Playlist already exists\")]\n    PlaylistAlreadyExists {},\n\n    #[error(\"Asset already exists in playlist\")]\n    AssetAlreadyExistsInPlaylist {},\n\n    #[error(\"Asset not in playlist\")]\n    AssetNotInPlaylist {},\n\n    #[error(\"Error saving playlist\")]\n    SavePlaylistError {},\n\n    #[error(\"Playlist asset limit reached\")]\n    PlaylistAssetLimitReached {},\n}\n\n#[derive(Error, Debug, PartialEq)]\npub enum AssetError {\n    #[error(\"Asset not found\")]\n    AssetNotFound {},\n\n    #[error(\"Asset already exists\")]\n    AssetAlreadyExists {},\n\n    #[error(\"Error saving asset\")]\n    SaveAssetError {},\n\n    #[error(\"Media URL cannot be empty\")]\n    MediaUriCannotBeEmpty {},\n\n    #[error(\"Name cannot be empty\")]\n    NameCannotBeEmpty {},\n\n    #[error(\"Name cannot be longer than 256 characters\")]\n    NameTooLong {},\n\n    #[error(\"Description cannot be empty\")]\n    DescriptionCannotBeEmpty {},\n\n    #[error(\"Description cannot be longer than 512 characters\")]\n    DescriptionTooLong {},\n\n    #[error(\"Media url cannot be longer than 256 characters\")]\n    MediaUriTooLong {},\n\n    #[error(\"Collection ID cannot be empty\")]\n    CollectionIdCannotBeEmpty {},\n\n    #[error(\"Onft ID cannot be empty\")]\n    OnftIdCannotBeEmpty {},\n\n    #[error(\"Error saving flag\")]\n    SaveFlagError {},\n\n    #[error(\"Error removing flags with limit\")]\n    RemoveFlagsWithLimitError {},\n\n    #[error(\"Error saving asset metadata\")]\n    SaveAssetMetadataError {},\n\n    #[error(\"Asset metadata not found\")]\n    AssetMetadataNotFound {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","asset-manager","src","lib.rs"],"content":"pub mod assets;\npub mod error;\npub mod playlists;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","asset-manager","src","playlists.rs"],"content":"use cosmwasm_std::{Order, StdResult, Storage};\nuse cw_storage_plus::{Bound, Map};\n\nuse omniflix_channel_types::asset::{AssetKey, Playlist};\n\nuse crate::assets::AssetsManager;\nuse crate::error::PlaylistError;\n\ntype ChannelId = String;\ntype PlaylistName = String;\n\nconst PLAYLISTS_STORAGE_KEY: \u0026str = \"playlists\";\nconst PLAYLISTS_ASSET_LIMIT: u32 = 100;\n\npub struct PlaylistsManager {\n    pub playlists: Map\u003c(ChannelId, PlaylistName), Playlist\u003e,\n}\n\nimpl PlaylistsManager {\n    pub const fn new() -\u003e Self {\n        PlaylistsManager {\n            playlists: Map::new(PLAYLISTS_STORAGE_KEY),\n        }\n    }\n\n    // Add a new playlist to a channel\n    pub fn add_new_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        if self\n            .playlists\n            .has(store, (channel_id.clone(), playlist_name.clone()))\n        {\n            return Err(PlaylistError::PlaylistAlreadyExists {});\n        }\n\n        let playlist = Playlist {\n            assets: Vec::new(),\n            playlist_name: playlist_name.clone(),\n        };\n\n        self.playlists\n            .save(store, (channel_id, playlist_name), \u0026playlist)\n            .map_err(|_| PlaylistError::SavePlaylistError {})?;\n\n        Ok(())\n    }\n\n    // Add an asset to a specific playlist\n    pub fn add_asset_to_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n        asset_key: AssetKey,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        let mut playlist = self\n            .playlists\n            .load(store, (channel_id.clone(), playlist_name.clone()))\n            .map_err(|_| PlaylistError::PlaylistNotFound {})?;\n\n        if playlist.assets.contains(\u0026asset_key) {\n            return Err(PlaylistError::AssetAlreadyExistsInPlaylist {});\n        }\n\n        playlist.assets.push(asset_key);\n\n        if playlist.assets.len() \u003e PLAYLISTS_ASSET_LIMIT as usize {\n            return Err(PlaylistError::PlaylistAssetLimitReached {});\n        }\n\n        self.playlists\n            .save(store, (channel_id, playlist_name), \u0026playlist)\n            .map_err(|_| PlaylistError::SavePlaylistError {})?;\n\n        Ok(())\n    }\n\n    // Remove an asset from a playlist\n    pub fn remove_assets_from_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n        asset_keys: Vec\u003cAssetKey\u003e,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        let mut playlist = self\n            .playlists\n            .load(store, (channel_id.clone(), playlist_name.clone()))\n            .map_err(|_| PlaylistError::PlaylistNotFound {})?;\n\n        for asset_key in asset_keys.iter() {\n            if let Some(index) = playlist.assets.iter().position(|x| x == asset_key) {\n                playlist.assets.remove(index);\n            } else {\n                // Asset not found in the playlist\n                return Err(PlaylistError::AssetNotInPlaylist {});\n            }\n        }\n\n        self.playlists\n            .save(store, (channel_id, playlist_name), \u0026playlist)\n            .map_err(|_| PlaylistError::SavePlaylistError {})?;\n        Ok(())\n    }\n\n    // Get a specific playlist\n    pub fn get_playlist(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n    ) -\u003e Result\u003cPlaylist, PlaylistError\u003e {\n        self.playlists\n            .load(store, (channel_id, playlist_name))\n            .map_err(|_| PlaylistError::PlaylistNotFound {})\n    }\n\n    // Get all playlists for a channel (with pagination support)\n    pub fn get_all_playlists(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cPlaylist\u003e\u003e {\n        let limit = limit.unwrap_or(25) as usize;\n        let start = start_after.map(Bound::exclusive);\n\n        self.playlists\n            .prefix(channel_id)\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| item.map(|(_, playlist)| playlist))\n            .collect()\n    }\n\n    // Delete a playlist\n    pub fn delete_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        if !self\n            .playlists\n            .has(store, (channel_id.clone(), playlist_name.clone()))\n        {\n            return Err(PlaylistError::PlaylistNotFound {});\n        }\n\n        self.playlists.remove(store, (channel_id, playlist_name));\n        Ok(())\n    }\n\n    // Refresh the playlist\n    pub fn refresh_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n    ) -\u003e Result\u003cVec\u003cAssetKey\u003e, PlaylistError\u003e {\n        let mut playlist = self\n            .playlists\n            .load(store, (channel_id.clone(), playlist_name.clone()))\n            .map_err(|_| PlaylistError::PlaylistNotFound {})?;\n\n        let asset_manager = AssetsManager::new();\n        let mut removed_asset_keys = Vec::with_capacity(playlist.assets.len());\n\n        playlist.assets.retain(|asset_key| {\n            if let Ok(asset) = asset_manager.get_asset(store, asset_key.clone()) {\n                if asset.is_visible {\n                    return true; // Keep visible asset\n                }\n            }\n            removed_asset_keys.push(asset_key.clone()); // Add to removed if not found or not visible\n            false // Remove asset\n        });\n\n        self.playlists\n            .save(store, (channel_id, playlist_name), \u0026playlist)\n            .map_err(|_| PlaylistError::SavePlaylistError {})?;\n\n        Ok(removed_asset_keys)\n    }\n\n    // Delete all playlists for a channel\n    pub fn delete_playlists_by_channel_id(\u0026self, store: \u0026mut dyn Storage, channel_id: ChannelId) {\n        self.playlists.prefix(channel_id).clear(store, None)\n    }\n}\n\n// Test delete playlists by channel id\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::MockStorage;\n\n    #[test]\n    fn test_delete_playlists_by_channel_id() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n\n        // Add 100 playlists\n        for i in 0..24 {\n            let playlist_name = format!(\"playlist_{}\", i);\n            playlists_manager\n                .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name)\n                .unwrap();\n        }\n\n        // Check if the playlists are added\n        let all_playlists = playlists_manager\n            .get_all_playlists(\u0026storage, channel_id.clone(), None, None)\n            .unwrap();\n        assert_eq!(all_playlists.len(), 24);\n\n        // Delete all playlists for the channel\n        playlists_manager.delete_playlists_by_channel_id(\u0026mut storage, channel_id.clone());\n\n        let all_playlists = playlists_manager\n            .get_all_playlists(\u0026storage, channel_id.clone(), None, None)\n            .unwrap();\n        assert_eq!(all_playlists.len(), 0);\n\n        // Check if the playlist is deleted\n        let playlist =\n            playlists_manager.get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone());\n        assert!(playlist.is_err());\n    }\n\n    #[test]\n    fn test_add_new_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Check if the playlist is added\n        let playlist =\n            playlists_manager.get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone());\n        assert!(playlist.is_ok());\n    }\n\n    #[test]\n    fn test_add_asset_to_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n        let asset_key: AssetKey = (\"asset_channel_id\".to_string(), \"publish_id\".to_string());\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Add an asset to the playlist\n        playlists_manager\n            .add_asset_to_playlist(\n                \u0026mut storage,\n                channel_id.clone(),\n                playlist_name.clone(),\n                asset_key.clone(),\n            )\n            .unwrap();\n\n        // Check if the asset is added to the playlist\n        let playlist = playlists_manager\n            .get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n        assert_eq!(playlist.assets.len(), 1);\n        assert_eq!(playlist.assets[0], asset_key);\n    }\n\n    #[test]\n    fn test_remove_assets_from_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n        let asset_key: AssetKey = (\"asset_channel_id\".to_string(), \"publish_id\".to_string());\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Add an asset to the playlist\n        playlists_manager\n            .add_asset_to_playlist(\n                \u0026mut storage,\n                channel_id.clone(),\n                playlist_name.clone(),\n                asset_key.clone(),\n            )\n            .unwrap();\n\n        // Remove the asset from the playlist\n        playlists_manager\n            .remove_assets_from_playlist(\n                \u0026mut storage,\n                channel_id.clone(),\n                playlist_name.clone(),\n                vec![asset_key.clone()],\n            )\n            .unwrap();\n\n        // Check if the asset is removed from the playlist\n        let playlist = playlists_manager\n            .get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n        assert_eq!(playlist.assets.len(), 0);\n    }\n\n    #[test]\n    fn test_get_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Get the playlist\n        let playlist = playlists_manager\n            .get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n        assert_eq!(playlist.playlist_name, playlist_name);\n    }\n\n    #[test]\n    fn test_get_all_playlists_with_start_after() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n\n        // Add 100 playlists\n        for i in 0..100 {\n            let playlist_name = format!(\"playlist_{}\", i);\n            playlists_manager\n                .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name)\n                .unwrap();\n        }\n\n        // Get 25 playlists starting after the 25th playlist\n        let all_playlists = playlists_manager\n            .get_all_playlists(\n                \u0026storage,\n                channel_id.clone(),\n                Some(\"playlist_24\".to_string()),\n                Some(25),\n            )\n            .unwrap();\n        assert_eq!(all_playlists.len(), 25);\n        assert_eq!(all_playlists[0].playlist_name, \"playlist_25\");\n    }\n\n    #[test]\n    fn test_delete_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Delete the playlist\n        playlists_manager\n            .delete_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Check if the playlist is deleted\n        let playlist =\n            playlists_manager.get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone());\n        assert!(playlist.is_err());\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":166}},{"line":22,"address":[],"length":0,"stats":{"Line":166}},{"line":27,"address":[],"length":0,"stats":{"Line":147}},{"line":33,"address":[],"length":0,"stats":{"Line":147}},{"line":34,"address":[],"length":0,"stats":{"Line":147}},{"line":35,"address":[],"length":0,"stats":{"Line":147}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":145}},{"line":42,"address":[],"length":0,"stats":{"Line":145}},{"line":45,"address":[],"length":0,"stats":{"Line":145}},{"line":46,"address":[],"length":0,"stats":{"Line":145}},{"line":47,"address":[],"length":0,"stats":{"Line":145}},{"line":49,"address":[],"length":0,"stats":{"Line":145}},{"line":53,"address":[],"length":0,"stats":{"Line":114}},{"line":60,"address":[],"length":0,"stats":{"Line":227}},{"line":61,"address":[],"length":0,"stats":{"Line":114}},{"line":62,"address":[],"length":0,"stats":{"Line":114}},{"line":63,"address":[],"length":0,"stats":{"Line":230}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":112}},{"line":71,"address":[],"length":0,"stats":{"Line":112}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":111}},{"line":76,"address":[],"length":0,"stats":{"Line":111}},{"line":77,"address":[],"length":0,"stats":{"Line":111}},{"line":79,"address":[],"length":0,"stats":{"Line":111}},{"line":83,"address":[],"length":0,"stats":{"Line":7}},{"line":90,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":7}},{"line":92,"address":[],"length":0,"stats":{"Line":7}},{"line":93,"address":[],"length":0,"stats":{"Line":16}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":19}},{"line":117,"address":[],"length":0,"stats":{"Line":19}},{"line":118,"address":[],"length":0,"stats":{"Line":19}},{"line":119,"address":[],"length":0,"stats":{"Line":40}},{"line":123,"address":[],"length":0,"stats":{"Line":10}},{"line":130,"address":[],"length":0,"stats":{"Line":10}},{"line":131,"address":[],"length":0,"stats":{"Line":10}},{"line":133,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":10}},{"line":135,"address":[],"length":0,"stats":{"Line":10}},{"line":136,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":185}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":2}}],"covered":59,"coverable":71},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","channel-manager","src","channel.rs"],"content":"use cosmwasm_std::{Addr, Decimal, Order, StdResult, Storage};\nuse cw_storage_plus::{Bound, Map};\n\nuse crate::error::ChannelError;\nuse omniflix_channel_types::{\n    channel::{ChannelCollaborator, ChannelDetails, ChannelId, ChannelMetadata, UserName},\n    msg::{CollaboratorInfo, ReservedUsername},\n};\n\nconst CHANNEL_DETAILS: \u0026str = \"cd\"; // channel_details\nconst CHANNEL_METADATA: \u0026str = \"cm\"; // channel_metadata\nconst USERNAME_TO_CHANNEL_ID: \u0026str = \"u2i\"; // username_to_channel_id\nconst CHANNEL_ID_TO_USERNAME: \u0026str = \"i2u\"; // channel_id_to_username\nconst RESERVED_USERNAMES: \u0026str = \"ru\"; // reserved_usernames\nconst CHANNEL_COLLABORATORS: \u0026str = \"col\"; // channel_collaborators\nconst TOTAL_COLLABORATOR_SHARES: \u0026str = \"tcs\"; // total_collaborator_shares\nconst TOTAL_UNIQUE_COLLABORATOR_LIMIT: u32 = 10;\n\nconst FOLLOWERS: \u0026str = \"f\"; // followers\nconst FOLLOWERS_COUNT: \u0026str = \"fc\"; // followers_count\n\nconst PAGINATION_LIMIT: u32 = 50;\n\npub struct ChannelsManager {\n    pub channel_details: Map\u003cChannelId, ChannelDetails\u003e,\n    pub channel_metadata: Map\u003cChannelId, ChannelMetadata\u003e,\n    pub username_to_channel_id: Map\u003cUserName, ChannelId\u003e,\n    pub channel_id_to_username: Map\u003cChannelId, UserName\u003e,\n    pub reserved_usernames: Map\u003cUserName, Option\u003cAddr\u003e\u003e,\n    pub channel_collaborators: Map\u003c(ChannelId, Addr), ChannelCollaborator\u003e,\n    pub total_collaborator_shares: Map\u003cChannelId, Decimal\u003e,\n    pub followers: Map\u003c(ChannelId, Addr), bool\u003e,\n    pub followers_count: Map\u003cChannelId, u64\u003e,\n}\n\nimpl ChannelsManager {\n    pub const fn new() -\u003e Self {\n        ChannelsManager {\n            channel_details: Map::new(CHANNEL_DETAILS),\n            username_to_channel_id: Map::new(USERNAME_TO_CHANNEL_ID),\n            channel_id_to_username: Map::new(CHANNEL_ID_TO_USERNAME),\n            reserved_usernames: Map::new(RESERVED_USERNAMES),\n            channel_metadata: Map::new(CHANNEL_METADATA),\n            channel_collaborators: Map::new(CHANNEL_COLLABORATORS),\n            total_collaborator_shares: Map::new(TOTAL_COLLABORATOR_SHARES),\n            followers: Map::new(FOLLOWERS),\n            followers_count: Map::new(FOLLOWERS_COUNT),\n        }\n    }\n\n    pub fn add_reserved_usernames(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        usernames: Vec\u003cReservedUsername\u003e,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        for username in usernames {\n            self.reserved_usernames\n                .save(store, username.username.clone(), \u0026username.address)\n                .map_err(|_| ChannelError::SaveReservedUsernamesFailed {})?;\n        }\n        Ok(())\n    }\n    pub fn remove_reserved_usernames(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        usernames: Vec\u003cUserName\u003e,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        for username in usernames {\n            // return error if username does not exist\n            if !self.reserved_usernames.has(store, username.clone()) {\n                return Err(ChannelError::UsernameNotReserved {});\n            }\n            self.reserved_usernames.remove(store, username.clone());\n        }\n        Ok(())\n    }\n\n    pub fn get_reserved_usernames(\n        \u0026self,\n        store: \u0026dyn Storage,\n        start_after: Option\u003cUserName\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cReservedUsername\u003e\u003e {\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(Bound::exclusive);\n\n        let reserved_usernames: Vec\u003cReservedUsername\u003e = self\n            .reserved_usernames\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(username, address)| ReservedUsername {\n                    username,\n                    address: address.clone(),\n                })\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .unwrap_or_default();\n        Ok(reserved_usernames)\n    }\n\n    pub fn get_reserved_status(\n        \u0026self,\n        store: \u0026dyn Storage,\n        username: UserName,\n    ) -\u003e StdResult\u003cOption\u003cOption\u003cAddr\u003e\u003e\u003e {\n        // Check if the username exists in the map\n        if !self.reserved_usernames.has(store, username.clone()) {\n            return Ok(None); // Username doesn't exist\n        }\n        // Username exists, get its value (which might be None)\n        let reserved_address = self.reserved_usernames.load(store, username)?;\n        Ok(Some(reserved_address)) // Return Some(None) or Some(Some(addr))\n    }\n\n    pub fn add_channel(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        channel_details: ChannelDetails,\n        channel_metadata: ChannelMetadata,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if the channel ID or username already exists\n        if self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdAlreadyExists {});\n        }\n        if self\n            .username_to_channel_id\n            .has(store, channel_details.user_name.clone())\n        {\n            return Err(ChannelError::UserNameAlreadyTaken {});\n        }\n\n        // Save the details and mappings\n        self.channel_details\n            .save(store, channel_id.clone(), \u0026channel_details)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        self.username_to_channel_id\n            .save(store, channel_details.user_name.clone(), \u0026channel_id)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        self.channel_id_to_username\n            .save(store, channel_id.clone(), \u0026channel_details.user_name)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        self.channel_metadata\n            .save(store, channel_id, \u0026channel_metadata)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        Ok(())\n    }\n\n    pub fn delete_channel(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let user_name = self\n            .channel_id_to_username\n            .load(store, channel_id.clone())\n            .map_err(|_| ChannelError::UserNameNotFound {})?;\n\n        // Remove channel details and mappings\n        self.channel_details.remove(store, channel_id.clone());\n        self.username_to_channel_id.remove(store, user_name.clone());\n        self.channel_id_to_username.remove(store, channel_id);\n\n        Ok(())\n    }\n\n    pub fn get_channels_list(\n        \u0026self,\n        store: \u0026dyn Storage,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cChannelDetails\u003e\u003e {\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(Bound::exclusive);\n\n        self.channel_details\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| item.map(|(_, details)| details))\n            .collect()\n    }\n\n    pub fn get_channel_details(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cChannelDetails, ChannelError\u003e {\n        self.channel_details\n            .load(store, channel_id)\n            .map_err(|_| ChannelError::ChannelIdNotFound {})\n    }\n\n    pub fn update_payment_address(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        payment_address: Addr,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        let mut channel_details = self.get_channel_details(store, channel_id.clone())?;\n        channel_details.payment_address = payment_address;\n        self.channel_details\n            .save(store, channel_id.clone(), \u0026channel_details)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        Ok(())\n    }\n\n    pub fn get_channel_metadata(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cChannelMetadata, ChannelError\u003e {\n        self.channel_metadata\n            .load(store, channel_id)\n            .map_err(|_| ChannelError::ChannelIdNotFound {})\n    }\n\n    pub fn update_channel_metadata(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        channel_metadata: ChannelMetadata,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        if !self.channel_metadata.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        self.channel_metadata\n            .save(store, channel_id, \u0026channel_metadata)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        Ok(())\n    }\n\n    pub fn get_channel_id(\n        \u0026self,\n        store: \u0026dyn Storage,\n        user_name: UserName,\n    ) -\u003e Result\u003cChannelId, ChannelError\u003e {\n        self.username_to_channel_id\n            .load(store, user_name)\n            .map_err(|_| ChannelError::UserNameNotFound {})\n    }\n\n    pub fn get_channel_id_from_username(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        user_name: UserName,\n    ) -\u003e Result\u003cChannelId, ChannelError\u003e {\n        self.username_to_channel_id\n            .load(store, user_name)\n            .map_err(|_| ChannelError::UserNameNotFound {})\n    }\n\n    pub fn get_username_from_channel_id(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cUserName, ChannelError\u003e {\n        self.channel_id_to_username\n            .load(store, channel_id)\n            .map_err(|_| ChannelError::ChannelIdNotFound {})\n    }\n\n    pub fn add_collaborator(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        address: Addr,\n        collaborator: ChannelCollaborator,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        // Check if collaborator already exists\n        if self\n            .channel_collaborators\n            .has(store, (channel_id.clone(), address.clone()))\n        {\n            return Err(ChannelError::CollaboratorExists {});\n        }\n\n        // Calculate new total share\n        let current_total = self\n            .total_collaborator_shares\n            .load(store, channel_id.clone())\n            .unwrap_or(Decimal::zero());\n        let new_total = current_total + collaborator.share;\n\n        // Check if the number of unique collaborators exceeds the limit\n        let unique_collaborators = self\n            .channel_collaborators\n            .prefix(channel_id.clone())\n            .keys(store, None, None, Order::Ascending)\n            .count();\n        if unique_collaborators \u003e= TOTAL_UNIQUE_COLLABORATOR_LIMIT as usize {\n            return Err(ChannelError::TotalUniqueCollaboratorsLimitExceeded {});\n        }\n\n        // Validate total share doesn't exceed 100%\n        if new_total \u003e Decimal::one() {\n            return Err(ChannelError::InvalidSharePercentage {});\n        }\n\n        // Save collaborator and update total shares\n        self.channel_collaborators\n            .save(store, (channel_id.clone(), address), \u0026collaborator)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        self.total_collaborator_shares\n            .save(store, channel_id, \u0026new_total)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        Ok(())\n    }\n\n    pub fn remove_collaborator(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        address: Addr,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        // Check if the collaborator exists\n        if !self\n            .channel_collaborators\n            .has(store, (channel_id.clone(), address.clone()))\n        {\n            return Err(ChannelError::CollaboratorNotFound {});\n        }\n        let collaborator = self\n            .channel_collaborators\n            .load(store, (channel_id.clone(), address.clone()))\n            .unwrap();\n        // Remove the collaborator\n        self.channel_collaborators\n            .remove(store, (channel_id.clone(), address.clone()));\n        // Update total shares\n        let current_total = self\n            .total_collaborator_shares\n            .load(store, channel_id.clone())\n            .unwrap_or(Decimal::zero());\n        let new_total = current_total - collaborator.share;\n        self.total_collaborator_shares\n            .save(store, channel_id, \u0026new_total)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        Ok(())\n    }\n    pub fn get_collaborator_shares(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cVec\u003c(Addr, Decimal)\u003e, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let shares: Vec\u003c(Addr, Decimal)\u003e = self\n            .channel_collaborators\n            .prefix(channel_id)\n            .range(store, None, None, Order::Ascending)\n            .filter_map(|item| item.ok())\n            .map(|(addr, collaborator)| (addr, collaborator.share))\n            .collect();\n        Ok(shares)\n    }\n\n    pub fn is_collaborator(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        sender: Addr,\n    ) -\u003e Result\u003cbool, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let collaborator = self\n            .channel_collaborators\n            .has(store, (channel_id.clone(), sender.clone()));\n        Ok(collaborator)\n    }\n    pub fn get_collaborator(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        sender: Addr,\n    ) -\u003e Result\u003cChannelCollaborator, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let collaborator = self\n            .channel_collaborators\n            .load(store, (channel_id.clone(), sender.clone()));\n        if collaborator.is_err() {\n            return Err(ChannelError::CollaboratorNotFound {});\n        }\n        Ok(collaborator.unwrap())\n    }\n\n    pub fn get_channel_collaborators(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cVec\u003cCollaboratorInfo\u003e, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(|addr| Bound::exclusive(Addr::unchecked(addr)));\n\n        let channel_collaborators = self\n            .channel_collaborators\n            .prefix(channel_id)\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, collab)| CollaboratorInfo {\n                    address: addr.to_string(),\n                    role: collab.role.to_string(),\n                    share: collab.share,\n                })\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .unwrap_or_default();\n        Ok(channel_collaborators)\n    }\n\n    pub fn add_follower(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        follower: Addr,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        // Check if the follower already exists\n        if self\n            .followers\n            .has(store, (channel_id.clone(), follower.clone()))\n        {\n            return Err(ChannelError::AlreadyFollowing {});\n        }\n\n        self.followers\n            .save(store, (channel_id.clone(), follower.clone()), \u0026true)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        let current_count = self\n            .followers_count\n            .load(store, channel_id.clone())\n            .unwrap_or(0);\n        self.followers_count\n            .save(store, channel_id.clone(), \u0026(current_count + 1))\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        Ok(())\n    }\n\n    pub fn remove_follower(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        follower: Addr,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        // Check if the follower exists\n        if !self\n            .followers\n            .has(store, (channel_id.clone(), follower.clone()))\n        {\n            return Err(ChannelError::FollowerNotFound {});\n        }\n        self.followers\n            .remove(store, (channel_id.clone(), follower.clone()));\n\n        let current_count = self\n            .followers_count\n            .load(store, channel_id.clone())\n            .unwrap_or(0);\n        self.followers_count\n            .save(store, channel_id.clone(), \u0026(current_count - 1))\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        Ok(())\n    }\n\n    pub fn get_followers_count(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cu64, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        let count = self\n            .followers_count\n            .load(store, channel_id.clone())\n            .unwrap_or(0);\n        Ok(count)\n    }\n\n    pub fn is_follower(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        follower: Addr,\n    ) -\u003e Result\u003cbool, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        let follower = self\n            .followers\n            .has(store, (channel_id.clone(), follower.clone()));\n        Ok(follower)\n    }\n\n    pub fn get_followers(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cVec\u003cAddr\u003e, ChannelError\u003e {\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(|addr| Bound::exclusive(Addr::unchecked(addr)));\n\n        let followers = self\n            .followers\n            .prefix(channel_id)\n            .keys(store, start, None, Order::Ascending)\n            .take(limit)\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .unwrap_or_default();\n        Ok(followers)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::mock_dependencies;\n    use omniflix_channel_types::channel::Role;\n\n    #[test]\n    fn test_collaborator_operations() {\n        let mut deps = mock_dependencies();\n        let channels = ChannelsManager::new();\n        let channel_id1 = \"channel1\".to_string();\n        let channel_id2 = \"channel2\".to_string();\n\n        // Create channel 1\n        let channel_details1 = ChannelDetails {\n            channel_id: channel_id1.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user1\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id1.clone(),\n                channel_details1,\n                ChannelMetadata {\n                    channel_name: \"channel1\".to_string(),\n                    description: Some(\"description1\".to_string()),\n                    profile_picture: Some(\"profile_picture1\".to_string()),\n                    banner_picture: Some(\"banner_picture1\".to_string()),\n                },\n            )\n            .unwrap();\n\n        // Create channel 2\n        let channel_details2 = ChannelDetails {\n            channel_id: channel_id2.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user2\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id2.clone(),\n                channel_details2,\n                ChannelMetadata {\n                    channel_name: \"channel2\".to_string(),\n                    description: Some(\"description2\".to_string()),\n                    profile_picture: Some(\"profile_picture2\".to_string()),\n                    banner_picture: Some(\"banner_picture2\".to_string()),\n                },\n            )\n            .unwrap();\n\n        let addr1 = Addr::unchecked(\"addr1\");\n        let addr2 = Addr::unchecked(\"addr2\");\n        let addr3 = Addr::unchecked(\"addr3\");\n        let addr4 = Addr::unchecked(\"addr4\");\n\n        // Test adding collaborators to channel 1\n        let collab1 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50), // 50%\n        };\n\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id1.clone(),\n            addr1.clone(),\n            collab1,\n        );\n        assert!(result.is_ok());\n\n        let collab2 = ChannelCollaborator {\n            role: Role::Publisher,\n            share: Decimal::percent(50), // 50%\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id1.clone(),\n            addr2.clone(),\n            collab2,\n        );\n        assert!(result.is_ok());\n\n        // Test adding collaborators to channel 2\n        let collab3 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(30), // 30%\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id2.clone(),\n            addr3.clone(),\n            collab3,\n        );\n        assert!(result.is_ok());\n\n        let collab4 = ChannelCollaborator {\n            role: Role::Publisher,\n            share: Decimal::percent(70), // 70%\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id2.clone(),\n            addr4.clone(),\n            collab4,\n        );\n        assert!(result.is_ok());\n\n        // Verify shares for channel 1\n        let shares1 = channels\n            .get_collaborator_shares(\u0026deps.storage, channel_id1.clone())\n            .unwrap();\n        assert_eq!(shares1.len(), 2);\n        assert!(shares1.contains(\u0026(addr1.clone(), Decimal::percent(50))));\n        assert!(shares1.contains(\u0026(addr2.clone(), Decimal::percent(50))));\n\n        // Verify shares for channel 2\n        let shares2 = channels\n            .get_collaborator_shares(\u0026deps.storage, channel_id2.clone())\n            .unwrap();\n        assert_eq!(shares2.len(), 2);\n        assert!(shares2.contains(\u0026(addr3.clone(), Decimal::percent(30))));\n        assert!(shares2.contains(\u0026(addr4.clone(), Decimal::percent(70))));\n\n        // Test removing collaborator from channel 1 doesn't affect channel 2\n        let result =\n            channels.remove_collaborator(\u0026mut deps.storage, channel_id1.clone(), addr1.clone());\n        assert!(result.is_ok());\n\n        // Verify channel 1 shares updated\n        let shares1_after = channels\n            .get_collaborator_shares(\u0026deps.storage, channel_id1.clone())\n            .unwrap();\n        assert_eq!(shares1_after.len(), 1);\n        assert!(shares1_after.contains(\u0026(addr2.clone(), Decimal::percent(50))));\n\n        // Verify channel 2 shares unchanged\n        let shares2_after = channels\n            .get_collaborator_shares(\u0026deps.storage, channel_id2.clone())\n            .unwrap();\n        assert_eq!(shares2_after.len(), 2);\n        assert!(shares2_after.contains(\u0026(addr3.clone(), Decimal::percent(30))));\n        assert!(shares2_after.contains(\u0026(addr4.clone(), Decimal::percent(70))));\n    }\n\n    #[test]\n    fn test_add_collaborator_overflow() {\n        let mut deps = mock_dependencies();\n        let channels = ChannelsManager::new();\n        let channel_id = \"channel1\".to_string();\n        let addr1 = Addr::unchecked(\"addr1\");\n        let addr2 = Addr::unchecked(\"addr2\");\n        let addr3 = Addr::unchecked(\"addr3\");\n\n        // Create channel\n        let channel_details = ChannelDetails {\n            channel_id: channel_id.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user1\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id.clone(),\n                channel_details,\n                ChannelMetadata {\n                    channel_name: \"channel1\".to_string(),\n                    description: Some(\"description1\".to_string()),\n                    profile_picture: Some(\"profile_picture1\".to_string()),\n                    banner_picture: Some(\"banner_picture1\".to_string()),\n                },\n            )\n            .unwrap();\n\n        // Add first collaborator\n        let collab1 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50),\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr1.clone(),\n            collab1,\n        );\n        assert!(result.is_ok());\n\n        // Now we are at 50%\n        // Add another collaborator with 50% share. This should work\n        let collab2 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50),\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr2.clone(),\n            collab2,\n        );\n        assert!(result.is_ok());\n\n        // Add another collaborator with 50% share. This should overflow\n        let collab3 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50),\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr3.clone(),\n            collab3,\n        );\n        assert_eq!(result.unwrap_err(), ChannelError::InvalidSharePercentage {});\n    }\n\n    #[test]\n    fn test_duplicate_collaborator() {\n        let mut deps = mock_dependencies();\n        let channels = ChannelsManager::new();\n        let channel_id = \"channel1\".to_string();\n        let addr1 = Addr::unchecked(\"addr1\");\n\n        // Create channel\n        let channel_details = ChannelDetails {\n            channel_id: channel_id.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user1\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id.clone(),\n                channel_details,\n                ChannelMetadata {\n                    channel_name: \"channel1\".to_string(),\n                    description: Some(\"description1\".to_string()),\n                    profile_picture: Some(\"profile_picture1\".to_string()),\n                    banner_picture: Some(\"banner_picture1\".to_string()),\n                },\n            )\n            .unwrap();\n\n        // Add first collaborator\n        let collab = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50),\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr1.clone(),\n            collab.clone(),\n        );\n        assert!(result.is_ok());\n\n        // Try to add same collaborator again\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr1.clone(),\n            collab.clone(),\n        );\n        assert!(matches!(result, Err(ChannelError::CollaboratorExists {})));\n    }\n\n    #[test]\n    fn test_follower_operations() {\n        let mut deps = mock_dependencies();\n        let channels = ChannelsManager::new();\n        let channel_id = \"channel1\".to_string();\n        let follower1 = deps.api.addr_make(\"follower1\");\n        let follower2 = deps.api.addr_make(\"follower2\");\n        let non_follower = deps.api.addr_make(\"non_follower\");\n\n        // Create channel\n        let channel_details = ChannelDetails {\n            channel_id: channel_id.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user1\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id.clone(),\n                channel_details,\n                ChannelMetadata {\n                    channel_name: \"channel1\".to_string(),\n                    description: Some(\"description1\".to_string()),\n                    profile_picture: Some(\"profile_picture1\".to_string()),\n                    banner_picture: Some(\"banner_picture1\".to_string()),\n                },\n            )\n            .unwrap();\n\n        // Test initial followers count\n        let count = channels\n            .get_followers_count(\u0026deps.storage, channel_id.clone())\n            .unwrap();\n        assert_eq!(count, 0);\n\n        // Test adding followers\n        let result =\n            channels.add_follower(\u0026mut deps.storage, channel_id.clone(), follower1.clone());\n        assert!(result.is_ok());\n        let result =\n            channels.add_follower(\u0026mut deps.storage, channel_id.clone(), follower2.clone());\n        assert!(result.is_ok());\n\n        // Test followers count after adding\n        let count = channels\n            .get_followers_count(\u0026deps.storage, channel_id.clone())\n            .unwrap();\n        assert_eq!(count, 2);\n\n        // Test is_follower\n        assert!(channels\n            .is_follower(\u0026deps.storage, channel_id.clone(), follower1.clone())\n            .unwrap());\n        assert!(channels\n            .is_follower(\u0026deps.storage, channel_id.clone(), follower2.clone())\n            .unwrap());\n        assert!(!channels\n            .is_follower(\u0026deps.storage, channel_id.clone(), non_follower.clone())\n            .unwrap());\n\n        // Test get_followers\n        let followers = channels\n            .get_followers(\u0026deps.storage, channel_id.clone(), None, None)\n            .unwrap();\n        assert_eq!(followers.len(), 2);\n        assert!(followers.contains(\u0026follower1));\n        assert!(followers.contains(\u0026follower2));\n\n        // Test removing follower\n        let result =\n            channels.remove_follower(\u0026mut deps.storage, channel_id.clone(), follower1.clone());\n        assert!(result.is_ok());\n\n        // Test followers count after removing\n        let count = channels\n            .get_followers_count(\u0026deps.storage, channel_id.clone())\n            .unwrap();\n        assert_eq!(count, 1);\n\n        // Test removing non-existent follower\n        let result =\n            channels.remove_follower(\u0026mut deps.storage, channel_id.clone(), non_follower.clone());\n        assert!(matches!(result, Err(ChannelError::FollowerNotFound {})));\n\n        // Verify remaining followers\n        let followers = channels\n            .get_followers(\u0026deps.storage, channel_id.clone(), None, None)\n            .unwrap();\n        assert_eq!(followers.len(), 1);\n        assert!(followers.contains(\u0026follower2));\n        assert!(!followers.contains(\u0026follower1));\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":497}},{"line":39,"address":[],"length":0,"stats":{"Line":497}},{"line":40,"address":[],"length":0,"stats":{"Line":497}},{"line":41,"address":[],"length":0,"stats":{"Line":497}},{"line":42,"address":[],"length":0,"stats":{"Line":497}},{"line":43,"address":[],"length":0,"stats":{"Line":497}},{"line":44,"address":[],"length":0,"stats":{"Line":497}},{"line":45,"address":[],"length":0,"stats":{"Line":497}},{"line":46,"address":[],"length":0,"stats":{"Line":497}},{"line":47,"address":[],"length":0,"stats":{"Line":497}},{"line":51,"address":[],"length":0,"stats":{"Line":74}},{"line":56,"address":[],"length":0,"stats":{"Line":224}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":74}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":11}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":8}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":17}},{"line":92,"address":[],"length":0,"stats":{"Line":18}},{"line":93,"address":[],"length":0,"stats":{"Line":9}},{"line":94,"address":[],"length":0,"stats":{"Line":9}},{"line":99,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":59}},{"line":108,"address":[],"length":0,"stats":{"Line":59}},{"line":109,"address":[],"length":0,"stats":{"Line":56}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":62}},{"line":124,"address":[],"length":0,"stats":{"Line":62}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":62}},{"line":128,"address":[],"length":0,"stats":{"Line":62}},{"line":129,"address":[],"length":0,"stats":{"Line":62}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":61}},{"line":136,"address":[],"length":0,"stats":{"Line":61}},{"line":137,"address":[],"length":0,"stats":{"Line":61}},{"line":138,"address":[],"length":0,"stats":{"Line":61}},{"line":139,"address":[],"length":0,"stats":{"Line":61}},{"line":140,"address":[],"length":0,"stats":{"Line":61}},{"line":141,"address":[],"length":0,"stats":{"Line":61}},{"line":142,"address":[],"length":0,"stats":{"Line":61}},{"line":143,"address":[],"length":0,"stats":{"Line":61}},{"line":144,"address":[],"length":0,"stats":{"Line":61}},{"line":145,"address":[],"length":0,"stats":{"Line":61}},{"line":146,"address":[],"length":0,"stats":{"Line":61}},{"line":148,"address":[],"length":0,"stats":{"Line":61}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":5}},{"line":189,"address":[],"length":0,"stats":{"Line":313}},{"line":194,"address":[],"length":0,"stats":{"Line":313}},{"line":195,"address":[],"length":0,"stats":{"Line":313}},{"line":196,"address":[],"length":0,"stats":{"Line":630}},{"line":199,"address":[],"length":0,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":5}},{"line":218,"address":[],"length":0,"stats":{"Line":5}},{"line":219,"address":[],"length":0,"stats":{"Line":5}},{"line":220,"address":[],"length":0,"stats":{"Line":10}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":24}},{"line":278,"address":[],"length":0,"stats":{"Line":24}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":24}},{"line":283,"address":[],"length":0,"stats":{"Line":24}},{"line":284,"address":[],"length":0,"stats":{"Line":24}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":23}},{"line":291,"address":[],"length":0,"stats":{"Line":23}},{"line":292,"address":[],"length":0,"stats":{"Line":23}},{"line":293,"address":[],"length":0,"stats":{"Line":23}},{"line":294,"address":[],"length":0,"stats":{"Line":23}},{"line":297,"address":[],"length":0,"stats":{"Line":23}},{"line":298,"address":[],"length":0,"stats":{"Line":23}},{"line":299,"address":[],"length":0,"stats":{"Line":23}},{"line":300,"address":[],"length":0,"stats":{"Line":23}},{"line":302,"address":[],"length":0,"stats":{"Line":23}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":22}},{"line":308,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":20}},{"line":313,"address":[],"length":0,"stats":{"Line":20}},{"line":314,"address":[],"length":0,"stats":{"Line":20}},{"line":316,"address":[],"length":0,"stats":{"Line":20}},{"line":317,"address":[],"length":0,"stats":{"Line":20}},{"line":318,"address":[],"length":0,"stats":{"Line":20}},{"line":320,"address":[],"length":0,"stats":{"Line":20}},{"line":323,"address":[],"length":0,"stats":{"Line":1}},{"line":330,"address":[],"length":0,"stats":{"Line":1}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":336,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":1}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":1}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":1}},{"line":351,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":354,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":6}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":6}},{"line":369,"address":[],"length":0,"stats":{"Line":6}},{"line":370,"address":[],"length":0,"stats":{"Line":6}},{"line":371,"address":[],"length":0,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":20}},{"line":373,"address":[],"length":0,"stats":{"Line":20}},{"line":375,"address":[],"length":0,"stats":{"Line":6}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":12}},{"line":401,"address":[],"length":0,"stats":{"Line":12}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":12}},{"line":406,"address":[],"length":0,"stats":{"Line":12}},{"line":407,"address":[],"length":0,"stats":{"Line":12}},{"line":408,"address":[],"length":0,"stats":{"Line":12}},{"line":409,"address":[],"length":0,"stats":{"Line":10}},{"line":411,"address":[],"length":0,"stats":{"Line":2}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":422,"address":[],"length":0,"stats":{"Line":1}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":2}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":430,"address":[],"length":0,"stats":{"Line":1}},{"line":431,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":1}},{"line":433,"address":[],"length":0,"stats":{"Line":1}},{"line":434,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":6}},{"line":453,"address":[],"length":0,"stats":{"Line":6}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":5}},{"line":458,"address":[],"length":0,"stats":{"Line":5}},{"line":459,"address":[],"length":0,"stats":{"Line":5}},{"line":461,"address":[],"length":0,"stats":{"Line":1}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":465,"address":[],"length":0,"stats":{"Line":4}},{"line":466,"address":[],"length":0,"stats":{"Line":4}},{"line":468,"address":[],"length":0,"stats":{"Line":4}},{"line":469,"address":[],"length":0,"stats":{"Line":4}},{"line":470,"address":[],"length":0,"stats":{"Line":4}},{"line":472,"address":[],"length":0,"stats":{"Line":4}},{"line":473,"address":[],"length":0,"stats":{"Line":4}},{"line":474,"address":[],"length":0,"stats":{"Line":4}},{"line":475,"address":[],"length":0,"stats":{"Line":4}},{"line":478,"address":[],"length":0,"stats":{"Line":2}},{"line":485,"address":[],"length":0,"stats":{"Line":2}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":2}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":493,"address":[],"length":0,"stats":{"Line":1}},{"line":495,"address":[],"length":0,"stats":{"Line":1}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":498,"address":[],"length":0,"stats":{"Line":1}},{"line":499,"address":[],"length":0,"stats":{"Line":1}},{"line":500,"address":[],"length":0,"stats":{"Line":1}},{"line":502,"address":[],"length":0,"stats":{"Line":1}},{"line":503,"address":[],"length":0,"stats":{"Line":1}},{"line":504,"address":[],"length":0,"stats":{"Line":1}},{"line":505,"address":[],"length":0,"stats":{"Line":1}},{"line":508,"address":[],"length":0,"stats":{"Line":5}},{"line":514,"address":[],"length":0,"stats":{"Line":5}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":5}},{"line":518,"address":[],"length":0,"stats":{"Line":5}},{"line":519,"address":[],"length":0,"stats":{"Line":5}},{"line":521,"address":[],"length":0,"stats":{"Line":5}},{"line":524,"address":[],"length":0,"stats":{"Line":3}},{"line":531,"address":[],"length":0,"stats":{"Line":3}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":3}},{"line":535,"address":[],"length":0,"stats":{"Line":3}},{"line":536,"address":[],"length":0,"stats":{"Line":3}},{"line":537,"address":[],"length":0,"stats":{"Line":3}},{"line":540,"address":[],"length":0,"stats":{"Line":3}},{"line":547,"address":[],"length":0,"stats":{"Line":3}},{"line":548,"address":[],"length":0,"stats":{"Line":6}},{"line":550,"address":[],"length":0,"stats":{"Line":3}},{"line":551,"address":[],"length":0,"stats":{"Line":3}},{"line":552,"address":[],"length":0,"stats":{"Line":3}},{"line":553,"address":[],"length":0,"stats":{"Line":3}},{"line":554,"address":[],"length":0,"stats":{"Line":3}},{"line":557,"address":[],"length":0,"stats":{"Line":3}}],"covered":214,"coverable":251},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","channel-manager","src","error.rs"],"content":"use thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ChannelError {\n    #[error(\"Channel ID not found\")]\n    ChannelIdNotFound {},\n\n    #[error(\"Channel ID already exists\")]\n    ChannelIdAlreadyExists {},\n\n    #[error(\"User name not found\")]\n    UserNameNotFound {},\n\n    #[error(\"User name already taken\")]\n    UserNameAlreadyTaken {},\n\n    #[error(\"Saving channel details failed\")]\n    SaveChannelDetailsFailed {},\n\n    #[error(\"Saving reserved usernames failed\")]\n    SaveReservedUsernamesFailed {},\n\n    #[error(\"Reserved username not found\")]\n    UsernameNotReserved {},\n\n    #[error(\"Collaborator already exists\")]\n    CollaboratorExists {},\n\n    #[error(\"Invalid share percentage\")]\n    InvalidSharePercentage {},\n\n    #[error(\"Collaborator not found\")]\n    CollaboratorNotFound {},\n\n    #[error(\"Collaborator expired\")]\n    CollaboratorExpired {},\n\n    #[error(\"Total unique collaborators limit exceeded\")]\n    TotalUniqueCollaboratorsLimitExceeded {},\n\n    #[error(\"Follower not found\")]\n    FollowerNotFound {},\n\n    #[error(\"Already following\")]\n    AlreadyFollowing {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","channel-manager","src","lib.rs"],"content":"pub mod channel;\npub mod error;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","pauser","src","lib.rs"],"content":"use cosmwasm_std::{Addr, StdError, Storage};\nuse cw_storage_plus::Item;\nuse thiserror::Error;\n\npub const PAUSED_KEY: \u0026str = \"paused\";\npub const PAUSERS_KEY: \u0026str = \"pausers\";\n\n#[derive(Error, Debug, PartialEq)]\npub enum PauseError {\n    #[error(transparent)]\n    Std(#[from] StdError),\n\n    #[error(\"contract is paused\")]\n    Paused {},\n\n    #[error(\"unauthorized pauser ({sender})\")]\n    Unauthorized { sender: Addr },\n}\n\npub struct PauseState {\n    pub paused: Item\u003cbool\u003e,\n    pub pausers: Item\u003cVec\u003cAddr\u003e\u003e,\n}\n\nimpl PauseState {\n    /// Creates a new pause orchestrator using the provided storage\n    /// keys.\n    pub fn new() -\u003e Result\u003cSelf, PauseError\u003e {\n        // Initiate the storage items empty\n        let paused = Item::new(PAUSED_KEY);\n        let pausers = Item::new(PAUSERS_KEY);\n        Ok(PauseState { paused, pausers })\n    }\n\n    /// Sets a new pauser who may pause the contract.\n    /// If no pausers are set, sets pausers to the provided addresses without authorization.\n    /// If pausers are already set, sender must be one of the pausers.\n    /// Also unpauses\n    pub fn set_pausers(\n        \u0026self,\n        storage: \u0026mut dyn Storage,\n        sender: Addr,\n        pausers: Vec\u003cAddr\u003e,\n    ) -\u003e Result\u003c(), PauseError\u003e {\n        let mut current_pausers = self.pausers.load(storage).unwrap_or_default();\n        if current_pausers.is_empty() {\n            current_pausers = pausers;\n        } else {\n            self.error_if_unauthorized(storage, \u0026sender)?;\n            current_pausers = pausers;\n        }\n        self.pausers.save(storage, \u0026current_pausers)?;\n        self.paused.save(storage, \u0026false)?;\n        Ok(())\n    }\n\n    /// Errors if the module is paused, does nothing otherwise.\n    pub fn error_if_paused(\u0026self, storage: \u0026dyn Storage) -\u003e Result\u003c(), PauseError\u003e {\n        if self.paused.load(storage)? {\n            Err(PauseError::Paused {})\n        } else {\n            Ok(())\n        }\n    }\n    pub fn error_if_unauthorized(\n        \u0026self,\n        storage: \u0026dyn Storage,\n        sender: \u0026Addr,\n    ) -\u003e Result\u003c(), PauseError\u003e {\n        let pausers = self.pausers.load(storage)?;\n        if !pausers.contains(sender) {\n            Err(PauseError::Unauthorized {\n                sender: sender.clone(),\n            })\n        } else {\n            Ok(())\n        }\n    }\n\n    pub fn pause(\u0026self, storage: \u0026mut dyn Storage, sender: \u0026Addr) -\u003e Result\u003c(), PauseError\u003e {\n        self.error_if_paused(storage)?;\n        self.error_if_unauthorized(storage, sender)?;\n        self.paused.save(storage, \u0026true)?;\n        Ok(())\n    }\n\n    pub fn unpause(\u0026self, storage: \u0026mut dyn Storage, sender: \u0026Addr) -\u003e Result\u003c(), PauseError\u003e {\n        self.error_if_unauthorized(storage, sender)?;\n        self.paused.save(storage, \u0026false)?;\n        Ok(())\n    }\n\n    pub fn is_paused(\u0026self, storage: \u0026dyn Storage) -\u003e Result\u003cbool, PauseError\u003e {\n        let is_paused = self.paused.load(storage).unwrap_or(false);\n        Ok(is_paused)\n    }\n\n    pub fn get_pausers(\u0026self, storage: \u0026dyn Storage) -\u003e Result\u003cVec\u003cAddr\u003e, PauseError\u003e {\n        let pausers = self.pausers.load(storage).unwrap_or_default();\n        Ok(pausers)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::mock_dependencies;\n\n    #[test]\n    fn test_pause_state() {\n        let mut deps = mock_dependencies();\n\n        let pauser1 = Addr::unchecked(\"pauser1\");\n        let pauser2 = Addr::unchecked(\"pauser2\");\n        let pauser3 = Addr::unchecked(\"pauser3\");\n\n        let state = PauseState::new().unwrap();\n\n        // no pausers set\n        assert_eq!(\n            state.set_pausers(\u0026mut deps.storage, pauser1.clone(), vec![]),\n            Ok(())\n        );\n        assert_eq!(\n            state.set_pausers(\u0026mut deps.storage, pauser2.clone(), vec![]),\n            Ok(())\n        );\n        assert_eq!(\n            state.set_pausers(\u0026mut deps.storage, pauser3.clone(), vec![]),\n            Ok(())\n        );\n\n        // pausers set\n        assert_eq!(\n            state.set_pausers(\n                \u0026mut deps.storage,\n                pauser1.clone(),\n                vec![pauser1.clone(), pauser2.clone()]\n            ),\n            Ok(())\n        );\n\n        assert_eq!(\n            state.set_pausers(\n                \u0026mut deps.storage,\n                pauser2.clone(),\n                vec![pauser1.clone(), pauser2.clone()]\n            ),\n            Ok(())\n        );\n        assert_eq!(\n            state.set_pausers(\n                \u0026mut deps.storage,\n                pauser3.clone(),\n                vec![pauser1.clone(), pauser2.clone()]\n            ),\n            Err(PauseError::Unauthorized {\n                sender: pauser3.clone()\n            })\n        );\n\n        // pause\n        assert_eq!(state.pause(\u0026mut deps.storage, \u0026pauser1), Ok(()));\n        assert_eq!(\n            state.pause(\u0026mut deps.storage, \u0026pauser2),\n            Err(PauseError::Paused {})\n        );\n        assert_eq!(\n            state.pause(\u0026mut deps.storage, \u0026pauser3.clone()),\n            Err(PauseError::Paused {})\n        );\n\n        // unpause\n        assert_eq!(state.unpause(\u0026mut deps.storage, \u0026pauser1), Ok(()));\n        assert_eq!(state.unpause(\u0026mut deps.storage, \u0026pauser2), Ok(()));\n        assert_eq!(\n            state.unpause(\u0026mut deps.storage, \u0026pauser3),\n            Err(PauseError::Unauthorized { sender: pauser3 })\n        );\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":440}},{"line":30,"address":[],"length":0,"stats":{"Line":440}},{"line":31,"address":[],"length":0,"stats":{"Line":440}},{"line":32,"address":[],"length":0,"stats":{"Line":440}},{"line":39,"address":[],"length":0,"stats":{"Line":78}},{"line":45,"address":[],"length":0,"stats":{"Line":78}},{"line":46,"address":[],"length":0,"stats":{"Line":154}},{"line":47,"address":[],"length":0,"stats":{"Line":76}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":77}},{"line":53,"address":[],"length":0,"stats":{"Line":77}},{"line":54,"address":[],"length":0,"stats":{"Line":77}},{"line":58,"address":[],"length":0,"stats":{"Line":370}},{"line":59,"address":[],"length":0,"stats":{"Line":370}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":366}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":16}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":81,"address":[],"length":0,"stats":{"Line":7}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}}],"covered":31,"coverable":37},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","testing","src","app.rs"],"content":"use std::ops::{Deref, DerefMut};\n\nuse crate::stargate::StargateKeeper;\nuse cosmwasm_std::{testing::MockApi, Empty, GovMsg, IbcMsg, IbcQuery, MemoryStorage};\nuse cw_multi_test::{no_init, App, AppBuilder, BankKeeper, FailingModule, WasmKeeper};\n\n#[allow(clippy::type_complexity)]\npub struct OmniflixApp(\n    App\u003c\n        BankKeeper,\n        MockApi,\n        MemoryStorage,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        WasmKeeper\u003cEmpty, Empty\u003e,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        FailingModule\u003cIbcMsg, IbcQuery, Empty\u003e,\n        FailingModule\u003cGovMsg, Empty, Empty\u003e,\n        StargateKeeper,\n    \u003e,\n);\n\nimpl Deref for OmniflixApp {\n    type Target = App\u003c\n        BankKeeper,\n        MockApi,\n        MemoryStorage,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        WasmKeeper\u003cEmpty, Empty\u003e,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        FailingModule\u003cIbcMsg, IbcQuery, Empty\u003e,\n        FailingModule\u003cGovMsg, Empty, Empty\u003e,\n        StargateKeeper,\n    \u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for OmniflixApp {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\nimpl Default for OmniflixApp {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl OmniflixApp {\n    pub fn new() -\u003e Self {\n        let stargate = StargateKeeper {};\n        let app_builder = AppBuilder::new();\n        let app = app_builder.with_stargate(stargate).build(no_init);\n        OmniflixApp(app)\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":58}},{"line":38,"address":[],"length":0,"stats":{"Line":58}},{"line":43,"address":[],"length":0,"stats":{"Line":1087}},{"line":44,"address":[],"length":0,"stats":{"Line":1087}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":70}},{"line":56,"address":[],"length":0,"stats":{"Line":70}},{"line":57,"address":[],"length":0,"stats":{"Line":70}},{"line":58,"address":[],"length":0,"stats":{"Line":70}},{"line":59,"address":[],"length":0,"stats":{"Line":70}}],"covered":9,"coverable":11},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","testing","src","lib.rs"],"content":"pub mod app;\npub mod stargate;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","testing","src","stargate.rs"],"content":"use anyhow::{bail, Result};\nuse cosmwasm_std::{from_json, to_json_binary, Addr, Api, Binary, BlockInfo, Querier, Storage};\nuse cw_multi_test::{error::AnyResult, AppResponse, CosmosRouter, Stargate};\nuse omniflix_std::types::omniflix::onft::v1beta1::{\n    Collection, Denom, MsgCreateDenom, MsgMintOnft, QueryOnftRequest, QueryOnftResponse,\n};\nuse omniflix_std::types::{\n    cosmos::base::v1beta1::Coin,\n    omniflix::onft::v1beta1::{Onft, Params, QueryParamsResponse},\n};\nuse prost::{DecodeError, Message};\n\nconst COLLECTION_PREFIX: \u0026str = \"collection\";\n\npub struct StargateKeeper {}\n\nimpl StargateKeeper {}\n\nimpl Stargate for StargateKeeper {\n    fn execute_stargate\u003cExecC, QueryC\u003e(\n        \u0026self,\n        _api: \u0026dyn Api,\n        storage: \u0026mut dyn Storage,\n        _router: \u0026dyn CosmosRouter\u003cExecC = ExecC, QueryC = QueryC\u003e,\n        _block: \u0026BlockInfo,\n        sender: Addr,\n        type_url: String,\n        value: Binary,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        if type_url == *\"/OmniFlix.onft.v1beta1.MsgCreateDenom\" {\n            let parsed_msg: Result\u003cMsgCreateDenom, DecodeError\u003e = Message::decode(value.as_slice());\n            if let Ok(msg) = parsed_msg {\n                let collection = Collection {\n                    denom: Some(Denom {\n                        creator: sender.to_string(),\n                        data: msg.data,\n                        name: msg.name,\n                        id: msg.id.clone(),\n                        preview_uri: msg.preview_uri,\n                        description: msg.description,\n                        schema: msg.schema,\n                        symbol: msg.symbol,\n                        uri: msg.uri,\n                        uri_hash: msg.uri_hash,\n                        royalty_receivers: msg.royalty_receivers,\n                    }),\n                    onfts: vec![],\n                };\n                let key = format!(\"collections:{}:{}\", COLLECTION_PREFIX, msg.id);\n                let serialized_collection =\n                    to_json_binary(\u0026collection).expect(\"Failed to serialize Collection\");\n                storage.set(key.as_bytes(), \u0026serialized_collection);\n            }\n        }\n        if type_url == *\"/OmniFlix.onft.v1beta1.MsgMintONFT\" {\n            let parsed_msg: Result\u003cMsgMintOnft, DecodeError\u003e = Message::decode(value.as_slice());\n            if let Ok(msg) = parsed_msg {\n                let key = format!(\"collections:{}:{}\", COLLECTION_PREFIX, msg.denom_id);\n                let serialized_collection = storage.get(key.as_bytes());\n                let mut collection: Collection = from_json(serialized_collection.unwrap())\n                    .expect(\"Failed to deserialize Collection\");\n                let onft = Onft {\n                    id: msg.id,\n                    created_at: None,\n                    nsfw: msg.nsfw,\n                    owner: msg.recipient,\n                    data: msg.data,\n                    transferable: msg.transferable,\n                    extensible: msg.extensible,\n                    metadata: msg.metadata,\n                    royalty_share: msg.royalty_share,\n                };\n                collection.onfts.push(onft);\n                let serialized_collection =\n                    to_json_binary(\u0026collection).expect(\"Failed to serialize Collection\");\n                storage.set(key.as_bytes(), \u0026serialized_collection);\n            };\n        }\n        Ok(AppResponse::default())\n    }\n\n    fn query_stargate(\n        \u0026self,\n        _api: \u0026dyn Api,\n        storage: \u0026dyn Storage,\n        _querier: \u0026dyn Querier,\n        _block: \u0026BlockInfo,\n        path: String,\n        data: Binary,\n    ) -\u003e AnyResult\u003cBinary\u003e {\n        if path == *\"/OmniFlix.onft.v1beta1.Query/Params\" {\n            let params = QueryParamsResponse {\n                params: Some(Params {\n                    denom_creation_fee: Some(Coin {\n                        denom: \"uflix\".to_string(),\n                        amount: \"1000000\".to_string(),\n                    }),\n                }),\n            };\n            return Ok(to_json_binary(\u0026params)?);\n        }\n        if path == *\"/OmniFlix.onft.v1beta1.Query/ONFT\" {\n            let query_msg: Result\u003cQueryOnftRequest, DecodeError\u003e = Message::decode(data.as_slice());\n            if let Ok(msg) = query_msg {\n                let key = format!(\"collections:{}:{}\", COLLECTION_PREFIX, msg.denom_id);\n                let serialized_collection = storage.get(key.as_bytes());\n                if serialized_collection.is_none() {\n                    return Ok(to_json_binary(\u0026QueryOnftResponse { onft: None })?);\n                }\n                let collection: Collection = from_json(serialized_collection.unwrap())\n                    .expect(\"Failed to deserialize Collection\");\n                let onft = collection\n                    .onfts\n                    .iter()\n                    .find(|onft| onft.id == msg.id)\n                    .expect(\"Onft not found\");\n                let response = QueryOnftResponse {\n                    onft: Some(onft.clone()),\n                };\n                return Ok(to_json_binary(\u0026response)?);\n            }\n        }\n        Ok(data)\n    }\n\n    fn execute_any\u003cExecC, QueryC\u003e(\n        \u0026self,\n        _api: \u0026dyn Api,\n        _storage: \u0026mut dyn Storage,\n        _router: \u0026dyn CosmosRouter\u003cExecC = ExecC, QueryC = QueryC\u003e,\n        _block: \u0026BlockInfo,\n        _sender: Addr,\n        _msg: cosmwasm_std::AnyMsg,\n    ) -\u003e AnyResult\u003cAppResponse\u003e\n    where\n        ExecC: cosmwasm_std::CustomMsg + serde::de::DeserializeOwned + 'static,\n        QueryC: cosmwasm_std::CustomQuery + serde::de::DeserializeOwned + 'static,\n    {\n        bail!(\"execute_any not implemented\")\n    }\n\n    fn query_grpc(\n        \u0026self,\n        _api: \u0026dyn Api,\n        _storage: \u0026dyn Storage,\n        _querier: \u0026dyn Querier,\n        _block: \u0026BlockInfo,\n        _request: cosmwasm_std::GrpcQuery,\n    ) -\u003e AnyResult\u003cBinary\u003e {\n        bail!(\"query_grpc not implemented\")\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":152}},{"line":30,"address":[],"length":0,"stats":{"Line":152}},{"line":31,"address":[],"length":0,"stats":{"Line":83}},{"line":32,"address":[],"length":0,"stats":{"Line":166}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":152}},{"line":56,"address":[],"length":0,"stats":{"Line":69}},{"line":57,"address":[],"length":0,"stats":{"Line":207}},{"line":58,"address":[],"length":0,"stats":{"Line":69}},{"line":59,"address":[],"length":0,"stats":{"Line":69}},{"line":60,"address":[],"length":0,"stats":{"Line":69}},{"line":63,"address":[],"length":0,"stats":{"Line":69}},{"line":65,"address":[],"length":0,"stats":{"Line":69}},{"line":66,"address":[],"length":0,"stats":{"Line":69}},{"line":67,"address":[],"length":0,"stats":{"Line":69}},{"line":68,"address":[],"length":0,"stats":{"Line":69}},{"line":69,"address":[],"length":0,"stats":{"Line":69}},{"line":70,"address":[],"length":0,"stats":{"Line":69}},{"line":71,"address":[],"length":0,"stats":{"Line":69}},{"line":73,"address":[],"length":0,"stats":{"Line":69}},{"line":74,"address":[],"length":0,"stats":{"Line":69}},{"line":75,"address":[],"length":0,"stats":{"Line":69}},{"line":76,"address":[],"length":0,"stats":{"Line":69}},{"line":79,"address":[],"length":0,"stats":{"Line":152}},{"line":82,"address":[],"length":0,"stats":{"Line":384}},{"line":91,"address":[],"length":0,"stats":{"Line":384}},{"line":93,"address":[],"length":0,"stats":{"Line":72}},{"line":100,"address":[],"length":0,"stats":{"Line":72}},{"line":102,"address":[],"length":0,"stats":{"Line":312}},{"line":103,"address":[],"length":0,"stats":{"Line":312}},{"line":104,"address":[],"length":0,"stats":{"Line":624}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":311}},{"line":112,"address":[],"length":0,"stats":{"Line":311}},{"line":113,"address":[],"length":0,"stats":{"Line":311}},{"line":115,"address":[],"length":0,"stats":{"Line":624}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}}],"covered":35,"coverable":47},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","asset.rs"],"content":"use cosmwasm_schema::cw_serde;\n\nuse crate::channel::ChannelId;\n\npub type PublishId = String;\n/// Used to identify an asset over a channel and all contract\npub type AssetKey = (ChannelId, PublishId);\n/// Used to identify a flags of assets\npub type FlagKey = (String, AssetKey);\n\n#[cw_serde]\npub struct Playlist {\n    pub playlist_name: String,\n    pub assets: Vec\u003cAssetKey\u003e,\n}\n\n#[cw_serde]\npub enum AssetSource {\n    Nft {\n        collection_id: String,\n        onft_id: String,\n    },\n    OffChain {},\n}\n\n// Implement to string for AssetSource\nimpl std::fmt::Display for AssetSource {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            AssetSource::Nft {\n                collection_id,\n                onft_id,\n            } =\u003e write!(f, \"ONFT: {} {}\", collection_id, onft_id),\n            AssetSource::OffChain {} =\u003e write!(f, \"OffChain\"),\n        }\n    }\n}\n\n#[cw_serde]\npub struct Asset {\n    pub channel_id: String,\n    pub publish_id: String,\n    pub asset_source: AssetSource,\n    pub is_visible: bool,\n}\n\n#[cw_serde]\n#[derive(Default)]\npub struct AssetMetadata {\n    pub name: String,\n    pub description: String,\n    pub media_uri: String,\n}\n\n#[cw_serde]\npub enum Flag {\n    NSFW,\n    Explicit,\n    Spam,\n    Hateful,\n    Other(String),\n}\nimpl std::fmt::Display for Flag {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            Flag::NSFW =\u003e write!(f, \"NSFW\"),\n            Flag::Explicit =\u003e write!(f, \"Explicit\"),\n            Flag::Spam =\u003e write!(f, \"Spam\"),\n            Flag::Hateful =\u003e write!(f, \"Hateful\"),\n            Flag::Other(s) =\u003e write!(f, \"Other: {}\", s),\n        }\n    }\n}\n\nimpl Flag {\n    pub fn to_key(\u0026self) -\u003e String {\n        match self {\n            Flag::NSFW =\u003e \"n\".to_string(),\n            Flag::Explicit =\u003e \"e\".to_string(),\n            Flag::Spam =\u003e \"s\".to_string(),\n            Flag::Hateful =\u003e \"h\".to_string(),\n            Flag::Other(_) =\u003e \"o\".to_string(),\n        }\n    }\n    pub fn values() -\u003e Vec\u003cFlag\u003e {\n        vec![\n            Flag::NSFW,\n            Flag::Explicit,\n            Flag::Spam,\n            Flag::Hateful,\n            Flag::Other(String::new()), // Assuming you want to include this variant\n        ]\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":122}},{"line":29,"address":[],"length":0,"stats":{"Line":122}},{"line":31,"address":[],"length":0,"stats":{"Line":10}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":34,"address":[],"length":0,"stats":{"Line":112}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":31}},{"line":77,"address":[],"length":0,"stats":{"Line":31}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":6}}],"covered":23,"coverable":27},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","channel.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Decimal};\npub type ChannelId = String;\npub type UserName = String;\n\n#[cw_serde]\npub struct ChannelDetails {\n    pub channel_id: String,\n    pub user_name: String,\n    pub onft_id: String,\n    pub payment_address: Addr,\n}\n\n#[cw_serde]\npub struct ChannelMetadata {\n    pub channel_name: String,\n    pub description: Option\u003cString\u003e,\n    pub profile_picture: Option\u003cString\u003e,\n    pub banner_picture: Option\u003cString\u003e,\n}\n\n#[cw_serde]\n// This is a struct that used for each onft's additional data field.\npub struct ChannelOnftData {\n    pub onft_id: String,\n    pub channel_id: String,\n    pub user_name: String,\n}\n#[cw_serde]\npub struct ChannelCollaborator {\n    pub role: Role,\n    pub share: Decimal,\n}\n\n#[cw_serde]\npub enum Role {\n    Admin,\n    Publisher,\n    Moderator,\n}\nuse std::fmt::{Display, Formatter, Result};\n\nimpl Display for Role {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        match self {\n            Role::Admin =\u003e write!(f, \"admin\"),\n            Role::Moderator =\u003e write!(f, \"moderator\"),\n            Role::Publisher =\u003e write!(f, \"publisher\"),\n        }\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","config.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Coin};\n\n#[cw_serde]\npub struct ChannelConractConfig {\n    pub channels_collection_id: String,\n    pub channel_creation_fee: Vec\u003cCoin\u003e,\n    pub accepted_tip_denoms: Vec\u003cString\u003e,\n    pub auth_details: AuthDetails,\n}\n\n#[cw_serde]\npub struct AuthDetails {\n    pub protocol_admin: Addr,\n    pub fee_collector: Addr,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","lib.rs"],"content":"pub mod asset;\npub mod channel;\npub mod config;\npub mod msg;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","msg.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Binary, Coin, Decimal};\n\nuse crate::{\n    asset::{Asset, AssetKey, AssetMetadata, AssetSource, Flag, Playlist},\n    channel::{ChannelCollaborator, ChannelDetails, ChannelMetadata},\n    config::ChannelConractConfig,\n};\n\n#[cw_serde]\npub struct InstantiateMsg {\n    pub protocol_admin: Addr,\n    pub fee_collector: Addr,\n    pub channels_collection_details: ChannelsCollectionDetails,\n    pub channel_token_details: ChannelTokenDetails,\n    pub channel_creation_fee: Vec\u003cCoin\u003e,\n    pub accepted_tip_denoms: Vec\u003cString\u003e,\n    pub reserved_usernames: Vec\u003cReservedUsername\u003e,\n}\n\n#[cw_serde]\npub struct ChannelsCollectionDetails {\n    pub collection_id: String,\n    pub collection_name: String,\n    pub collection_symbol: String,\n    pub description: String,\n    pub preview_uri: String,\n    pub schema: String,\n    pub uri: String,\n    pub uri_hash: String,\n    pub data: String,\n}\n\n#[cw_serde]\npub struct ChannelTokenDetails {\n    pub description: String,\n    pub media_uri: String,\n    pub preview_uri: String,\n    pub uri_hash: String,\n    pub transferable: bool,\n    pub extensible: bool,\n    pub nsfw: bool,\n    pub royalty_share: String,\n}\n\n#[cw_serde]\npub struct ReservedUsername {\n    pub username: String,\n    pub address: Option\u003cAddr\u003e,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Updates the configuration of the contract, including the channel creation fee,\n    /// protocol admin, and fee collector. Only callable by the protocol admin.\n    AdminSetConfig {\n        /// (Optional) The new channel creation fee.\n        channel_creation_fee: Option\u003cVec\u003cCoin\u003e\u003e,\n        /// (Optional) The new admin address.\n        protocol_admin: Option\u003cString\u003e,\n        /// (Optional) The new fee collector address.\n        fee_collector: Option\u003cString\u003e,\n    },\n    /// Removes assets from the contract.\n    /// Only callable by the protocol admin.    \n    AdminRemoveAssets {\n        /// The keys of the assets to be removed.\n        asset_keys: Vec\u003cAssetKey\u003e,\n        /// Removes all flags from the assets if set to true.\n        refresh_flags: Option\u003cbool\u003e,\n    },\n    /// Manages reserved usernames.\n    /// Only callable by the protocol admin.\n    /// Can set an address as a reserved username\n    /// Can remove reserved usernames\n    /// Can add reserved usernames\n    AdminManageReservedUsernames {\n        /// (Optional) A list of addresses to be set as reserved usernames.\n        add_usernames: Option\u003cVec\u003cReservedUsername\u003e\u003e,\n        /// (Optional) A list of addresses to be removed from reserved usernames.\n        remove_usernames: Option\u003cVec\u003cString\u003e\u003e,\n    },\n    /// Pauses all channel-related operations. Only callable by a pauser.\n    Pause {},\n\n    /// Resumes all paused operations. Only callable by a pauser.\n    Unpause {},\n\n    /// Updates the list of accounts allowed to pause and unpause the contract.\n    /// Only callable by an admin.\n    SetPausers {\n        /// A list of addresses to be set as pausers.\n        pausers: Vec\u003cString\u003e,\n    },\n    /// Publishes an asset to a channel. The contract will generate and store a publish ID.\n    /// Only callable by the channel owner or a collaborator.\n    AssetPublish {\n        /// The source of the asset.\n        asset_source: AssetSource,\n        /// A salt value used for unique identification.\n        salt: Binary,\n        /// The ID of the channel where the asset is published.\n        channel_id: String,\n        /// (Optional) The name of the playlist where the asset is added.\n        playlist_name: Option\u003cString\u003e,\n        /// A flag indicating if the asset is visible to the public.\n        is_visible: bool,\n        /// The metadata of the asset.\n        metadata: AssetMetadata,\n    },\n\n    /// Unpublishes an asset from a channel. The publish ID and related asset details will\n    /// be removed from the contract state. Only callable by the channel owner or a collaborator.\n    AssetUnpublish {\n        /// The ID of the publish to be removed.\n        publish_id: String,\n        /// The ID of the channel where the asset is unpublished.\n        channel_id: String,\n    },\n\n    /// Updates the details of a published asset, including its visibility status.\n    /// Only callable by the channel owner.\n    AssetUpdateDetails {\n        /// The ID of the publish to be updated.\n        publish_id: String,\n        /// The ID of the channel where the asset is published.\n        channel_id: String,\n        /// The new visibility status of the asset.\n        is_visible: Option\u003cbool\u003e,\n        /// The new name of the asset.\n        name: Option\u003cString\u003e,\n        /// The new description of the asset.\n        description: Option\u003cString\u003e,\n        /// The new media URI of the asset.\n        media_uri: Option\u003cString\u003e,\n    },\n    AssetFlag {\n        /// The ID of the channel where the asset is published.\n        channel_id: String,\n        /// The ID of the publish to be flagged.\n        publish_id: String,\n        /// The flag value.\n        flag: Flag,\n    },\n    /// Creates a new playlist in the specified channel. The playlist name must be unique\n    /// within the channel. Only callable by the channel owner or a collaborator.\n    PlaylistCreate {\n        /// The unique name of the playlist.\n        playlist_name: String,\n        /// The ID of the channel where the playlist is created.\n        channel_id: String,\n    },\n\n    /// Deletes an existing playlist from the channel.\n    /// Only callable by the channel owner or a collaborator.\n    PlaylistDelete {\n        /// The name of the playlist to be deleted.\n        playlist_name: String,\n        /// The ID of the channel where the playlist exists.\n        channel_id: String,\n    },\n\n    /// Adds an asset to a playlist. The asset must already be published in the channel\n    /// and must be visible. Only callable by the channel owner or a collaborator.\n    PlaylistAddAsset {\n        /// The publish ID of the asset to be added.\n        publish_id: String,\n        /// The ID of the channel where the asset is currently published.\n        asset_channel_id: String,\n        /// The ID of the channel where the playlist exists.\n        channel_id: String,\n        /// The name of the playlist where the asset will be added.\n        playlist_name: String,\n    },\n\n    /// Removes an asset from a playlist.\n    /// Only callable by the channel owner or a collaborator.\n    PlaylistRemoveAsset {\n        /// The publish ID of the asset to be removed.\n        publish_id: String,\n        /// The ID of the channel where the playlist exists.\n        channel_id: String,\n        /// The name of the playlist where the asset is being removed.\n        playlist_name: String,\n    },\n\n    /// Refreshes a playlist by removing all assets that are either unpublished\n    /// or no longer visible. Only callable by the channel owner or a collaborator.\n    PlaylistRefresh {\n        /// The ID of the channel where the playlist exists.\n        channel_id: String,\n        /// The name of the playlist to be refreshed.\n        playlist_name: String,\n    },\n\n    /// Creates a new channel. The contract will generate a channel ID and mint an NFT\n    /// for the owner.\n    /// The owner must pay the `channel_creation_fee` to create a channel.\n    ChannelCreate {\n        /// A salt value used for unique identification.\n        salt: Binary,\n        /// The user name of the channel owner.\n        user_name: String,\n        /// Name of the channel\n        channel_name: String,\n        /// A description of the channel.\n        description: Option\u003cString\u003e,\n        /// The payment address of the channel owner.\n        payment_address: Addr,\n        /// (Optional) Profile image of the channel\n        profile_picture: Option\u003cString\u003e,\n        /// (Optional) Banner image of the channel\n        banner_picture: Option\u003cString\u003e,\n    },\n\n    /// Deletes an existing channel. The channel ID and related details will be removed\n    /// from the contract state. Only callable by the channel owner.\n    ChannelDelete {\n        /// The ID of the channel to be deleted.\n        channel_id: String,\n    },\n    /// Updates the details of an existing channel. Only callable by the channel owner.\n    ChannelUpdateDetails {\n        /// The ID of the channel to be updated.\n        channel_id: String,\n        /// The new description of the channel.\n        /// (Optional) The new description of the channel.\n        description: Option\u003cString\u003e,\n        /// (Optional) The new name of the channel.\n        channel_name: Option\u003cString\u003e,\n        /// (Optional) The new profile image of the channel.\n        profile_picture: Option\u003cString\u003e,\n        /// (Optional) The new banner image of the channel.\n        banner_picture: Option\u003cString\u003e,\n        /// (Optional) The new payment address of the channel.\n        payment_address: Option\u003cString\u003e,\n    },\n    /// Tipping a channel\n    ChannelTip {\n        /// The ID of the channel to be tipped.\n        channel_id: String,\n        /// The amount of tokens to be tipped.\n        amount: Coin,\n        /// The asset id to be tipped. Only for indexing purposes. Not used for anything else.\n        asset_id: Option\u003cString\u003e,\n    },\n    /// Adds a collaborator to a channel.\n    /// Only callable by the channel owner.\n    ChannelAddCollaborator {\n        /// The ID of the channel to add the collaborator to.\n        channel_id: String,\n        /// The address of the collaborator to be added.\n        collaborator_address: String,\n        /// Collaborator details\n        collaborator_details: ChannelCollaborator,\n    },\n    /// Removes a collaborator from a channel.\n    /// Only callable by the channel owner.\n    ChannelRemoveCollaborator {\n        /// The ID of the channel to remove the collaborator from.\n        channel_id: String,\n        /// The address of the collaborator to be removed.\n        collaborator_address: String,\n    },\n\n    /// Follow a channel\n    ChannelFollow {\n        /// The ID of the channel to follow.\n        channel_id: String,\n    },\n\n    /// Unfollow a channel\n    ChannelUnfollow {\n        /// The ID of the channel to unfollow.\n        channel_id: String,\n    },\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(bool)]\n    IsPaused {},\n\n    #[returns(Vec\u003cString\u003e)]\n    Pausers {},\n\n    #[returns(ChannelDetails)]\n    ChannelDetails { channel_id: String },\n\n    #[returns(ChannelMetadata)]\n    ChannelMetadata { channel_id: String },\n\n    #[returns(ChannelResponse)]\n    Channel { channel_id: String },\n\n    #[returns(Vec\u003cChannelResponse\u003e)]\n    Channels {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(String)]\n    ChannelId { user_name: String },\n\n    #[returns(Playlist)]\n    Playlist {\n        channel_id: String,\n        playlist_name: String,\n    },\n\n    #[returns(Vec\u003cPlaylist\u003e)]\n    Playlists {\n        channel_id: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(ChannelConractConfig)]\n    Config {},\n\n    #[returns(Vec\u003cAssetResponse\u003e)]\n    Assets {\n        channel_id: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(AssetResponse)]\n    Asset {\n        channel_id: String,\n        publish_id: String,\n    },\n\n    #[returns(Vec\u003cReservedUsername\u003e)]\n    ReservedUsernames {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(CollaboratorInfo)]\n    GetChannelCollaborator {\n        channel_id: String,\n        collaborator_address: Addr,\n    },\n\n    #[returns(Vec\u003cCollaboratorInfo\u003e)]\n    GetChannelCollaborators {\n        channel_id: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(u64)]\n    FollowersCount { channel_id: String },\n\n    #[returns(Vec\u003cString\u003e)]\n    Followers {\n        channel_id: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n}\n// Response for Channel query\n#[cw_serde]\npub struct ChannelResponse {\n    pub channel_id: String,\n    pub user_name: String,\n    pub onft_id: String,\n    pub payment_address: String,\n    pub channel_name: String,\n    pub description: Option\u003cString\u003e,\n    pub profile_picture: Option\u003cString\u003e,\n    pub banner_picture: Option\u003cString\u003e,\n    pub collaborators: Vec\u003cCollaboratorInfo\u003e,\n    pub follower_count: u64,\n}\n\n#[cw_serde]\npub struct AssetResponse {\n    pub asset: Asset,\n    pub flags: Vec\u003cFlagInfo\u003e,\n    pub metadata: AssetMetadata,\n}\n#[cw_serde]\npub struct CollaboratorInfo {\n    pub address: String,\n    pub role: String,\n    pub share: Decimal,\n}\n\n// Create this new type to avoid tuples\n#[cw_serde]\npub struct FlagInfo {\n    pub flag: Flag,\n    pub count: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","helpers","mod.rs"],"content":"#[allow(dead_code)]\npub mod setup;\n#[allow(dead_code)]\npub mod utils;\n\n#[allow(dead_code)]\npub mod msg_wrapper;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","helpers","msg_wrapper.rs"],"content":"use cosmwasm_std::{Addr, Binary};\nuse omniflix_channel_types::{\n    asset::{AssetMetadata, AssetSource},\n    msg::{\n        ChannelTokenDetails, ChannelsCollectionDetails, ExecuteMsg, InstantiateMsg,\n        ReservedUsername,\n    },\n};\n\npub fn get_channel_instantiate_msg(admin: Addr) -\u003e InstantiateMsg {\n    InstantiateMsg {\n        channel_creation_fee: vec![],\n        fee_collector: admin.clone(),\n        protocol_admin: admin.clone(),\n        accepted_tip_denoms: vec![\"uflix\".to_string()],\n        channel_token_details: ChannelTokenDetails {\n            media_uri: \"https://example.com/media.png\".to_string(),\n            preview_uri: \"https://example.com/preview.png\".to_string(),\n            description: \"Channel token details\".to_string(),\n            uri_hash: \"\".to_string(),\n            transferable: true,\n            extensible: true,\n            nsfw: false,\n            royalty_share: \"0\".to_string(),\n        },\n        channels_collection_details: ChannelsCollectionDetails {\n            collection_id: \"Channels\".to_string(),\n            collection_name: \"Channels\".to_string(),\n            collection_symbol: \"CH\".to_string(),\n            description: \"Channels collection\".to_string(),\n            preview_uri: \"https://example.com/preview.png\".to_string(),\n            uri: \"https://example.com/uri\".to_string(),\n            schema: \"https://example.com/schema\".to_string(),\n            uri_hash: \"\".to_string(),\n            data: \"\".to_string(),\n        },\n        reserved_usernames: vec![ReservedUsername {\n            username: \"reserved\".to_string(),\n            address: None,\n        }],\n    }\n}\n\npub struct CreateChannelMsgBuilder {\n    salt: Binary,\n    user_name: String,\n    description: String,\n    channel_name: String,\n    banner_picture: Option\u003cString\u003e,\n    profile_picture: Option\u003cString\u003e,\n    payment_address: Addr,\n}\n\nimpl CreateChannelMsgBuilder {\n    pub fn new(user_name: \u0026str, payment_address: Addr) -\u003e Self {\n        Self {\n            salt: Binary::from(\"salt\".as_bytes()),\n            user_name: user_name.to_string(),\n            description: \"Default description\".to_string(),\n            channel_name: user_name.to_string(), // Default to the same as user_name\n            banner_picture: None,\n            profile_picture: None,\n            payment_address,\n        }\n    }\n\n    pub fn description(mut self, description: String) -\u003e Self {\n        self.description = description;\n        self\n    }\n\n    pub fn channel_name(mut self, channel_name: String) -\u003e Self {\n        self.channel_name = channel_name;\n        self\n    }\n\n    pub fn banner_picture(mut self, banner_picture: String) -\u003e Self {\n        self.banner_picture = Some(banner_picture);\n        self\n    }\n\n    pub fn profile_picture(mut self, profile_picture: String) -\u003e Self {\n        self.profile_picture = Some(profile_picture);\n        self\n    }\n\n    pub fn salt(mut self, salt: Binary) -\u003e Self {\n        self.salt = salt;\n        self\n    }\n\n    pub fn build(self) -\u003e ExecuteMsg {\n        ExecuteMsg::ChannelCreate {\n            salt: self.salt,\n            user_name: self.user_name,\n            description: Some(self.description),\n            banner_picture: self.banner_picture,\n            profile_picture: self.profile_picture,\n            channel_name: self.channel_name,\n            payment_address: self.payment_address,\n        }\n    }\n}\n\npub struct AssetPublishMsgBuilder {\n    asset_source: AssetSource,\n    salt: Binary,\n    channel_id: String,\n    playlist_name: Option\u003cString\u003e,\n    is_visible: bool,\n    name: String,\n    description: String,\n    media_uri: String,\n}\n\nimpl AssetPublishMsgBuilder {\n    pub fn new(channel_id: String) -\u003e Self {\n        Self {\n            asset_source: AssetSource::OffChain {},\n            salt: Binary::from(\"salt\".as_bytes()),\n            channel_id,\n            playlist_name: None,\n            is_visible: true,\n            name: \"validassetname\".to_string(),\n            description: \"validassetdescription\".to_string(),\n            media_uri: \"https://example.com/media.png\".to_string(),\n        }\n    }\n\n    pub fn asset_source(mut self, asset_source: AssetSource) -\u003e Self {\n        self.asset_source = asset_source;\n        self\n    }\n\n    pub fn playlist_name(mut self, playlist_name: String) -\u003e Self {\n        self.playlist_name = Some(playlist_name);\n        self\n    }\n\n    pub fn set_visible(mut self, is_visible: bool) -\u003e Self {\n        self.is_visible = is_visible;\n        self\n    }\n\n    pub fn name(mut self, name: String) -\u003e Self {\n        self.name = name;\n        self\n    }\n\n    pub fn description(mut self, description: String) -\u003e Self {\n        self.description = description;\n        self\n    }\n\n    pub fn media_uri(mut self, media_uri: String) -\u003e Self {\n        self.media_uri = media_uri;\n        self\n    }\n\n    pub fn build(self) -\u003e ExecuteMsg {\n        ExecuteMsg::AssetPublish {\n            asset_source: self.asset_source,\n            salt: self.salt,\n            channel_id: self.channel_id,\n            playlist_name: self.playlist_name,\n            is_visible: self.is_visible,\n            metadata: AssetMetadata {\n                name: self.name,\n                description: self.description,\n                media_uri: self.media_uri,\n            },\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","helpers","setup.rs"],"content":"use cosmwasm_std::{coin, Addr, BlockInfo, Timestamp};\nuse cw_multi_test::{ContractWrapper, MockApiBech32};\n\nuse super::utils::mint_to_address;\nuse testing::app::OmniflixApp;\n\npub fn setup() -\u003e SetupResponse {\n    let api = MockApiBech32::new(\"cosmwasm\");\n    let mut app = OmniflixApp::new();\n\n    let admin = api.addr_make(\"admin\");\n    let creator = api.addr_make(\"creator\");\n    let creator2 = api.addr_make(\"creator2\");\n    let collector = api.addr_make(\"collector\");\n    let collaborator = api.addr_make(\"collaborator\");\n\n    app.set_block(BlockInfo {\n        chain_id: \"test_1\".to_string(),\n        height: 1_000,\n        time: Timestamp::from_nanos(1_000),\n    });\n\n    // Mint multiple denominations at once for each address\n    mint_to_address(\n        \u0026mut app,\n        creator.to_string(),\n        vec![\n            coin(1_000_000_000, \"uflix\"),\n            coin(1_000_000_000_000, \"different_denom\"),\n            coin(1_000_000_000_000, \"incorrect_denom\"),\n        ],\n    );\n    mint_to_address(\n        \u0026mut app,\n        creator2.to_string(),\n        vec![\n            coin(1_000_000_000, \"uflix\"),\n            coin(1_000_000_000_000, \"different_denom\"),\n            coin(1_000_000_000_000, \"incorrect_denom\"),\n        ],\n    );\n    mint_to_address(\n        \u0026mut app,\n        collector.to_string(),\n        vec![\n            coin(1_000_000_000, \"uflix\"),\n            coin(1_000_000_000_000, \"different_denom\"),\n            coin(1_000_000_000_000, \"incorrect_denom\"),\n        ],\n    );\n    mint_to_address(\n        \u0026mut app,\n        admin.to_string(),\n        vec![\n            coin(1_000_000_000, \"uflix\"),\n            coin(1_000_000_000_000, \"different_denom\"),\n            coin(1_000_000_000_000, \"incorrect_denom\"),\n        ],\n    );\n    mint_to_address(\n        \u0026mut app,\n        collaborator.to_string(),\n        vec![coin(1_000_000_000, \"uflix\")],\n    );\n\n    let channel_contract = Box::new(ContractWrapper::new(\n        omniflix_channel::contract::execute,\n        omniflix_channel::contract::instantiate,\n        omniflix_channel::contract::query,\n    ));\n\n    let channel_contract_code_id = app.store_code(channel_contract);\n\n    SetupResponse {\n        app,\n        test_accounts: TestAccounts {\n            admin,\n            creator,\n            creator2,\n            collaborator,\n            collector,\n        },\n        channel_contract_code_id,\n    }\n}\n\npub struct SetupResponse {\n    pub app: OmniflixApp,\n    pub test_accounts: TestAccounts,\n    pub channel_contract_code_id: u64,\n}\n\npub struct TestAccounts {\n    pub admin: Addr,\n    pub creator: Addr,\n    pub creator2: Addr,\n    pub collaborator: Addr,\n    pub collector: Addr,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","helpers","utils.rs"],"content":"use cosmwasm_std::{from_json, Addr, Coin, CosmosMsg, MemoryStorage, Storage};\nuse cw_multi_test::AppResponse;\nuse omniflix_std::types::omniflix::onft::v1beta1::{Collection, MsgCreateDenom, MsgMintOnft};\nuse testing::app::OmniflixApp;\n\npub fn get_contract_address_from_res(res: AppResponse) -\u003e String {\n    res.events\n        .iter()\n        .find(|e| e.ty == \"instantiate\")\n        .unwrap()\n        .attributes\n        .iter()\n        .find(|a| a.key == \"_contract_address\")\n        .unwrap()\n        .value\n        .clone()\n}\n\npub fn query_onft_collection(storage: \u0026MemoryStorage, minter_address: String) -\u003e Collection {\n    let key = format!(\"collections:{}:{}\", \"collection\", minter_address);\n    let collection = storage.get(key.as_bytes()).unwrap();\n    let collection_details: Collection = from_json(collection).unwrap();\n    collection_details\n}\npub fn mint_to_address(app: \u0026mut OmniflixApp, to_address: String, amount: Vec\u003cCoin\u003e) {\n    app.init_modules(|router, _, storage| {\n        router\n            .bank\n            .init_balance(\n                storage,\n                \u0026Addr::unchecked(to_address.clone()),\n                amount.clone(),\n            )\n            .unwrap()\n    });\n}\npub fn get_event_attribute(res: AppResponse, event_type: \u0026str, attribute_key: \u0026str) -\u003e String {\n    res.events\n        .iter()\n        .find(|e| e.ty == event_type) // Find the event by type\n        .and_then(|e| {\n            e.attributes.iter().find(|attr| attr.key == attribute_key) // Find the attribute by key\n        })\n        .map_or(String::new(), |attr| attr.value.clone()) // Return value or empty string\n}\n\n/// Generates a CosmosMsg to create a denom\npub fn create_denom_msg(\n    sender: String,\n    denom_id: String,\n    name: Option\u003cString\u003e, // Optional: if not provided, default is used\n) -\u003e CosmosMsg {\n    let create_denom_msg = MsgCreateDenom {\n        data: \"data\".to_string(),\n        sender: sender.clone(),\n        creation_fee: None,\n        description: \"description\".to_string(),\n        id: denom_id.clone(),\n        name: name.unwrap_or_else(|| \"Media asset collection\".to_string()),\n        preview_uri: \"preview_uri\".to_string(),\n        royalty_receivers: vec![],\n        schema: \"schema\".to_string(),\n        symbol: \"symbol\".to_string(),\n        uri: \"uri\".to_string(),\n        uri_hash: \"uri_hash\".to_string(),\n    };\n\n    create_denom_msg.into() // Convert to CosmosMsg\n}\n\n/// Generates a CosmosMsg to mint an ONFT\npub fn mint_onft_msg(\n    denom_id: String,\n    onft_id: String, // Renamed from asset_id to onft_id\n    recipient: String,\n) -\u003e CosmosMsg {\n    let mint_onft_msg = MsgMintOnft {\n        denom_id: denom_id.clone(),\n        id: onft_id.clone(),\n        nsfw: false, // Default is false\n        recipient: recipient.clone(),\n        ..Default::default() // Use default values for remaining fields\n    };\n\n    mint_onft_msg.into() // Convert to CosmosMsg\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","lib.rs"],"content":"mod helpers;\n\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","admin","mod.rs"],"content":"pub mod remove_assets;\npub mod set_config;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","admin","remove_assets.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::Asset;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{AssetPublishMsgBuilder, CreateChannelMsgBuilder};\nuse crate::helpers::utils::get_event_attribute;\nuse crate::helpers::{msg_wrapper::get_channel_instantiate_msg, setup::setup};\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Admin removes the asset\n    let remove_assets_msg = ExecuteMsg::AdminRemoveAssets {\n        asset_keys: vec![(channel_id.clone(), publish_id.clone())],\n        refresh_flags: None,\n    };\n\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_assets_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the asset and check if it is removed\n    let query_msg = QueryMsg::Assets {\n        channel_id: channel_id.clone(),\n        start_after: None,\n        limit: None,\n    };\n\n    let assets: Vec\u003cAsset\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert!(assets.is_empty());\n}\n\n#[test]\nfn unauthorized() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Asset creator can not remove the asset with admin remove assets.\n    let remove_assets_msg = ExecuteMsg::AdminRemoveAssets {\n        asset_keys: vec![(channel_id.clone(), publish_id.clone())],\n        refresh_flags: None,\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_assets_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    let err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n\n    assert_eq!(err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn asset_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Admin removes the asset that does not exist\n    let remove_assets_msg = ExecuteMsg::AdminRemoveAssets {\n        asset_keys: vec![(channel_id.clone(), \"publish_id\".to_string())],\n        refresh_flags: None,\n    };\n\n    let res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_assets_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    let err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n\n    assert_eq!(\n        err,\n        \u0026ContractError::Asset(asset_manager::error::AssetError::AssetNotFound {})\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","admin","set_config.rs"],"content":"use cosmwasm_std::{coin, StdError};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::config::ChannelConractConfig;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::{msg_wrapper::get_channel_instantiate_msg, setup::setup};\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Set the config\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                protocol_admin: Some(creator.to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check the contract config\n    let config: ChannelConractConfig = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr, \u0026QueryMsg::Config {})\n        .unwrap();\n    assert_eq!(config.auth_details.protocol_admin, creator);\n}\n\n#[test]\nfn unauthorized() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Set the config\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                protocol_admin: Some(creator.to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn invalid() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Set the config\n    let res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                // Invalid address\n                protocol_admin: Some(\"creator\".to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Std(StdError::generic_err(\"Error decoding bech32\"))\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","flag.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel_types::{\n    asset::{AssetSource, Flag},\n    msg::ExecuteMsg,\n};\n\nuse crate::helpers::msg_wrapper::AssetPublishMsgBuilder;\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::{create_denom_msg, get_event_attribute, mint_onft_msg},\n};\n\n#[test]\nfn flag_asset_happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create an asset for the channel\n    let collection_id = \"collection1\";\n    let asset_id = \"asset1\";\n\n    // Create collection and mint asset\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        collection_id.to_string(),\n        Some(\"Test Collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n\n    let mint_asset_msg = mint_onft_msg(\n        collection_id.to_string(),\n        asset_id.to_string(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_asset_msg);\n\n    // Publish the asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: collection_id.to_string(),\n            onft_id: asset_id.to_string(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // User flags the asset\n    let flag_msg = ExecuteMsg::AssetFlag {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n        flag: Flag::NSFW,\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026flag_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify correct event attributes\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"action\"),\n        \"asset_flag\"\n    );\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"publish_id\"),\n        publish_id\n    );\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"channel_id\"),\n        channel_id\n    );\n    assert_eq!(get_event_attribute(res.clone(), \"wasm\", \"flag\"), \"NSFW\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","mod.rs"],"content":"pub mod flag;\npub mod publish;\npub mod unpublish;\npub mod update_details;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","publish.rs"],"content":"use asset_manager::error::PlaylistError;\nuse cosmwasm_std::{coin, CosmosMsg};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::{AssetSource, Playlist};\nuse omniflix_channel_types::msg::{AssetResponse, ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::AssetPublishMsgBuilder;\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::{create_denom_msg, get_event_attribute, mint_onft_msg},\n};\n\n#[test]\nfn asset_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Try publishing an asset without it existing\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: \"id\".to_string(),\n            onft_id: \"asset_id\".to_string(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::OnftNotFound {\n            collection_id: \"id\".to_string(),\n            onft_id: \"asset_id\".to_string()\n        }\n    );\n}\n#[test]\nfn channel_not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n    // Creator owns the channel\n    // Lets create a asset for collector and try to publish it\n\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        collector.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        collector.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(collector.clone(), cosmos_msg);\n\n    // Publish the asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn playlist_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Creator owns the channel\n    // Lets create a asset for creator and try to publish it\n\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(creator.clone(), cosmos_msg);\n\n    // Publish the asset with wrong playlist name\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .playlist_name(\"Wrong playlist\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistNotFound {})\n    );\n}\n\n#[test]\nfn with_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n    println!(\"channel_id: {}\", channel_id);\n\n    // Creator owns the channel\n    // Lets create a asset for creator and try to publish it\n\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(creator.clone(), cosmos_msg);\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Publish the asset under the new playlist\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .playlist_name(\"My Videos\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Query the new playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Videos\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 1);\n    assert_eq!(playlist.assets[0].1, publish_id);\n}\n\n#[test]\nfn asset_not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        collector.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    // Asset is owned by collector\n    // Creator tries to publish the asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::OnftNotOwned {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone()\n        }\n    );\n}\n\n#[test]\nfn publish_off_chain_asset() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::OffChain {})\n        .name(\"name\".to_string())\n        .description(\"description\".to_string())\n        .media_uri(\"https://omniflix.network/\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Query the asset\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(asset.asset.publish_id, publish_id);\n    assert_eq!(asset.asset.asset_source, AssetSource::OffChain {});\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // We need to create a denom for creator\n    // Then we will mint a onft representing the asset\n    // Then we will publish the asset\n\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(creator.clone(), cosmos_msg);\n\n    // Publish the asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Query the asset\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(asset.asset.publish_id, publish_id);\n    assert_eq!(\n        asset.asset.asset_source,\n        AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","unpublish.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::AssetSource;\nuse omniflix_channel_types::msg::{AssetResponse, ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::AssetPublishMsgBuilder;\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::{create_denom_msg, get_event_attribute, mint_onft_msg},\n};\n\n#[test]\nfn channel_not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    // Create a collection\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Asset Collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    // Publish an asset\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Unpublish the asset with a different user\n    let unpublish_msg = ExecuteMsg::AssetUnpublish {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026unpublish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn asset_not_pubished() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Unpublish the asset\n    // Should return an error\n    let unpublish_msg = ExecuteMsg::AssetUnpublish {\n        publish_id: \"publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026unpublish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Asset(asset_manager::error::AssetError::AssetNotFound {})\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    // Create a collection\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Asset Collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Query the asset and check if it is published\n    let query_msg = QueryMsg::Assets {\n        channel_id: channel_id.clone(),\n        start_after: None,\n        limit: None,\n    };\n\n    let assets: Vec\u003cAssetResponse\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(assets.len(), 1);\n    assert_eq!(assets[0].asset.publish_id, publish_id.clone());\n\n    // Unpublish the asset\n    let unpublish_msg = ExecuteMsg::AssetUnpublish {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026unpublish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the asset and check if it is unpublished\n    let query_msg = QueryMsg::Assets {\n        channel_id: channel_id.clone(),\n        start_after: None,\n        limit: None,\n    };\n\n    let assets: Vec\u003cAssetResponse\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(assets.len(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","update_details.rs"],"content":"use asset_manager::error::AssetError;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::channel::Role;\nuse omniflix_channel_types::msg::{AssetResponse, ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::AssetPublishMsgBuilder;\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::get_event_attribute,\n};\n\n#[test]\nfn asset_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Try to update details of a non-existent asset\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: \"non_existent_publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n        is_visible: Some(false),\n        name: Some(\"Updated Name\".to_string()),\n        description: Some(\"Updated Description\".to_string()),\n        media_uri: Some(\"https://updated-media-uri.com\".to_string()),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026update_details_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Asset(AssetError::AssetNotFound {})\n    );\n}\n\n#[test]\nfn channel_not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let other_user = setup_response.test_accounts.creator2.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Try to update asset details from a non-owner account\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        is_visible: Some(false),\n        name: Some(\"Updated Name\".to_string()),\n        description: Some(\"Updated Description\".to_string()),\n        media_uri: Some(\"https://updated-media-uri.com\".to_string()),\n    };\n\n    let err = app\n        .execute_contract(\n            other_user.clone(),\n            channel_contract_addr.clone(),\n            \u0026update_details_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = err.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn partial_update() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let original_name = \"Original Asset Name\";\n    let original_description = \"Original Asset Description\";\n    let original_media_uri = \"https://original-media-uri.com\";\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .name(original_name.to_string())\n        .description(original_description.to_string())\n        .media_uri(original_media_uri.to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Update only the name of the asset\n    let new_name = \"Updated Asset Name\";\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        is_visible: None,\n        name: Some(new_name.to_string()),\n        description: None,\n        media_uri: None,\n    };\n\n    app.execute_contract(\n        creator.clone(),\n        channel_contract_addr.clone(),\n        \u0026update_details_msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query the asset to verify the update\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset_response: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Verify that only the name was updated\n    assert_eq!(asset_response.metadata.name, new_name);\n    assert_eq!(asset_response.metadata.description, original_description);\n    assert_eq!(asset_response.metadata.media_uri, original_media_uri);\n    assert!(asset_response.asset.is_visible);\n}\n\n#[test]\nfn full_update() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let original_name = \"Original Asset Name\";\n    let original_description = \"Original Asset Description\";\n    let original_media_uri = \"https://original-media-uri.com\";\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .name(original_name.to_string())\n        .description(original_description.to_string())\n        .media_uri(original_media_uri.to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Update all fields of the asset\n    let new_name = \"Completely Updated Name\";\n    let new_description = \"Completely Updated Description\";\n    let new_media_uri = \"https://completely-updated-media-uri.com\";\n\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        is_visible: Some(false),\n        name: Some(new_name.to_string()),\n        description: Some(new_description.to_string()),\n        media_uri: Some(new_media_uri.to_string()),\n    };\n\n    app.execute_contract(\n        creator.clone(),\n        channel_contract_addr.clone(),\n        \u0026update_details_msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query the asset to verify the update\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset_response: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Verify that all fields were updated\n    assert_eq!(asset_response.metadata.name, new_name);\n    assert_eq!(asset_response.metadata.description, new_description);\n    assert_eq!(asset_response.metadata.media_uri, new_media_uri);\n    assert!(!asset_response.asset.is_visible);\n}\n\n#[test]\nfn collaborator_update() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collaborator = setup_response.test_accounts.collaborator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Add collaborator to the channel\n    let add_collaborator_msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collaborator.to_string(),\n        collaborator_details: omniflix_channel_types::channel::ChannelCollaborator {\n            role: Role::Publisher,\n            share: cosmwasm_std::Decimal::percent(10),\n        },\n    };\n\n    app.execute_contract(\n        creator.clone(),\n        channel_contract_addr.clone(),\n        \u0026add_collaborator_msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Publish an asset\n    let original_name = \"Original Asset Name\";\n    let original_description = \"Original Asset Description\";\n    let original_media_uri = \"https://original-media-uri.com\";\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .name(original_name.to_string())\n        .description(original_description.to_string())\n        .media_uri(original_media_uri.to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Collaborator updates the asset details\n    let new_name = \"Collaborator Updated Name\";\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        is_visible: Some(false),\n        name: Some(new_name.to_string()),\n        description: None,\n        media_uri: None,\n    };\n\n    // This should succeed since collaborators should be able to update assets\n    app.execute_contract(\n        collaborator.clone(),\n        channel_contract_addr.clone(),\n        \u0026update_details_msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query the asset to verify the update\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset_response: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Verify that the name was updated and visibility changed\n    assert_eq!(asset_response.metadata.name, new_name);\n    assert_eq!(asset_response.metadata.description, original_description);\n    assert_eq!(asset_response.metadata.media_uri, original_media_uri);\n    assert!(!asset_response.asset.is_visible);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","collaborators.rs"],"content":"use channel_manager::error::ChannelError;\nuse cosmwasm_std::{coin, Decimal, Uint128};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::channel::{ChannelCollaborator, Role};\nuse omniflix_channel_types::msg::{CollaboratorInfo, ExecuteMsg, QueryMsg};\n\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::get_event_attribute,\n};\n\n#[test]\nfn add_collaborator_unauthorized() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Try to add collaborator as unauthorized user\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: creator.clone().into_string(),\n        collaborator_details: ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::from_ratio(Uint128::one(), Uint128::from(3u128)),\n        },\n    };\n\n    let res = app\n        .execute_contract(collector.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn add_collaborator_invalid_share() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Try to add collaborator with share \u003e 100%\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collector.clone().into_string(),\n        collaborator_details: ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(101),\n        },\n    };\n\n    let res = app\n        .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::InvalidSharePercentage {})\n    );\n}\n\n#[test]\nfn add_collaborator_total_unique_limit_exceeded() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Need to add 10 collaborators\n    for i in 0..10 {\n        // Generate a valid cosmos collaborator address\n        let collaborator_address = app.api().addr_make(format!(\"collaborator_{}\", i).as_str());\n\n        let msg = ExecuteMsg::ChannelAddCollaborator {\n            channel_id: channel_id.clone(),\n            collaborator_address: collaborator_address.clone().into_string(),\n            collaborator_details: ChannelCollaborator {\n                role: Role::Moderator,\n                share: Decimal::percent(9),\n            },\n        };\n\n        let _res = app\n            .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n            .unwrap();\n    }\n\n    // Try to add another collaborator should fail\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: app.api().addr_make(\"new_collaborator\").into_string(),\n        collaborator_details: ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(9),\n        },\n    };\n\n    let res = app\n        .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::TotalUniqueCollaboratorsLimitExceeded {})\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Add collaborator successfully\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collector.clone().into_string(),\n        collaborator_details: ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(30),\n        },\n    };\n\n    let _res = app\n        .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Verify collaborator was added\n    let query_msg = QueryMsg::GetChannelCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collector.clone(),\n    };\n\n    let collaborator: CollaboratorInfo = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(collaborator.role, Role::Moderator.to_string());\n    assert_eq!(collaborator.share, Decimal::percent(30));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","create.rs"],"content":"use crate::helpers::msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\nuse channel_manager::error::ChannelError;\nuse cosmwasm_std::{coin, Binary};\nuse cw_multi_test::Executor;\nuse omniflix_channel::string_validation::StringValidationError;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::msg::{ChannelResponse, ExecuteMsg, QueryMsg, ReservedUsername};\n\n#[test]\nfn missing_creation_fee() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Missing creation fee creating a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::PaymentError {\n            expected: [coin(1000000, \"uflix\")].to_vec(),\n            received: (vec![])\n        }\n    );\n}\n\n#[test]\nfn paused() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Pause the contract\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::Pause {},\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Pause(pauser::PauseError::Paused {})\n    );\n}\n\n#[test]\nfn failed_validations() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let channel_create_msg =\n        CreateChannelMsgBuilder::new(\"creatorcreatorcreatorcreatorcreator\", creator.clone())\n            .build();\n\n    // Too long username\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::StringValidationError(StringValidationError::InvalidLength {\n            sent: \"creatorcreatorcreatorcreatorcreator\".to_string(),\n            min_length: 3,\n            max_length: 32,\n        })\n    );\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone())\n        .description(\"a\".repeat(257))\n        .build();\n\n    // Too long description\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::StringValidationError(StringValidationError::InvalidLength {\n            sent: \"a\".repeat(257),\n            min_length: 3,\n            max_length: 256,\n        })\n    );\n}\n#[test]\nfn username_already_exists() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Happy path\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone())\n        .salt(Binary::from(\"salt2\".as_bytes()))\n        .build();\n\n    // Try to create a channel with the same username\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::UserNameAlreadyTaken {})\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Happy path\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    // Validate the creation fee was sent to the fee collector\n    let amount = get_event_attribute(res.clone(), \"transfer\", \"amount\");\n    assert_eq!(amount, \"1000000uflix\");\n    let recipient = get_event_attribute(res.clone(), \"transfer\", \"recipient\");\n    assert_eq!(recipient, admin.to_string());\n\n    // Get onftid from events\n    let onft_id = get_event_attribute(res.clone(), \"wasm\", \"onft_id\");\n\n    // Query channels\n    let channels: Vec\u003cChannelResponse\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::Channels {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(channels.len(), 1);\n    assert_eq!(channels[0].user_name, \"creator\");\n    // Validate the onft_id\n    assert_eq!(channels[0].onft_id, onft_id);\n}\n\n#[test]\nfn create_reserved_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n    // Username \"admin\" is reserved for the actor admin\n    instantiate_msg.reserved_usernames = vec![\n        ReservedUsername {\n            username: \"admin\".to_string(),\n            address: Some(admin.clone()),\n        },\n        ReservedUsername {\n            username: \"reserved\".to_string(),\n            address: None,\n        },\n    ];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"admin\", creator.clone()).build();\n\n    // Creator can not use the reserved username \"admin\"\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::UserNameReserved {});\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"reserved\", creator.clone()).build();\n    // No one can use the reserved username \"reserved\"\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    // Admin can use the reserved username \"admin\"\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"admin\", admin.clone()).build();\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    // Whenever a reserved username is used, remove it from the reserved list\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 1);\n    assert_eq!(res[0].username, \"reserved\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","delete.rs"],"content":"use crate::helpers::msg_wrapper::CreateChannelMsgBuilder;\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::{\n    channel::ChannelDetails,\n    msg::{ExecuteMsg, QueryMsg},\n};\n\n#[test]\nfn delete_channel_happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026crate::helpers::msg_wrapper::get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel first\n    let username = \"creator\";\n    let channel_create_msg = CreateChannelMsgBuilder::new(username, creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Extract channel_id from the response\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Verify channel exists\n    let channel_details_query: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel_details_query.user_name, username);\n\n    // Delete the channel\n    let delete_msg = ExecuteMsg::ChannelDelete {\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify correct event attributes\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"action\"),\n        \"delete_channel\"\n    );\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"channel_id\"),\n        channel_id\n    );\n\n    // Verify that the channel no longer exists\n    let query_result = app.wrap().query_wasm_smart::\u003cChannelDetails\u003e(\n        channel_contract_addr.clone(),\n        \u0026QueryMsg::ChannelDetails {\n            channel_id: channel_id.clone(),\n        },\n    );\n\n    // Query should fail with channel not found error\n    assert!(query_result.is_err());\n}\n\n#[test]\nfn delete_channel_not_creator() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let creator2 = setup_response.test_accounts.creator2.clone();\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026crate::helpers::msg_wrapper::get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel first\n    let username = \"creator\";\n    let channel_create_msg = CreateChannelMsgBuilder::new(username, creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Extract channel_id from the response\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Try to delete channel with non creator\n    let delete_msg = ExecuteMsg::ChannelDelete {\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    // Verify error is about permissions\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n\n    // Verify channel still exists\n    let channel_details_query: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel_details_query.user_name, username);\n}\n\n#[test]\nfn delete_channel_when_paused() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026crate::helpers::msg_wrapper::get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel first\n    let username = \"creator\";\n    let channel_create_msg = CreateChannelMsgBuilder::new(username, creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Extract channel_id from the response\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Pause the contract\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::Pause {},\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to delete the channel when contract is paused\n    let delete_msg = ExecuteMsg::ChannelDelete {\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    // Verify error is about contract being paused\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Pause(pauser::PauseError::Paused {})\n    );\n}\n\n#[test]\nfn delete_nonexistent_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026crate::helpers::msg_wrapper::get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Try to delete a channel that doesn't exist\n    let nonexistent_channel_id = \"nonexistent_channel_id\";\n    let delete_msg = ExecuteMsg::ChannelDelete {\n        channel_id: nonexistent_channel_id.to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    // Verify error is about channel not found\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(channel_manager::error::ChannelError::ChannelIdNotFound {})\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","follow.rs"],"content":"use crate::helpers::msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\nuse channel_manager::error::ChannelError;\nuse cosmwasm_std::{coin, Addr};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\n#[test]\nfn follow_non_existent_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let follower = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let res = app.execute_contract(\n        follower.clone(),\n        channel_contract_addr.clone(),\n        \u0026ExecuteMsg::ChannelFollow {\n            channel_id: \"non_existent_channel\".to_string(),\n        },\n        \u0026[],\n    );\n\n    assert!(res.is_err());\n}\n#[test]\nfn already_following() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let follower = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Follow the channel\n    let _res = app\n        .execute_contract(\n            follower.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelFollow {\n                channel_id: channel_id.clone(),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to follow again\n    let res = app\n        .execute_contract(\n            follower.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelFollow {\n                channel_id: channel_id.clone(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::AlreadyFollowing {})\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let follower = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Follow the channel\n    let _res = app\n        .execute_contract(\n            follower.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelFollow {\n                channel_id: channel_id.clone(),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query followers count\n    let followers_count: u64 = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::FollowersCount {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n\n    assert_eq!(followers_count, 1);\n\n    // Query followers\n    let followers: Vec\u003cAddr\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::Followers {\n                channel_id: channel_id.clone(),\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(followers.len(), 1);\n    assert_eq!(followers[0], follower);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","manage_reserved_usernames.rs"],"content":"use cosmwasm_std::{coin, Addr};\nuse cw_multi_test::Executor;\nuse omniflix_channel::string_validation::StringValidationError;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg, ReservedUsername};\n\nuse crate::helpers::msg_wrapper::get_channel_instantiate_msg;\nuse crate::helpers::setup::setup;\n\n#[test]\nfn add_reserved_usernames() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    // Query reserved_usernames\n    // Default reserved usernames has 1 entry\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 1);\n\n    // Add a reserved username but dont set an address\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"admin\".to_string(),\n            address: None,\n        }]),\n        remove_usernames: None,\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 2);\n\n    // Add invalid reserved username\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"Admin\".to_string(),\n            address: None,\n        }]),\n        remove_usernames: None,\n    };\n\n    let res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::StringValidationError(StringValidationError::UppercaseNotAllowed {\n            sent: \"Admin\".to_string()\n        })\n    );\n    // Add valid reserved username with invalid address\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"Admin\".to_string(),\n            address: Some(Addr::unchecked(\"\")),\n        }]),\n        remove_usernames: None,\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n    // Username admin is already added but we want to sent an valid address\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"admin\".to_string(),\n            address: Some(creator.clone()),\n        }]),\n        remove_usernames: None,\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(res.len(), 2);\n    assert_eq!(res[0].address, Some(creator.clone()));\n\n    // Remove designated address from reserved username\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"admin\".to_string(),\n            address: None,\n        }]),\n        remove_usernames: None,\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 2);\n    assert_eq!(res[0].address, None);\n}\n\n#[test]\nfn remove_reserved_usernames() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let _creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    // Query reserved_usernames\n    // Default reserved usernames has 1 entry\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 1);\n\n    // Remove a reserved username that does not exist\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: None,\n        remove_usernames: vec![\"admin\".to_string()].into(),\n    };\n\n    let res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(channel_manager::error::ChannelError::UsernameNotReserved {})\n    );\n\n    // Remove a reserved username\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: None,\n        remove_usernames: vec![\"reserved\".to_string()].into(),\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 0);\n\n    // Remove usernames while adding\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"admin\".to_string(),\n            address: None,\n        }]),\n        remove_usernames: vec![\"admin\".to_string()].into(),\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","mod.rs"],"content":"pub mod collaborators;\npub mod create;\npub mod manage_reserved_usernames;\npub mod tipping;\npub mod update_channel_details;\n\npub mod follow;\n\npub mod delete;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","tipping.rs"],"content":"use crate::helpers::msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\nuse cosmwasm_std::{coin, Addr, Decimal, Uint128};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::msg::ExecuteMsg;\n\n#[test]\nfn invalid_payment_address() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg =\n        CreateChannelMsgBuilder::new(\"creator\", Addr::unchecked(\"invalid\")).build();\n\n    // Create a channel with an invalid payment address\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n}\n\n#[test]\nfn invalid_tipping_denom() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Channel contracts tipping denom is uflix\n    // Try to tip with a different denom\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(100000, \"different_denom\"),\n                asset_id: None,\n            },\n            \u0026[coin(1000000, \"different_denom\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::InvalidTipDenom {});\n}\n\n#[test]\nfn invalid_tip_amount() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Amount in the message is different from the amount in the coins\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(1000, \"uflix\"),\n                asset_id: None,\n            },\n            \u0026[coin(100, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::InvalidTipAmount {});\n    // Denom in the message is different from the denom in the coins\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(1000, \"uflix\"),\n                asset_id: None,\n            },\n            \u0026[coin(1000, \"different_denom\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Payment(cw_utils::PaymentError::MissingDenom(\"uflix\".to_string()))\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Tip the creator\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(100000, \"uflix\"),\n                asset_id: None,\n            },\n            \u0026[coin(100000, \"uflix\")],\n        )\n        .unwrap();\n\n    // Validate the tip was sent to the creator\n    let amount = get_event_attribute(res.clone(), \"transfer\", \"amount\");\n    assert_eq!(amount, \"100000uflix\");\n    let recipient = get_event_attribute(res, \"transfer\", \"recipient\");\n    assert_eq!(recipient, creator.to_string());\n\n    // Add collaborator\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collector.clone().into_string(),\n        collaborator_details: omniflix_channel_types::channel::ChannelCollaborator {\n            role: omniflix_channel_types::channel::Role::Moderator,\n            share: Decimal::from_ratio(Uint128::one(), Uint128::from(3u128)),\n        },\n    };\n\n    let _res = app\n        .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Execute a tip\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(100000, \"uflix\"),\n                asset_id: None,\n            },\n            \u0026[coin(100000, \"uflix\")],\n        )\n        .unwrap();\n\n    // Validate the tip was sent to the creator\n    let amount = get_event_attribute(res.clone(), \"wasm\", \u0026creator.into_string());\n    assert_eq!(amount, \"66667uflix\");\n\n    let amount = get_event_attribute(res.clone(), \"wasm\", \u0026collector.into_string());\n    assert_eq!(amount, \"33333uflix\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","update_channel_details.rs"],"content":"use crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::get_event_attribute,\n};\nuse channel_manager::error::ChannelError;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::channel::ChannelDetails;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\n#[test]\nfn missing_channel_id() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Missing channel_id\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: \"\".to_string(),\n                description: Some(\"creator\".to_string()),\n                banner_picture: None,\n                profile_picture: None,\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(channel_manager::error::ChannelError::ChannelIdNotFound {})\n    );\n}\n#[test]\nfn invalid_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Channel not found\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: \"1\".to_string(),\n                description: Some(\"creator\".to_string()),\n                banner_picture: None,\n                profile_picture: None,\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::ChannelIdNotFound {})\n    );\n}\n\n#[test]\nfn unauthorized() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Query Channel Details\n    let channel: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel.channel_id, channel_id);\n\n    // Unauthorized\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: Some(\"creator\".to_string()),\n                banner_picture: None,\n                profile_picture: None,\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Query Channel\n    let channel: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel.channel_id, channel_id);\n\n    // Happy path\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: Some(\"new description\".to_string()),\n                banner_picture: None,\n                profile_picture: None,\n                channel_name: None,\n                payment_address: Some(creator.clone().to_string()),\n            },\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    // Query Channel Details\n    let channel: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel.payment_address, creator.clone());\n}\n\n#[test]\nfn invalid() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Query Channel Details\n    let channel: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel.channel_id, channel_id);\n\n    // Invalid banner link\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: None,\n                banner_picture: Some(\"i\".repeat(1001)),\n                profile_picture: None,\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    // Invalid profile link\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: None,\n                banner_picture: None,\n                profile_picture: Some(\"i\".repeat(1001)),\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    // Invalid channel name\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: None,\n                banner_picture: None,\n                profile_picture: None,\n                // No special characters\n                channel_name: Some(\"creator_1\".to_string()),\n                payment_address: None,\n            },\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","instantiate.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::{\n    config::ChannelConractConfig,\n    msg::{ExecuteMsg, QueryMsg},\n};\n\nuse crate::helpers::{msg_wrapper::get_channel_instantiate_msg, setup::setup};\n\n#[test]\nfn instantiate_channel_contract() {\n    // Setup     testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    // Missed Onft collection creation fee. This variable is set to 1000000 uflix\n    let res = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::PaymentError {\n            expected: [coin(1000000, \"uflix\")].to_vec(),\n            received: (vec![])\n        }\n    );\n\n    // Send more than the required fee\n    let res = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000001, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::PaymentError {\n            expected: [coin(1000000, \"uflix\")].to_vec(),\n            received: [coin(1000001, \"uflix\")].to_vec()\n        }\n    );\n\n    // Happy path\n    let res = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Check the contract config\n    let config: ChannelConractConfig = app\n        .wrap()\n        .query_wasm_smart(res, \u0026QueryMsg::Config {})\n        .unwrap();\n    assert_eq!(config.auth_details.protocol_admin, admin);\n    assert_eq!(config.channels_collection_id, \"Channels\");\n    assert_eq!(config.channel_creation_fee, vec![]);\n}\n\n#[test]\nfn set_config() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Unauthorized attempt to set the config\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                protocol_admin: Some(creator.to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n\n    // Happy path\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                protocol_admin: Some(creator.to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check the contract config\n    let config: ChannelConractConfig = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr, \u0026QueryMsg::Config {})\n        .unwrap();\n    assert_eq!(config.auth_details.protocol_admin, creator);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","mod.rs"],"content":"#[cfg(test)]\npub mod instantiate;\n\n#[cfg(test)]\npub mod channels;\n\n#[cfg(test)]\npub mod assets;\n\n#[cfg(test)]\npub mod playlist;\n\n#[cfg(test)]\npub mod admin;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","add_asset.rs"],"content":"use cosmwasm_std::{coin, BlockInfo, Timestamp};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::{AssetSource, Playlist};\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{\n    get_channel_instantiate_msg, AssetPublishMsgBuilder, CreateChannelMsgBuilder,\n};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::{create_denom_msg, get_event_attribute, mint_onft_msg};\n\n#[test]\nfn asset_not_visible() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let _collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: asset_id.clone(),\n        asset_channel_id: asset_collection_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let error = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        error,\n        \u0026ContractError::Asset(asset_manager::error::AssetError::AssetNotFound {})\n    );\n}\n#[test]\nfn asset_from_diffirent_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let creator2 = setup_response.test_accounts.creator2.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Creator 1 creates a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creatorone\", creator.clone())\n        .description(\"Creator 1 Description\".to_string())\n        .channel_name(\"Creator1\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let creator1_channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Creator 2 creates a channel\n    app.set_block(BlockInfo {\n        chain_id: \"test_1\".to_string(),\n        height: 5_000_000,\n        time: Timestamp::from_nanos(5_000_000),\n    });\n\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creatortwo\", creator2.clone())\n        .description(\"Creator 2 Description\".to_string())\n        .channel_name(\"Creator2\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let creator2_channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        \"id\".to_string(),\n        \"asset_id\".to_string(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(creator1_channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Create a playlist under creator 2's channel\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"Creator2 Playlist\".to_string(),\n        channel_id: creator2_channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: creator1_channel_id.clone(),\n        channel_id: creator2_channel_id.clone(),\n        playlist_name: \"Creator2 Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: creator2_channel_id.clone(),\n        playlist_name: \"Creator2 Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 1);\n    assert_eq!(playlist.assets[0].1, publish_id);\n}\n\n#[test]\nfn asset_already_exists_in_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to add the same asset again\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    // Verify error is about asset already in playlist\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(\n            asset_manager::error::PlaylistError::AssetAlreadyExistsInPlaylist {}\n        )\n    );\n}\n\n#[test]\nfn playlist_asset_limit_reached() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Create and publish 101 assets (1 more than the limit)\n    // The constant PLAYLISTS_ASSET_LIMIT is typically set to 100\n    for i in 0..101 {\n        let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n        // Increase block time by 1 ns every iteration\n        app.update_block(|block| {\n            block.time = block.time.plus_nanos(1);\n        });\n\n        let res = app\n            .execute_contract(\n                creator.clone(),\n                channel_contract_addr.clone(),\n                \u0026publish_msg,\n                \u0026[],\n            )\n            .unwrap();\n\n        let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n        // Add assets to the playlist (first 100 should succeed)\n        let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n            publish_id: publish_id.clone(),\n            asset_channel_id: channel_id.clone(),\n            channel_id: channel_id.clone(),\n            playlist_name: \"My Playlist\".to_string(),\n        };\n\n        // The first 100 adds should succeed, the 101st should fail\n        if i \u003c 100 {\n            let _res = app\n                .execute_contract(\n                    creator.clone(),\n                    channel_contract_addr.clone(),\n                    \u0026add_asset_msg,\n                    \u0026[],\n                )\n                .unwrap();\n        } else {\n            // The 101st add should fail with PlaylistAssetLimitReached\n            let res = app\n                .execute_contract(\n                    creator.clone(),\n                    channel_contract_addr.clone(),\n                    \u0026add_asset_msg,\n                    \u0026[],\n                )\n                .unwrap_err();\n\n            // Verify error is about playlist asset limit reached\n            let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n            assert_eq!(\n                typed_err,\n                \u0026ContractError::Playlist(\n                    asset_manager::error::PlaylistError::PlaylistAssetLimitReached {}\n                )\n            );\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","create.rs"],"content":"use asset_manager::error::PlaylistError;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::Playlist;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\n\n// Create a playlist that already exists\n#[test]\nfn already_exists() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify that the playlist exists under the channel\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Videos\");\n\n    // Create a playlist that already exists\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistAlreadyExists {})\n    );\n}\n\n// Create a playlist without owning the channel\n#[test]\nfn not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist without owning the channel\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            // Collector does not own the channel\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify that the playlist exists under the channel\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Videos\");\n}\n\n#[test]\nfn try_creating_same_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify that the playlist exists under the channel\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Videos\");\n\n    // Creator tries to create a playlist named \"My Videos\"\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistAlreadyExists {})\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","delete.rs"],"content":"use crate::helpers::msg_wrapper::{\n    get_channel_instantiate_msg, AssetPublishMsgBuilder, CreateChannelMsgBuilder,\n};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::{create_denom_msg, get_event_attribute, mint_onft_msg};\nuse asset_manager::error::PlaylistError;\nuse cosmwasm_std::{coin, CosmosMsg};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::{AssetSource, Playlist};\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\n#[test]\nfn does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Remove a playlist that does not exist\n    let delete_playlist_msg = ExecuteMsg::PlaylistDelete {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistNotFound {})\n    );\n}\n\n// Delete a playlist without owning the channel\n#[test]\nfn not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Remove a playlist without owning the channel\n    let delete_playlist_msg = ExecuteMsg::PlaylistDelete {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n// Happy path\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        \"id\".to_string(),\n        \"asset_id\".to_string(),\n        creator.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(creator.clone(), cosmos_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Playlist Add Asset\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Validate the asset was added to the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 1);\n    assert_eq!(playlist.assets[0].1, publish_id.clone());\n\n    // Delete the playlist\n    let delete_playlist_msg = ExecuteMsg::PlaylistDelete {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Validate the playlist was removed\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","mod.rs"],"content":"pub mod create;\n\npub mod delete;\n\npub mod remove_asset_from_playlist;\n\npub mod add_asset;\n\npub mod refresh_playlist;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","refresh_playlist.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::Playlist;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{\n    get_channel_instantiate_msg, AssetPublishMsgBuilder, CreateChannelMsgBuilder,\n};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\n\n#[test]\nfn empty_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let _collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 0);\n\n    // Refresh the playlist\n    let refresh_playlist_msg = ExecuteMsg::PlaylistRefresh {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026refresh_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 0);\n}\n\n#[test]\nfn playlist_with_assets() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let _collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish the assets\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    app.update_block(|block| {\n        block.time = block.time.plus_nanos(1);\n    });\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id2 = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id2.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 2);\n    assert_eq!(playlist.assets[0], (channel_id.clone(), publish_id.clone()));\n    assert_eq!(\n        playlist.assets[1],\n        (channel_id.clone(), publish_id2.clone())\n    );\n\n    // Refresh the playlist\n    let refresh_playlist_msg = ExecuteMsg::PlaylistRefresh {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026refresh_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Playlist should have the same assets\n    assert_eq!(playlist.assets.len(), 2);\n    assert_eq!(playlist.assets[0], (channel_id.clone(), publish_id.clone()));\n    assert_eq!(\n        playlist.assets[1],\n        (channel_id.clone(), publish_id2.clone())\n    );\n}\n\n#[test]\nfn playlist_with_assets_and_removed_assets() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let _collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish the assets\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg.clone(),\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    app.update_block(|block| {\n        block.time = block.time.plus_nanos(1);\n    });\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id2 = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id2.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 2);\n\n    // Unpublish the first asset\n    let unpublish_msg = ExecuteMsg::AssetUnpublish {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026unpublish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Refresh the playlist\n    let refresh_playlist_msg = ExecuteMsg::PlaylistRefresh {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026refresh_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Playlist should have the second asset only\n    assert_eq!(playlist.assets.len(), 1);\n    assert_eq!(\n        playlist.assets[0],\n        (channel_id.clone(), publish_id2.clone())\n    );\n}\n\n#[test]\nfn not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let creator2 = setup_response.test_accounts.creator2.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try refreshing the playlist with a different user\n    let refresh_playlist_msg = ExecuteMsg::PlaylistRefresh {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026refresh_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let error = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(error, \u0026ContractError::Unauthorized {});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","remove_asset_from_playlist.rs"],"content":"use asset_manager::error::PlaylistError;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::{AssetSource, Playlist};\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{\n    get_channel_instantiate_msg, AssetPublishMsgBuilder, CreateChannelMsgBuilder,\n};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::{create_denom_msg, get_event_attribute, mint_onft_msg};\n\n#[test]\nfn asset_not_in_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Validate the creator have added a playlist\n\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Playlist\");\n\n    // Remove an unexisting asset from a playlist\n    let remove_asset_msg = ExecuteMsg::PlaylistRemoveAsset {\n        publish_id: \"publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::AssetNotInPlaylist {})\n    );\n}\n\n#[test]\nfn playlist_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Remove an asset from a playlist that does not exist\n    let remove_asset_msg = ExecuteMsg::PlaylistRemoveAsset {\n        publish_id: \"publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistNotFound {})\n    );\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Validate the creator have added a playlist\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Playlist\");\n    assert_eq!(playlists[0].assets.len(), 0);\n\n    // Playlist does not have any assets\n    // Remove an asset from a playlist\n\n    let remove_asset_msg = ExecuteMsg::PlaylistRemoveAsset {\n        publish_id: \"publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::AssetNotInPlaylist {})\n    );\n}\n\n#[test]\nfn not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Validate the creator have added a playlist\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Playlist\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        \"id\".to_string(),\n        \"asset_id\".to_string(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Add an asset to a playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Validate the asset was added to the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 1);\n\n    // Remove an asset from a playlist\n    let remove_asset_msg = ExecuteMsg::PlaylistRemoveAsset {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","access_control.rs"],"content":"use crate::ContractError;\nuse channel_manager::channel::ChannelsManager;\nuse cosmwasm_std::{Addr, Deps};\nuse omniflix_channel_types::channel::{ChannelId, Role};\nuse omniflix_std::types::omniflix::onft::v1beta1::{Onft, OnftQuerier};\n\n/// Validates if the sender has the required permissions to perform an action on a channel\n///\n/// # Arguments\n/// * `deps` - Dependencies for accessing storage and querier\n/// * `channel_id` - Identifier of the channel\n/// * `sender` - Address of the account attempting the action\n/// * `channels_collection_id` - Collection ID containing the channel NFTs\n/// * `required_role` - Minimum role required to perform the action\n///\n/// # Returns\n/// * `Ok(())` if the sender either:\n///   - Owns the channel NFT (has admin privileges)\n///   - Is a collaborator with sufficient role permissions\n/// * `Err(ContractError::Unauthorized)` if the sender lacks required permissions\npub fn validate_permissions(\n    deps: Deps,\n    channel_id: ChannelId,\n    sender: Addr,\n    channels_collection_id: String,\n    required_role: Role,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let channel_details = channels.get_channel_details(deps.storage, channel_id.clone())?;\n    let channel_onft_id = channel_details.onft_id;\n\n    // First check if they own the channel NFT\n    if let Ok(_channel_onft) = get_onft_with_owner(\n        deps,\n        channels_collection_id,\n        channel_onft_id,\n        sender.to_string(),\n    ) {\n        // Channel owner (NFT holder) has admin privileges\n        return Ok(());\n    }\n\n    // If not the owner, check if user is a collaborator with sufficient privileges\n    if let Ok(collaborator) = channels.get_collaborator(deps.storage, channel_id, sender) {\n        if has_sufficient_privileges(collaborator.role, required_role) {\n            return Ok(());\n        }\n    }\n\n    // If neither owner nor collaborator with sufficient privileges, return error\n    Err(ContractError::Unauthorized {})\n}\n\n// Helper function to check role hierarchy\nfn has_sufficient_privileges(actual_role: Role, required_role: Role) -\u003e bool {\n    match (actual_role, required_role) {\n        // Admin can do everything\n        (Role::Admin, _) =\u003e true,\n\n        // Moderator can do moderator and publisher tasks\n        (Role::Moderator, Role::Moderator | Role::Publisher) =\u003e true,\n\n        // Publisher can only do publisher tasks\n        (Role::Publisher, Role::Publisher) =\u003e true,\n\n        // All other combinations are insufficient privileges\n        _ =\u003e false,\n    }\n}\n\npub fn get_onft_with_owner(\n    deps: Deps,\n    collection_id: String,\n    onft_id: String,\n    owner: String,\n) -\u003e Result\u003cOnft, ContractError\u003e {\n    let onft_querier = OnftQuerier::new(\u0026deps.querier);\n    let onft_response = onft_querier\n        .onft(collection_id.clone(), onft_id.clone())\n        .map_err(|_| ContractError::OnftNotFound {\n            collection_id: collection_id.clone(),\n            onft_id: onft_id.clone(),\n        })?;\n\n    let onft = onft_response\n        .onft\n        .ok_or_else(|| ContractError::OnftNotFound {\n            collection_id: collection_id.clone(),\n            onft_id: onft_id.clone(),\n        })?;\n\n    if onft.owner != owner {\n        return Err(ContractError::OnftNotOwned {\n            collection_id,\n            onft_id,\n        });\n    }\n\n    Ok(onft)\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":302}},{"line":28,"address":[],"length":0,"stats":{"Line":302}},{"line":29,"address":[],"length":0,"stats":{"Line":604}},{"line":40,"address":[],"length":0,"stats":{"Line":288}},{"line":44,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":10}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":312}},{"line":77,"address":[],"length":0,"stats":{"Line":312}},{"line":78,"address":[],"length":0,"stats":{"Line":624}},{"line":79,"address":[],"length":0,"stats":{"Line":312}},{"line":80,"address":[],"length":0,"stats":{"Line":312}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":311}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":93,"address":[],"length":0,"stats":{"Line":12}},{"line":94,"address":[],"length":0,"stats":{"Line":12}},{"line":95,"address":[],"length":0,"stats":{"Line":12}},{"line":99,"address":[],"length":0,"stats":{"Line":299}}],"covered":23,"coverable":28},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","bank_helpers.rs"],"content":"use cosmwasm_std::{Addr, Attribute, Coin, CosmosMsg, Decimal, Uint128};\nuse cw_utils::NativeBalance;\n\nuse crate::ContractError;\n\n/// Validates that the received payment matches the expected amount\npub fn check_payment(expected: Vec\u003cCoin\u003e, received: Vec\u003cCoin\u003e) -\u003e Result\u003c(), ContractError\u003e {\n    let mut expected_balance = NativeBalance::default();\n    for coin in expected.clone() {\n        expected_balance += coin;\n    }\n\n    let mut received_balance = NativeBalance::default();\n    for coin in received.clone() {\n        received_balance += coin;\n    }\n\n    expected_balance.normalize();\n    received_balance.normalize();\n\n    if expected_balance != received_balance {\n        return Err(ContractError::PaymentError { expected, received });\n    }\n\n    Ok(())\n}\n\n/// Creates a bank message for sending coins to a recipient, handling zero amounts gracefully\n///\n/// This helper function wraps the creation of a bank send message with validation:\n/// - If the input amount contains zero coins, returns an empty vector to avoid transaction failures\n/// - If the amount is non-zero, returns a vector containing the bank send message\n///\n/// # Arguments\n/// * `recipient` - The address that will receive the coins\n/// * `amount` - Vector of coins to send\n///\n/// # Returns\n/// * `Vec\u003cCosmosMsg\u003e` - Empty vector if amount is zero, otherwise vector containing the bank message\npub fn bank_msg_wrapper(recipient: Addr, amount: Vec\u003cCoin\u003e) -\u003e Vec\u003cCosmosMsg\u003e {\n    let mut final_amount = NativeBalance::default();\n    for coin in amount.clone() {\n        final_amount += coin;\n    }\n    // Remove any zero coins\n    final_amount.normalize();\n    // If the final amount is empty, return an empty vec\n    if final_amount.is_empty() {\n        return vec![];\n    }\n    let bank_msg: CosmosMsg = CosmosMsg::Bank(cosmwasm_std::BankMsg::Send {\n        to_address: recipient.into_string(),\n        amount: final_amount.0,\n    });\n    vec![bank_msg]\n}\n\n/// Distributes funds among collaborators according to their shares\n/// and sends any remaining amount to the channel payment address\npub fn distribute_funds_with_shares(\n    collaborators: Vec\u003c(Addr, Decimal)\u003e,\n    amount: Coin,\n    channel_payment_address: Addr,\n) -\u003e Result\u003c(Vec\u003cCosmosMsg\u003e, Vec\u003cAttribute\u003e), ContractError\u003e {\n    let mut bank_msgs: Vec\u003cCosmosMsg\u003e = vec![];\n    let mut remaining_amount = amount.clone().amount;\n    let mut attributes: Vec\u003cAttribute\u003e = vec![];\n\n    for (collaborator, share) in collaborators.clone() {\n        // Create a decimal from the share\n        let share_amount = Decimal::from_ratio(remaining_amount, Uint128::one()) * share;\n        let uint_share_amount = share_amount.to_uint_floor();\n        let share_amount_coin = Coin {\n            denom: amount.denom.clone(),\n            amount: uint_share_amount,\n        };\n        bank_msgs.extend(bank_msg_wrapper(\n            collaborator.clone(),\n            vec![share_amount_coin.clone()],\n        ));\n        remaining_amount -= uint_share_amount;\n        attributes.push(Attribute::new(\n            collaborator.to_string(),\n            share_amount_coin.to_string(),\n        ));\n    }\n\n    if !remaining_amount.is_zero() {\n        let remaining_amount_coin = Coin {\n            denom: amount.denom.clone(),\n            amount: remaining_amount,\n        };\n        bank_msgs.extend(bank_msg_wrapper(\n            channel_payment_address.clone(),\n            vec![remaining_amount_coin.clone()],\n        ));\n        attributes.push(Attribute::new(\n            channel_payment_address.to_string(),\n            remaining_amount_coin.to_string(),\n        ));\n    }\n\n    Ok((bank_msgs, attributes))\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":135}},{"line":8,"address":[],"length":0,"stats":{"Line":135}},{"line":9,"address":[],"length":0,"stats":{"Line":311}},{"line":10,"address":[],"length":0,"stats":{"Line":88}},{"line":13,"address":[],"length":0,"stats":{"Line":135}},{"line":14,"address":[],"length":0,"stats":{"Line":307}},{"line":15,"address":[],"length":0,"stats":{"Line":86}},{"line":18,"address":[],"length":0,"stats":{"Line":135}},{"line":19,"address":[],"length":0,"stats":{"Line":135}},{"line":21,"address":[],"length":0,"stats":{"Line":135}},{"line":22,"address":[],"length":0,"stats":{"Line":3}},{"line":25,"address":[],"length":0,"stats":{"Line":132}},{"line":40,"address":[],"length":0,"stats":{"Line":59}},{"line":41,"address":[],"length":0,"stats":{"Line":59}},{"line":42,"address":[],"length":0,"stats":{"Line":83}},{"line":43,"address":[],"length":0,"stats":{"Line":12}},{"line":46,"address":[],"length":0,"stats":{"Line":59}},{"line":48,"address":[],"length":0,"stats":{"Line":59}},{"line":49,"address":[],"length":0,"stats":{"Line":47}},{"line":51,"address":[],"length":0,"stats":{"Line":12}},{"line":52,"address":[],"length":0,"stats":{"Line":12}},{"line":53,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":2}},{"line":65,"address":[],"length":0,"stats":{"Line":2}},{"line":66,"address":[],"length":0,"stats":{"Line":2}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":4}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":77,"address":[],"length":0,"stats":{"Line":1}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":79,"address":[],"length":0,"stats":{"Line":1}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":94,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":98,"address":[],"length":0,"stats":{"Line":2}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":103,"address":[],"length":0,"stats":{"Line":2}}],"covered":47,"coverable":47},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","bin","schema.rs"],"content":"use cosmwasm_schema::write_api;\nuse omniflix_channel_types::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};\n\nfn main() {\n    write_api! {\n        instantiate: InstantiateMsg,\n        execute: ExecuteMsg,\n        query: QueryMsg,\n    }\n}\n","traces":[{"line":4,"address":[],"length":0,"stats":{"Line":0}},{"line":5,"address":[],"length":0,"stats":{"Line":0}},{"line":6,"address":[],"length":0,"stats":{"Line":0}},{"line":7,"address":[],"length":0,"stats":{"Line":0}},{"line":8,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":5},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","contract.rs"],"content":"use crate::access_control::validate_permissions;\nuse crate::bank_helpers::{bank_msg_wrapper, check_payment, distribute_funds_with_shares};\nuse crate::error::ContractError;\nuse crate::helpers::{\n    filter_assets_to_remove, generate_create_denom_msg, generate_mint_onft_msg,\n    get_collection_creation_fee, validate_asset_metadata, validate_asset_source,\n    validate_channel_collection_details, validate_channel_details, validate_channel_metadata,\n    validate_channel_token_details, validate_reserved_usernames,\n};\nuse crate::random::generate_random_id_with_prefix;\nuse crate::state::{CHANNEL_TOKEN_DETAILS, CONFIG};\nuse crate::string_validation::{validate_string, StringValidationType};\nuse asset_manager::assets::AssetsManager;\nuse asset_manager::playlists::PlaylistsManager;\nuse channel_manager::channel::ChannelsManager;\nuse cosmwasm_std::entry_point;\nuse cosmwasm_std::{\n    to_json_binary, Addr, Binary, Coin, CosmosMsg, Deps, DepsMut, Env, MessageInfo, Response,\n    StdResult,\n};\nuse cw_utils::must_pay;\nuse omniflix_channel_types::asset::{Asset, AssetKey, AssetMetadata, AssetSource, Flag, Playlist};\nuse omniflix_channel_types::channel::{\n    ChannelCollaborator, ChannelDetails, ChannelMetadata, ChannelOnftData, Role,\n};\nuse omniflix_channel_types::config::{AuthDetails, ChannelConractConfig};\nuse omniflix_channel_types::msg::{\n    AssetResponse, ChannelResponse, CollaboratorInfo, ExecuteMsg, InstantiateMsg, QueryMsg,\n    ReservedUsername,\n};\nuse pauser::PauseState;\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn instantiate(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: InstantiateMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    // Validate the admin address provided in the instantiation message\n    let protocol_admin = deps\n        .api\n        .addr_validate(\u0026msg.clone().protocol_admin.into_string())?;\n    //Initialize the pause state and set the initial pausers\n    let pause_state = PauseState::new()?;\n    pause_state.set_pausers(\n        deps.storage,\n        info.sender.clone(),\n        vec![protocol_admin.clone()],\n    )?;\n\n    // Validate the fee collector address, or default to the admin address if validation fails\n    let fee_collector = deps\n        .api\n        .addr_validate(\u0026msg.fee_collector.clone().into_string())?;\n\n    // Validate the channel token details\n    validate_channel_token_details(msg.channel_token_details.clone())?;\n\n    // Save the channel token details\n    CHANNEL_TOKEN_DETAILS.save(deps.storage, \u0026msg.channel_token_details)?;\n\n    // Validate the channel collection details\n    validate_channel_collection_details(msg.channels_collection_details.clone())?;\n\n    // Save channel CONFIG\n    let channel_contract_config = ChannelConractConfig {\n        auth_details: AuthDetails {\n            protocol_admin: protocol_admin.clone(),\n            fee_collector: fee_collector.clone(),\n        },\n        accepted_tip_denoms: msg.accepted_tip_denoms.clone(),\n        channels_collection_id: msg.channels_collection_details.collection_id.clone(),\n        channel_creation_fee: msg.channel_creation_fee.clone(),\n    };\n    // Save the channel CONFIG to the contract state\n    CONFIG.save(deps.storage, \u0026channel_contract_config)?;\n\n    // Query the collection creation fee from onft module\n    let collection_creation_fee = get_collection_creation_fee(deps.as_ref())?;\n\n    // Check if the payment provided in the message matches the required creation fee\n    check_payment(\n        [collection_creation_fee.clone()].to_vec(),\n        info.funds.clone(),\n    )?;\n\n    let channels_manager = ChannelsManager::new();\n    validate_reserved_usernames(msg.reserved_usernames.clone(), deps.api)?;\n    channels_manager.add_reserved_usernames(deps.storage, msg.reserved_usernames.clone())?;\n\n    // Prepare the message to create a new ONFT denom (collection)\n    let onft_creation_message: CosmosMsg = generate_create_denom_msg(\n        msg.channels_collection_details.clone(),\n        env.contract.address.clone().to_string(),\n        collection_creation_fee,\n    );\n\n    let response = Response::new()\n        .add_message(onft_creation_message)\n        .add_attribute(\"action\", \"instantiate\")\n        .add_attribute(\n            \"channels_collection_id\",\n            msg.channels_collection_details.collection_id.clone(),\n        )\n        .add_attribute(\n            \"channels_collection_name\",\n            msg.channels_collection_details.collection_name.clone(),\n        )\n        .add_attribute(\n            \"channels_collection_symbol\",\n            msg.channels_collection_details.collection_symbol.clone(),\n        );\n\n    Ok(response)\n}\n\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    match msg {\n        ExecuteMsg::AdminRemoveAssets {\n            asset_keys,\n            refresh_flags,\n        } =\u003e remove_assets(deps, info, asset_keys, refresh_flags),\n        ExecuteMsg::AssetFlag {\n            channel_id,\n            publish_id,\n            flag,\n        } =\u003e flag_asset(deps, info, channel_id, publish_id, flag),\n        ExecuteMsg::Pause {} =\u003e pause(deps, info),\n        ExecuteMsg::Unpause {} =\u003e unpause(deps, info),\n        ExecuteMsg::SetPausers { pausers } =\u003e set_pausers(deps, info, pausers),\n        ExecuteMsg::AssetPublish {\n            asset_source,\n            salt,\n            channel_id,\n            playlist_name,\n            is_visible,\n            metadata,\n        } =\u003e publish(\n            deps,\n            env,\n            info,\n            asset_source,\n            salt,\n            channel_id,\n            playlist_name,\n            is_visible,\n            metadata,\n        ),\n        ExecuteMsg::AssetUnpublish {\n            publish_id,\n            channel_id,\n        } =\u003e unpublish(deps, info, publish_id, channel_id),\n        ExecuteMsg::PlaylistRefresh {\n            channel_id,\n            playlist_name,\n        } =\u003e refresh_playlist(deps, info, channel_id, playlist_name),\n        ExecuteMsg::PlaylistCreate {\n            playlist_name,\n            channel_id,\n        } =\u003e create_playlist(deps, info, channel_id, playlist_name),\n        ExecuteMsg::ChannelCreate {\n            user_name,\n            channel_name,\n            salt,\n            description,\n            profile_picture,\n            banner_picture,\n            payment_address,\n        } =\u003e create_channel(\n            deps,\n            env,\n            info,\n            salt,\n            description,\n            payment_address,\n            user_name,\n            channel_name,\n            profile_picture,\n            banner_picture,\n        ),\n        ExecuteMsg::ChannelUpdateDetails {\n            channel_id,\n            description,\n            channel_name,\n            profile_picture,\n            banner_picture,\n            payment_address,\n        } =\u003e update_channel_details(\n            deps,\n            info,\n            channel_id,\n            description,\n            channel_name,\n            profile_picture,\n            banner_picture,\n            payment_address,\n        ),\n\n        ExecuteMsg::PlaylistDelete {\n            playlist_name,\n            channel_id,\n        } =\u003e delete_playlist(deps, info, channel_id, playlist_name),\n        ExecuteMsg::PlaylistRemoveAsset {\n            publish_id,\n            channel_id,\n            playlist_name,\n        } =\u003e remove_asset_from_playlist(deps, info, publish_id, channel_id, playlist_name),\n        ExecuteMsg::AdminSetConfig {\n            channel_creation_fee,\n            protocol_admin,\n            fee_collector,\n        } =\u003e set_config(\n            deps,\n            info,\n            channel_creation_fee,\n            protocol_admin,\n            fee_collector,\n        ),\n        ExecuteMsg::PlaylistAddAsset {\n            publish_id,\n            asset_channel_id,\n            channel_id,\n            playlist_name,\n        } =\u003e add_asset_to_playlist(\n            deps,\n            info,\n            asset_channel_id,\n            publish_id,\n            channel_id,\n            playlist_name,\n        ),\n        ExecuteMsg::AssetUpdateDetails {\n            publish_id,\n            channel_id,\n            is_visible,\n            name,\n            description,\n            media_uri,\n        } =\u003e update_asset_details(\n            deps,\n            info,\n            publish_id,\n            channel_id,\n            is_visible,\n            name,\n            description,\n            media_uri,\n        ),\n        ExecuteMsg::ChannelDelete { channel_id } =\u003e delete_channel(deps, info, channel_id),\n        ExecuteMsg::AdminManageReservedUsernames {\n            add_usernames,\n            remove_usernames,\n        } =\u003e manage_reserved_usernames(deps, info, add_usernames, remove_usernames),\n        ExecuteMsg::ChannelTip {\n            channel_id, amount, ..\n        } =\u003e tip_channel(deps, info, channel_id, amount),\n        ExecuteMsg::ChannelAddCollaborator {\n            channel_id,\n            collaborator_address,\n            collaborator_details,\n        } =\u003e add_collaborator(\n            deps,\n            info,\n            channel_id,\n            collaborator_address,\n            collaborator_details,\n        ),\n        ExecuteMsg::ChannelRemoveCollaborator {\n            channel_id,\n            collaborator_address,\n        } =\u003e remove_collaborator(deps, info, channel_id, collaborator_address),\n        ExecuteMsg::ChannelFollow { channel_id } =\u003e follow_channel(deps, info, channel_id),\n        ExecuteMsg::ChannelUnfollow { channel_id } =\u003e unfollow_channel(deps, info, channel_id),\n    }\n}\n\n#[allow(clippy::too_many_arguments)]\nfn create_channel(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    salt: Binary,\n    description: Option\u003cString\u003e,\n    payment_address: Addr,\n    user_name: String,\n    channel_name: String,\n    profile_picture: Option\u003cString\u003e,\n    banner_picture: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    // Check if the payment provided in the message matches the required creation fee\n    check_payment(config.channel_creation_fee.clone(), info.funds.clone())?;\n\n    // Generate a random channel onft ID\n    let onft_id = generate_random_id_with_prefix(\u0026salt, \u0026env, \"onft\");\n\n    // Generate a random channel ID\n    let channel_id = generate_random_id_with_prefix(\u0026salt, \u0026env, \"channel\");\n\n    let channels_manager = ChannelsManager::new();\n\n    let channel_details = ChannelDetails {\n        channel_id: channel_id.clone(),\n        user_name: user_name.clone(),\n        onft_id: onft_id.clone(),\n        payment_address: deps.api.addr_validate(\u0026payment_address.into_string())?,\n    };\n    let channel_metadata = ChannelMetadata {\n        channel_name: channel_name.clone(),\n        description: description.clone(),\n        profile_picture: profile_picture.clone(),\n        banner_picture: banner_picture.clone(),\n    };\n    validate_channel_details(channel_details.clone())?;\n    validate_channel_metadata(channel_metadata.clone())?;\n\n    // Check if the username is reserved\n    match channels_manager.get_reserved_status(deps.storage, user_name.clone())? {\n        None =\u003e {\n            // Username is not reserved, proceed with channel creation\n        }\n        Some(reserved_addr) =\u003e {\n            if reserved_addr != Some(info.sender.clone()) {\n                // Username is reserved but not assigned to anyone\n                return Err(ContractError::UserNameReserved {});\n            }\n            // Username is reserved for a specific address\n            if reserved_addr != Some(info.sender.clone()) {\n                return Err(ContractError::UserNameReserved {});\n            }\n            // Sender matches the reserved address, remove the reservation\n            channels_manager.remove_reserved_usernames(deps.storage, vec![user_name.clone()])?;\n        }\n    }\n    // Add the new channel to the collection\n    // Checks for uniqueness of the channel ID and username\n    channels_manager.add_channel(\n        deps.storage,\n        channel_id.clone(),\n        channel_details.clone(),\n        channel_metadata.clone(),\n    )?;\n\n    // Create the onft data for the channel. This data will be stored in the onft's data field\n    let onft_data = ChannelOnftData {\n        channel_id: channel_id.clone(),\n        user_name: user_name.clone(),\n        onft_id: onft_id.clone(),\n    };\n\n    let string_onft_data =\n        serde_json::to_string(\u0026onft_data).map_err(|_| ContractError::InvalidOnftData {})?;\n\n    // Generate the mint message and its attributes\n    let (mint_onft_msg, nft_attributes) = generate_mint_onft_msg(\n        onft_id.clone(),\n        config.channels_collection_id.clone(),\n        env.contract.address.clone().to_string(),\n        info.sender.clone().to_string(),\n        string_onft_data,\n        user_name.clone(),\n        CHANNEL_TOKEN_DETAILS.load(deps.storage)?,\n    );\n\n    // Pay the channel creation fee to the fee collector\n    let bank_channel_fee_msg = bank_msg_wrapper(\n        config.auth_details.fee_collector,\n        config.channel_creation_fee,\n    );\n\n    let response = Response::new()\n        .add_message(mint_onft_msg)\n        .add_messages(bank_channel_fee_msg)\n        .add_attribute(\"action\", \"register_channel\")\n        .add_attributes(nft_attributes)\n        .add_attribute(\"channel_id\", channel_id.clone());\n\n    Ok(response)\n}\n\nfn follow_channel(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    channels_manager.add_follower(deps.storage, channel_id.clone(), info.sender.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"follow_channel\")\n        .add_attribute(\"channel_id\", channel_id);\n    Ok(response)\n}\n\nfn unfollow_channel(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    channels_manager.remove_follower(deps.storage, channel_id.clone(), info.sender.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"unfollow_channel\")\n        .add_attribute(\"channel_id\", channel_id);\n    Ok(response)\n}\n\nfn delete_channel(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    let channels_manager = ChannelsManager::new();\n    let assets_manager = AssetsManager::new();\n    let playlist_manager = PlaylistsManager::new();\n    // Check if the sender has admin permissions\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Admin,\n    )?;\n\n    channels_manager.delete_channel(deps.storage, channel_id.clone())?;\n    assets_manager.delete_assets_by_channel_id(deps.storage, channel_id.clone())?;\n    playlist_manager.delete_playlists_by_channel_id(deps.storage, channel_id.clone());\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"delete_channel\")\n        .add_attribute(\"channel_id\", channel_id);\n\n    Ok(response)\n}\n\n#[allow(clippy::too_many_arguments)]\nfn publish(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    asset_source: AssetSource,\n    salt: Binary,\n    channel_id: String,\n    playlist_name: Option\u003cString\u003e,\n    is_visible: bool,\n    metadata: AssetMetadata,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let publish_id = generate_random_id_with_prefix(\u0026salt, \u0026env, \"publish\");\n\n    validate_asset_source(deps.as_ref(), asset_source.clone(), info.sender.clone())?;\n\n    validate_asset_metadata(metadata.clone())?;\n\n    // Define the asset to be published\n    let asset = Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n        asset_source: asset_source.clone(),\n        is_visible,\n    };\n\n    // Add asset to the channel's asset list\n    let assets_manager = AssetsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    assets_manager.add_asset(deps.storage, asset_key.clone(), asset.clone(), metadata)?;\n\n    if let Some(playlist_name) = playlist_name.clone() {\n        if is_visible {\n            let playlists_manager = PlaylistsManager::new();\n            playlists_manager.add_asset_to_playlist(\n                deps.storage,\n                channel_id.clone(),\n                playlist_name.clone(),\n                asset_key,\n            )?;\n        }\n    }\n\n    let mut response = Response::new()\n        .add_attribute(\"action\", \"publish\")\n        .add_attribute(\"publish_id\", publish_id)\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"asset_source\", asset_source.to_string());\n\n    if let Some(playlist_name) = playlist_name {\n        response = response.add_attribute(\"playlist_name\", playlist_name);\n    }\n    Ok(response)\n}\n\nfn unpublish(\n    deps: DepsMut,\n    info: MessageInfo,\n    publish_id: String,\n    channel_id: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let assets_manager = AssetsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    assets_manager.delete_assets(deps.storage, vec![asset_key.clone()])?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"unpublish\")\n        .add_attribute(\"publish_id\", publish_id)\n        .add_attribute(\"channel_id\", channel_id);\n\n    Ok(response)\n}\n\nfn refresh_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlists_manager = PlaylistsManager::new();\n    let playlist_asset_keys = playlists_manager\n        .get_playlist(deps.storage, channel_id.clone(), playlist_name.clone())?\n        .assets;\n    let asset_keys_to_remove = filter_assets_to_remove(deps.storage, playlist_asset_keys.clone());\n\n    playlists_manager.remove_assets_from_playlist(\n        deps.storage,\n        channel_id.clone(),\n        playlist_name.clone(),\n        asset_keys_to_remove.clone(),\n    )?;\n    let removed_publish_ids: Vec\u003cString\u003e = asset_keys_to_remove\n        .iter()\n        .map(|asset_key| asset_key.1.clone())\n        .collect();\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"refresh_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name)\n        .add_attribute(\"removed_publish_ids\", removed_publish_ids.join(\", \"));\n\n    Ok(response)\n}\n\nfn create_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlists_manager = PlaylistsManager::new();\n    playlists_manager.add_new_playlist(deps.storage, channel_id.clone(), playlist_name.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"create_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name);\n\n    Ok(response)\n}\n\nfn pause(deps: DepsMut, info: MessageInfo) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.pause(deps.storage, \u0026info.sender)?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"pause\")\n        .add_attribute(\"pauser\", info.sender.clone().to_string());\n    Ok(response)\n}\n\nfn unpause(deps: DepsMut, info: MessageInfo) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.unpause(deps.storage, \u0026info.sender)?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"unpause\")\n        .add_attribute(\"pauser\", info.sender.clone().to_string());\n    Ok(response)\n}\n\nfn set_pausers(\n    deps: DepsMut,\n    info: MessageInfo,\n    pausers: Vec\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    // Validate pauser addresses\n    let validated_pausers: Vec\u003cAddr\u003e = pausers\n        .iter()\n        .map(|pauser| deps.api.addr_validate(pauser))\n        .collect::\u003cResult\u003cVec\u003cAddr\u003e, _\u003e\u003e()?;\n\n    for pauser in pausers.clone() {\n        deps.api.addr_validate(\u0026pauser)?;\n    }\n    pause_state.set_pausers(deps.storage, info.sender.clone(), validated_pausers)?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"set_pausers\")\n        .add_attribute(\"pauser\", info.sender.clone().to_string());\n    Ok(response)\n}\n\nfn add_collaborator(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    collaborator_address: String,\n    collaborator_details: ChannelCollaborator,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Admin,\n    )?;\n\n    // Validate the collaborator address\n    let collaborator_address = deps.api.addr_validate(\u0026collaborator_address)?;\n    let channels_manager = ChannelsManager::new();\n\n    // Add the collaborator to the channel\n    channels_manager.add_collaborator(\n        deps.storage,\n        channel_id.clone(),\n        collaborator_address.clone(),\n        collaborator_details.clone(),\n    )?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"add_collaborator\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"collaborator_address\", collaborator_address)\n        .add_attribute(\"share\", collaborator_details.share.to_string());\n\n    Ok(response)\n}\n\nfn remove_collaborator(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    collaborator_address: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Admin,\n    )?;\n\n    // Validate the collaborator address\n    let collaborator_address = deps.api.addr_validate(\u0026collaborator_address)?;\n\n    // Remove the collaborator from the channel\n    let channels_manager = ChannelsManager::new();\n    channels_manager.remove_collaborator(\n        deps.storage,\n        channel_id.clone(),\n        collaborator_address.clone(),\n    )?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"remove_collaborator\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"collaborator_address\", collaborator_address);\n\n    Ok(response)\n}\n\n#[allow(clippy::too_many_arguments)]\nfn update_channel_details(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    description: Option\u003cString\u003e,\n    channel_name: Option\u003cString\u003e,\n    profile_picture: Option\u003cString\u003e,\n    banner_picture: Option\u003cString\u003e,\n    payment_address: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n    let config = CONFIG.load(deps.storage)?;\n    let channels_collection_id = config.channels_collection_id.clone();\n\n    let channel_manager = ChannelsManager::new();\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        channels_collection_id.clone(),\n        Role::Admin,\n    )?;\n\n    let mut channel_metadata =\n        channel_manager.get_channel_metadata(deps.storage, channel_id.clone())?;\n\n    if let Some(description) = description.clone() {\n        channel_metadata.description = Some(description.clone());\n    }\n\n    if let Some(channel_name) = channel_name.clone() {\n        channel_metadata.channel_name = channel_name.clone();\n    }\n\n    if let Some(profile_picture) = profile_picture.clone() {\n        channel_metadata.profile_picture = Some(profile_picture.clone());\n    }\n\n    if let Some(banner_picture) = banner_picture.clone() {\n        channel_metadata.banner_picture = Some(banner_picture.clone());\n    }\n    validate_channel_metadata(channel_metadata.clone())?;\n\n    channel_manager.update_channel_metadata(\n        deps.storage,\n        channel_id.clone(),\n        channel_metadata.clone(),\n    )?;\n\n    if let Some(payment_address) = payment_address.clone() {\n        let payment_address = deps.api.addr_validate(\u0026payment_address)?;\n        channel_manager.update_payment_address(\n            deps.storage,\n            channel_id.clone(),\n            payment_address,\n        )?;\n    }\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"update_channel_details\")\n        .add_attribute(\"channel_id\", channel_id);\n\n    Ok(response)\n}\n\nfn delete_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlist_manager = PlaylistsManager::new();\n    playlist_manager.delete_playlist(deps.storage, channel_id.clone(), playlist_name.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"delete_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name);\n\n    Ok(response)\n}\nfn add_asset_to_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    asset_channel_id: String,\n    publish_id: String,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlist_manager = PlaylistsManager::new();\n\n    // Load the asset\n    let assets_manager = AssetsManager::new();\n    let asset_key = (asset_channel_id.clone(), publish_id.clone());\n    let asset = assets_manager.get_asset(deps.storage, asset_key.clone())?;\n\n    // Verify that the asset is visible\n    if !asset.is_visible {\n        return Err(ContractError::AssetNotVisible {});\n    }\n\n    // Add asset to playlist\n    playlist_manager.add_asset_to_playlist(\n        deps.storage,\n        channel_id.clone(),\n        playlist_name.clone(),\n        asset_key.clone(),\n    )?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"add_asset_to_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name)\n        .add_attribute(\"publish_id\", publish_id);\n\n    Ok(response)\n}\nfn remove_asset_from_playlist(\n    deps: DepsMut,\n    info: MessageInfo,\n    publish_id: String,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let playlists_manager = PlaylistsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    // Remove the asset from the playlist\n    playlists_manager.remove_assets_from_playlist(\n        deps.storage,\n        channel_id.clone(),\n        playlist_name.clone(),\n        [asset_key.clone()].to_vec(),\n    )?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"remove_asset_from_playlist\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"playlist_name\", playlist_name)\n        .add_attribute(\"publish_id\", publish_id);\n\n    Ok(response)\n}\n#[allow(clippy::too_many_arguments)]\nfn update_asset_details(\n    deps: DepsMut,\n    info: MessageInfo,\n    publish_id: String,\n    channel_id: String,\n    is_visible: Option\u003cbool\u003e,\n    name: Option\u003cString\u003e,\n    description: Option\u003cString\u003e,\n    media_uri: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    validate_permissions(\n        deps.as_ref(),\n        channel_id.clone(),\n        info.sender.clone(),\n        config.channels_collection_id.clone(),\n        Role::Publisher,\n    )?;\n\n    let assets_manager = AssetsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    let mut asset = assets_manager.get_asset(deps.storage, asset_key.clone())?;\n    let mut metadata = assets_manager.get_asset_metadata(deps.storage, asset_key.clone())?;\n    // Validate the asset name\n    if let Some(name) = name {\n        validate_string(\u0026name, StringValidationType::AssetName)?;\n        metadata.name = name;\n    }\n    // Validate the asset description\n    if let Some(description) = description {\n        validate_string(\u0026description, StringValidationType::Description)?;\n        metadata.description = description;\n    }\n    // Validate the asset media URI\n    if let Some(media_uri) = media_uri {\n        validate_string(\u0026media_uri, StringValidationType::Link)?;\n        metadata.media_uri = media_uri;\n    }\n    if let Some(is_visible) = is_visible {\n        asset.is_visible = is_visible;\n    }\n\n    assets_manager.update_asset(deps.storage, asset_key.clone(), asset.clone())?;\n    assets_manager.update_asset_metadata(deps.storage, asset_key.clone(), metadata.clone())?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"update_asset_details\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"publish_id\", publish_id)\n        .add_attribute(\"is_visible\", asset.is_visible.to_string())\n        .add_attribute(\"name\", metadata.name.clone())\n        .add_attribute(\"description\", metadata.description.clone())\n        .add_attribute(\"media_uri\", metadata.media_uri.clone());\n\n    Ok(response)\n}\n\nfn set_config(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_creation_fee: Option\u003cVec\u003cCoin\u003e\u003e,\n    protocol_admin: Option\u003cString\u003e,\n    fee_collector: Option\u003cString\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let mut config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.auth_details.protocol_admin {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    if let Some(protocol_admin) = protocol_admin {\n        let protocol_admin = deps.api.addr_validate(\u0026protocol_admin)?;\n        config.auth_details.protocol_admin = protocol_admin;\n    }\n\n    if let Some(fee_collector) = fee_collector {\n        let fee_collector = deps.api.addr_validate(\u0026fee_collector)?;\n        config.auth_details.fee_collector = fee_collector;\n    }\n\n    if let Some(channel_creation_fee) = channel_creation_fee {\n        config.channel_creation_fee = channel_creation_fee;\n    }\n\n    CONFIG.save(deps.storage, \u0026config)?;\n\n    let response = Response::new()\n        .add_attribute(\"action\", \"set_config\")\n        .add_attribute(\n            \"protocol_admin\",\n            config.auth_details.protocol_admin.to_string(),\n        )\n        .add_attribute(\n            \"fee_collector\",\n            config.auth_details.fee_collector.to_string(),\n        );\n\n    Ok(response)\n}\n\nfn manage_reserved_usernames(\n    deps: DepsMut,\n    info: MessageInfo,\n    add_usernames: Option\u003cVec\u003cReservedUsername\u003e\u003e,\n    remove_usernames: Option\u003cVec\u003cString\u003e\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let config = CONFIG.load(deps.storage)?;\n\n    if info.sender != config.auth_details.protocol_admin {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let channels_manager = ChannelsManager::new();\n\n    let mut attrs = vec![(\n        \"action\".to_string(),\n        \"manage_reserved_usernames\".to_string(),\n    )];\n    if let Some(add_usernames) = add_usernames {\n        validate_reserved_usernames(add_usernames.clone(), deps.api)?;\n        channels_manager.add_reserved_usernames(deps.storage, add_usernames.clone())?;\n        for username in add_usernames {\n            attrs.push((\"add_username\".to_string(), username.username)); // Directly push owned username\n        }\n    }\n    if let Some(remove_usernames) = remove_usernames {\n        for username in remove_usernames {\n            channels_manager.remove_reserved_usernames(deps.storage, vec![username.clone()])?;\n            attrs.push((\"remove_username\".to_string(), username)); // Directly push owned username\n        }\n    }\n\n    let response = Response::new().add_attributes(attrs);\n\n    Ok(response)\n}\n\nfn tip_channel(\n    deps: DepsMut,\n    info: MessageInfo,\n    channel_id: String,\n    amount: Coin,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n    let config = CONFIG.load(deps.storage)?;\n    let accepted_tip_denoms = config.accepted_tip_denoms.clone();\n    if !accepted_tip_denoms.contains(\u0026amount.denom) {\n        return Err(ContractError::InvalidTipDenom {});\n    }\n\n    let sent_amount = must_pay(\u0026info, \u0026amount.denom)?;\n\n    if sent_amount != amount.amount {\n        return Err(ContractError::InvalidTipAmount {});\n    }\n\n    let channels_manager = ChannelsManager::new();\n    let channel_details = channels_manager.get_channel_details(deps.storage, channel_id.clone())?;\n    let channel_payment_address = channel_details.payment_address.clone();\n    // Calculates the shares of the collaborators\n    let collaborator_shares =\n        channels_manager.get_collaborator_shares(deps.storage, channel_id.clone())?;\n    // Distributes the funds to the collaborators and remaining to the channel payment address\n    let (bank_msgs, attributes) =\n        distribute_funds_with_shares(collaborator_shares, amount.clone(), channel_payment_address)?;\n\n    let response = Response::new()\n        .add_messages(bank_msgs)\n        .add_attributes(attributes)\n        .add_attribute(\"action\", \"tip_creator\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"amount\", amount.to_string());\n\n    Ok(response)\n}\n\nfn remove_assets(\n    deps: DepsMut,\n    info: MessageInfo,\n    asset_keys: Vec\u003cAssetKey\u003e,\n    refresh_flags: Option\u003cbool\u003e,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let config = CONFIG.load(deps.storage)?;\n    if info.sender != config.auth_details.protocol_admin {\n        return Err(ContractError::Unauthorized {});\n    }\n\n    let mut deleted_assets: Vec\u003cAssetKey\u003e = Vec::new();\n    deleted_assets.extend(asset_keys.clone());\n\n    // First remove the assets specified in the message\n    let assets_manager = AssetsManager::new();\n    assets_manager.delete_assets(deps.storage, asset_keys)?;\n\n    // Refresh the flags if set\n    // If the flag is set to true, all flags of all assets will be removed\n    if let Some(refresh_flags) = refresh_flags {\n        if refresh_flags {\n            assets_manager.remove_all_flags(deps.storage)?;\n        }\n    }\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"remove_assets\")\n        .add_attribute(\"admin\", config.auth_details.protocol_admin.to_string()))\n}\n\nfn flag_asset(\n    deps: DepsMut,\n    _info: MessageInfo,\n    channel_id: String,\n    publish_id: String,\n    flag: Flag,\n) -\u003e Result\u003cResponse, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    pause_state.error_if_paused(deps.storage)?;\n\n    let assets_manager = AssetsManager::new();\n    assets_manager.add_flag(\n        deps.storage,\n        channel_id.clone(),\n        publish_id.clone(),\n        flag.clone(),\n    )?;\n\n    Ok(Response::new()\n        .add_attribute(\"action\", \"asset_flag\")\n        .add_attribute(\"channel_id\", channel_id)\n        .add_attribute(\"publish_id\", publish_id)\n        .add_attribute(\"flag\", flag.to_string()))\n}\n#[cfg_attr(not(feature = \"library\"), entry_point)]\npub fn query(deps: Deps, _env: Env, msg: QueryMsg) -\u003e StdResult\u003cBinary\u003e {\n    match msg {\n        QueryMsg::Channel { channel_id } =\u003e to_json_binary(\u0026query_channel(deps, channel_id)?),\n        QueryMsg::IsPaused {} =\u003e to_json_binary(\u0026query_is_paused(deps)?),\n        QueryMsg::Pausers {} =\u003e to_json_binary(\u0026query_pausers(deps)?),\n        QueryMsg::ChannelDetails { channel_id } =\u003e {\n            to_json_binary(\u0026query_channel_details(deps, channel_id)?)\n        }\n        QueryMsg::ChannelMetadata { channel_id } =\u003e {\n            to_json_binary(\u0026query_channel_metadata(deps, channel_id)?)\n        }\n        QueryMsg::Playlist {\n            channel_id,\n            playlist_name,\n        } =\u003e to_json_binary(\u0026query_playlist(deps, channel_id, playlist_name)?),\n        QueryMsg::Channels { start_after, limit } =\u003e {\n            to_json_binary(\u0026query_channels(deps, start_after, limit)?)\n        }\n        QueryMsg::ChannelId { user_name } =\u003e to_json_binary(\u0026query_channel_id(deps, user_name)?),\n        QueryMsg::Playlists {\n            channel_id,\n            start_after,\n            limit,\n        } =\u003e to_json_binary(\u0026query_playlists(deps, channel_id, start_after, limit)?),\n        QueryMsg::Config {} =\u003e to_json_binary(\u0026CONFIG.load(deps.storage)?),\n        QueryMsg::Assets {\n            channel_id,\n            start_after,\n            limit,\n        } =\u003e to_json_binary(\u0026query_assets(deps, channel_id, start_after, limit)?),\n        QueryMsg::Asset {\n            channel_id,\n            publish_id,\n        } =\u003e to_json_binary(\u0026query_asset(deps, channel_id, publish_id)?),\n        QueryMsg::ReservedUsernames { start_after, limit } =\u003e {\n            to_json_binary(\u0026query_reserved_usernames(deps, start_after, limit)?)\n        }\n        QueryMsg::GetChannelCollaborator {\n            channel_id,\n            collaborator_address,\n        } =\u003e to_json_binary(\u0026query_channel_collaborator(\n            deps,\n            channel_id,\n            collaborator_address,\n        )?),\n        QueryMsg::GetChannelCollaborators {\n            channel_id,\n            start_after,\n            limit,\n        } =\u003e to_json_binary(\u0026query_channel_collaborators(\n            deps,\n            channel_id,\n            start_after,\n            limit,\n        )?),\n        QueryMsg::FollowersCount { channel_id } =\u003e {\n            to_json_binary(\u0026query_followers_count(deps, channel_id)?)\n        }\n        QueryMsg::Followers {\n            channel_id,\n            start_after,\n            limit,\n        } =\u003e to_json_binary(\u0026query_followers(deps, channel_id, start_after, limit)?),\n    }\n}\n\nfn query_channel_details(deps: Deps, channel_id: String) -\u003e Result\u003cChannelDetails, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    let channel_details = channels_manager.get_channel_details(deps.storage, channel_id.clone())?;\n    Ok(channel_details)\n}\n\nfn query_channel_metadata(\n    deps: Deps,\n    channel_id: String,\n) -\u003e Result\u003cChannelMetadata, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    let channel_metadata =\n        channels_manager.get_channel_metadata(deps.storage, channel_id.clone())?;\n    Ok(channel_metadata)\n}\n\nfn query_channel(deps: Deps, channel_id: String) -\u003e Result\u003cChannelResponse, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    let channel_details = channels_manager.get_channel_details(deps.storage, channel_id.clone())?;\n    let channel_metadata =\n        channels_manager.get_channel_metadata(deps.storage, channel_id.clone())?;\n    let channel_collaborators =\n        channels_manager.get_channel_collaborators(deps.storage, channel_id.clone(), None, None)?;\n    let follower_count = channels_manager.get_followers_count(deps.storage, channel_id.clone())?;\n\n    Ok(ChannelResponse {\n        channel_id: channel_details.channel_id,\n        user_name: channel_details.user_name,\n        onft_id: channel_details.onft_id,\n        payment_address: channel_details.payment_address.to_string(),\n        channel_name: channel_metadata.channel_name,\n        description: channel_metadata.description,\n        profile_picture: channel_metadata.profile_picture,\n        banner_picture: channel_metadata.banner_picture,\n        collaborators: channel_collaborators,\n        follower_count,\n    })\n}\n\nfn query_channels(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cChannelResponse\u003e, ContractError\u003e {\n    let channels_manager = ChannelsManager::new();\n    let channels_list = channels_manager.get_channels_list(deps.storage, start_after, limit)?;\n    let channels = channels_list\n        .iter()\n        .map(|channel| query_channel(deps, channel.channel_id.clone()))\n        .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n    Ok(channels)\n}\n\nfn query_playlist(\n    deps: Deps,\n    channel_id: String,\n    playlist_name: String,\n) -\u003e Result\u003cPlaylist, ContractError\u003e {\n    let playlists_manager = PlaylistsManager::new();\n    let playlist =\n        playlists_manager.get_playlist(deps.storage, channel_id.clone(), playlist_name.clone())?;\n    Ok(playlist)\n}\n\nfn query_playlists(\n    deps: Deps,\n    channel_id: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cPlaylist\u003e, ContractError\u003e {\n    let playlists_manager = PlaylistsManager::new();\n    let playlists = playlists_manager.get_all_playlists(\n        deps.storage,\n        channel_id.clone(),\n        start_after,\n        limit,\n    )?;\n    Ok(playlists)\n}\n\nfn query_channel_id(deps: Deps, user_name: String) -\u003e Result\u003cString, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let channel_id = channels.get_channel_id(deps.storage, user_name.clone())?;\n    Ok(channel_id)\n}\n\nfn query_is_paused(deps: Deps) -\u003e Result\u003cbool, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    let is_paused = pause_state.is_paused(deps.storage)?;\n    Ok(is_paused)\n}\n\nfn query_pausers(deps: Deps) -\u003e Result\u003cVec\u003cString\u003e, ContractError\u003e {\n    let pause_state = PauseState::new()?;\n    let pausers = pause_state.get_pausers(deps.storage)?;\n    let pauser_strings = pausers.iter().map(|addr| addr.to_string()).collect();\n    Ok(pauser_strings)\n}\n\nfn query_assets(\n    deps: Deps,\n    channel_id: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cAssetResponse\u003e, ContractError\u003e {\n    let assets_manager = AssetsManager::new();\n    let assets_list =\n        assets_manager.get_all_assets(deps.storage, channel_id.clone(), start_after, limit)?;\n    Ok(assets_list)\n}\n\nfn query_asset(\n    deps: Deps,\n    channel_id: String,\n    publish_id: String,\n) -\u003e Result\u003cAssetResponse, ContractError\u003e {\n    let assets_manager = AssetsManager::new();\n    let asset_key = (channel_id.clone(), publish_id.clone());\n    let asset = assets_manager.get_asset(deps.storage, asset_key.clone())?;\n    let flags = assets_manager.get_all_flags_for_asset(deps.storage, channel_id, publish_id)?;\n    let metadata = assets_manager.get_asset_metadata(deps.storage, asset_key.clone())?;\n    Ok(AssetResponse {\n        asset,\n        flags,\n        metadata,\n    })\n}\nfn query_reserved_usernames(\n    deps: Deps,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cReservedUsername\u003e, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let reserved_usernames = channels.get_reserved_usernames(deps.storage, start_after, limit)?;\n    Ok(reserved_usernames)\n}\n\nfn query_channel_collaborator(\n    deps: Deps,\n    channel_id: String,\n    collaborator_address: Addr,\n) -\u003e Result\u003cCollaboratorInfo, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let collaborator =\n        channels.get_collaborator(deps.storage, channel_id, collaborator_address.clone())?;\n    Ok(CollaboratorInfo {\n        address: collaborator_address.to_string(),\n        role: collaborator.role.to_string(),\n        share: collaborator.share,\n    })\n}\n\nfn query_channel_collaborators(\n    deps: Deps,\n    channel_id: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cCollaboratorInfo\u003e, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let collaborators =\n        channels.get_channel_collaborators(deps.storage, channel_id, start_after, limit)?;\n    Ok(collaborators)\n}\n\nfn query_followers_count(deps: Deps, channel_id: String) -\u003e Result\u003cu64, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let count = channels.get_followers_count(deps.storage, channel_id)?;\n    Ok(count)\n}\n\nfn query_followers(\n    deps: Deps,\n    channel_id: String,\n    start_after: Option\u003cString\u003e,\n    limit: Option\u003cu32\u003e,\n) -\u003e Result\u003cVec\u003cAddr\u003e, ContractError\u003e {\n    let channels = ChannelsManager::new();\n    let followers = channels.get_followers(deps.storage, channel_id, start_after, limit)?;\n    Ok(followers)\n}\n\n#[cfg(test)]\nmod tests {}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":72}},{"line":41,"address":[],"length":0,"stats":{"Line":144}},{"line":42,"address":[],"length":0,"stats":{"Line":72}},{"line":43,"address":[],"length":0,"stats":{"Line":72}},{"line":45,"address":[],"length":0,"stats":{"Line":72}},{"line":53,"address":[],"length":0,"stats":{"Line":144}},{"line":54,"address":[],"length":0,"stats":{"Line":72}},{"line":55,"address":[],"length":0,"stats":{"Line":72}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":72}},{"line":64,"address":[],"length":0,"stats":{"Line":72}},{"line":68,"address":[],"length":0,"stats":{"Line":72}},{"line":72,"address":[],"length":0,"stats":{"Line":72}},{"line":73,"address":[],"length":0,"stats":{"Line":72}},{"line":74,"address":[],"length":0,"stats":{"Line":72}},{"line":77,"address":[],"length":0,"stats":{"Line":72}},{"line":80,"address":[],"length":0,"stats":{"Line":144}},{"line":88,"address":[],"length":0,"stats":{"Line":70}},{"line":89,"address":[],"length":0,"stats":{"Line":70}},{"line":90,"address":[],"length":0,"stats":{"Line":70}},{"line":94,"address":[],"length":0,"stats":{"Line":70}},{"line":95,"address":[],"length":0,"stats":{"Line":70}},{"line":96,"address":[],"length":0,"stats":{"Line":70}},{"line":99,"address":[],"length":0,"stats":{"Line":70}},{"line":100,"address":[],"length":0,"stats":{"Line":70}},{"line":104,"address":[],"length":0,"stats":{"Line":70}},{"line":108,"address":[],"length":0,"stats":{"Line":70}},{"line":112,"address":[],"length":0,"stats":{"Line":70}},{"line":115,"address":[],"length":0,"stats":{"Line":70}},{"line":119,"address":[],"length":0,"stats":{"Line":395}},{"line":125,"address":[],"length":0,"stats":{"Line":395}},{"line":127,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":129,"address":[],"length":0,"stats":{"Line":3}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":126}},{"line":140,"address":[],"length":0,"stats":{"Line":126}},{"line":141,"address":[],"length":0,"stats":{"Line":126}},{"line":142,"address":[],"length":0,"stats":{"Line":126}},{"line":143,"address":[],"length":0,"stats":{"Line":126}},{"line":144,"address":[],"length":0,"stats":{"Line":126}},{"line":146,"address":[],"length":0,"stats":{"Line":126}},{"line":147,"address":[],"length":0,"stats":{"Line":126}},{"line":148,"address":[],"length":0,"stats":{"Line":126}},{"line":149,"address":[],"length":0,"stats":{"Line":126}},{"line":150,"address":[],"length":0,"stats":{"Line":126}},{"line":151,"address":[],"length":0,"stats":{"Line":126}},{"line":152,"address":[],"length":0,"stats":{"Line":126}},{"line":153,"address":[],"length":0,"stats":{"Line":126}},{"line":154,"address":[],"length":0,"stats":{"Line":126}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":4}},{"line":159,"address":[],"length":0,"stats":{"Line":4}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":4}},{"line":163,"address":[],"length":0,"stats":{"Line":4}},{"line":165,"address":[],"length":0,"stats":{"Line":19}},{"line":166,"address":[],"length":0,"stats":{"Line":19}},{"line":167,"address":[],"length":0,"stats":{"Line":19}},{"line":169,"address":[],"length":0,"stats":{"Line":64}},{"line":170,"address":[],"length":0,"stats":{"Line":64}},{"line":171,"address":[],"length":0,"stats":{"Line":64}},{"line":172,"address":[],"length":0,"stats":{"Line":64}},{"line":173,"address":[],"length":0,"stats":{"Line":64}},{"line":174,"address":[],"length":0,"stats":{"Line":64}},{"line":175,"address":[],"length":0,"stats":{"Line":64}},{"line":177,"address":[],"length":0,"stats":{"Line":64}},{"line":178,"address":[],"length":0,"stats":{"Line":64}},{"line":179,"address":[],"length":0,"stats":{"Line":64}},{"line":180,"address":[],"length":0,"stats":{"Line":64}},{"line":181,"address":[],"length":0,"stats":{"Line":64}},{"line":182,"address":[],"length":0,"stats":{"Line":64}},{"line":183,"address":[],"length":0,"stats":{"Line":64}},{"line":184,"address":[],"length":0,"stats":{"Line":64}},{"line":185,"address":[],"length":0,"stats":{"Line":64}},{"line":186,"address":[],"length":0,"stats":{"Line":64}},{"line":189,"address":[],"length":0,"stats":{"Line":7}},{"line":190,"address":[],"length":0,"stats":{"Line":7}},{"line":191,"address":[],"length":0,"stats":{"Line":7}},{"line":192,"address":[],"length":0,"stats":{"Line":7}},{"line":193,"address":[],"length":0,"stats":{"Line":7}},{"line":194,"address":[],"length":0,"stats":{"Line":7}},{"line":196,"address":[],"length":0,"stats":{"Line":7}},{"line":197,"address":[],"length":0,"stats":{"Line":7}},{"line":198,"address":[],"length":0,"stats":{"Line":7}},{"line":199,"address":[],"length":0,"stats":{"Line":7}},{"line":200,"address":[],"length":0,"stats":{"Line":7}},{"line":201,"address":[],"length":0,"stats":{"Line":7}},{"line":202,"address":[],"length":0,"stats":{"Line":7}},{"line":203,"address":[],"length":0,"stats":{"Line":7}},{"line":207,"address":[],"length":0,"stats":{"Line":3}},{"line":208,"address":[],"length":0,"stats":{"Line":3}},{"line":209,"address":[],"length":0,"stats":{"Line":3}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":4}},{"line":213,"address":[],"length":0,"stats":{"Line":4}},{"line":214,"address":[],"length":0,"stats":{"Line":4}},{"line":216,"address":[],"length":0,"stats":{"Line":5}},{"line":217,"address":[],"length":0,"stats":{"Line":5}},{"line":218,"address":[],"length":0,"stats":{"Line":5}},{"line":220,"address":[],"length":0,"stats":{"Line":5}},{"line":221,"address":[],"length":0,"stats":{"Line":5}},{"line":222,"address":[],"length":0,"stats":{"Line":5}},{"line":223,"address":[],"length":0,"stats":{"Line":5}},{"line":224,"address":[],"length":0,"stats":{"Line":5}},{"line":227,"address":[],"length":0,"stats":{"Line":111}},{"line":228,"address":[],"length":0,"stats":{"Line":111}},{"line":229,"address":[],"length":0,"stats":{"Line":111}},{"line":230,"address":[],"length":0,"stats":{"Line":111}},{"line":232,"address":[],"length":0,"stats":{"Line":111}},{"line":233,"address":[],"length":0,"stats":{"Line":111}},{"line":234,"address":[],"length":0,"stats":{"Line":111}},{"line":235,"address":[],"length":0,"stats":{"Line":111}},{"line":236,"address":[],"length":0,"stats":{"Line":111}},{"line":237,"address":[],"length":0,"stats":{"Line":111}},{"line":240,"address":[],"length":0,"stats":{"Line":5}},{"line":241,"address":[],"length":0,"stats":{"Line":5}},{"line":242,"address":[],"length":0,"stats":{"Line":5}},{"line":243,"address":[],"length":0,"stats":{"Line":5}},{"line":244,"address":[],"length":0,"stats":{"Line":5}},{"line":245,"address":[],"length":0,"stats":{"Line":5}},{"line":247,"address":[],"length":0,"stats":{"Line":5}},{"line":248,"address":[],"length":0,"stats":{"Line":5}},{"line":249,"address":[],"length":0,"stats":{"Line":5}},{"line":250,"address":[],"length":0,"stats":{"Line":5}},{"line":251,"address":[],"length":0,"stats":{"Line":5}},{"line":252,"address":[],"length":0,"stats":{"Line":5}},{"line":253,"address":[],"length":0,"stats":{"Line":5}},{"line":254,"address":[],"length":0,"stats":{"Line":5}},{"line":256,"address":[],"length":0,"stats":{"Line":4}},{"line":258,"address":[],"length":0,"stats":{"Line":8}},{"line":259,"address":[],"length":0,"stats":{"Line":8}},{"line":260,"address":[],"length":0,"stats":{"Line":8}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":5}},{"line":265,"address":[],"length":0,"stats":{"Line":16}},{"line":266,"address":[],"length":0,"stats":{"Line":16}},{"line":267,"address":[],"length":0,"stats":{"Line":16}},{"line":269,"address":[],"length":0,"stats":{"Line":16}},{"line":270,"address":[],"length":0,"stats":{"Line":16}},{"line":271,"address":[],"length":0,"stats":{"Line":16}},{"line":272,"address":[],"length":0,"stats":{"Line":16}},{"line":273,"address":[],"length":0,"stats":{"Line":16}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":64}},{"line":297,"address":[],"length":0,"stats":{"Line":128}},{"line":298,"address":[],"length":0,"stats":{"Line":1}},{"line":300,"address":[],"length":0,"stats":{"Line":126}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":306,"address":[],"length":0,"stats":{"Line":62}},{"line":309,"address":[],"length":0,"stats":{"Line":62}},{"line":311,"address":[],"length":0,"stats":{"Line":62}},{"line":317,"address":[],"length":0,"stats":{"Line":1}},{"line":325,"address":[],"length":0,"stats":{"Line":1}},{"line":326,"address":[],"length":0,"stats":{"Line":61}},{"line":329,"address":[],"length":0,"stats":{"Line":59}},{"line":330,"address":[],"length":0,"stats":{"Line":56}},{"line":333,"address":[],"length":0,"stats":{"Line":3}},{"line":334,"address":[],"length":0,"stats":{"Line":3}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":57}},{"line":349,"address":[],"length":0,"stats":{"Line":57}},{"line":350,"address":[],"length":0,"stats":{"Line":57}},{"line":351,"address":[],"length":0,"stats":{"Line":57}},{"line":352,"address":[],"length":0,"stats":{"Line":57}},{"line":357,"address":[],"length":0,"stats":{"Line":56}},{"line":358,"address":[],"length":0,"stats":{"Line":56}},{"line":359,"address":[],"length":0,"stats":{"Line":56}},{"line":362,"address":[],"length":0,"stats":{"Line":56}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":56}},{"line":379,"address":[],"length":0,"stats":{"Line":56}},{"line":382,"address":[],"length":0,"stats":{"Line":56}},{"line":383,"address":[],"length":0,"stats":{"Line":56}},{"line":384,"address":[],"length":0,"stats":{"Line":56}},{"line":386,"address":[],"length":0,"stats":{"Line":56}},{"line":387,"address":[],"length":0,"stats":{"Line":56}},{"line":389,"address":[],"length":0,"stats":{"Line":56}},{"line":392,"address":[],"length":0,"stats":{"Line":4}},{"line":397,"address":[],"length":0,"stats":{"Line":4}},{"line":398,"address":[],"length":0,"stats":{"Line":6}},{"line":400,"address":[],"length":0,"stats":{"Line":2}},{"line":402,"address":[],"length":0,"stats":{"Line":2}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":4}},{"line":425,"address":[],"length":0,"stats":{"Line":8}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":428,"address":[],"length":0,"stats":{"Line":6}},{"line":442,"address":[],"length":0,"stats":{"Line":1}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":1}},{"line":448,"address":[],"length":0,"stats":{"Line":1}},{"line":450,"address":[],"length":0,"stats":{"Line":1}},{"line":454,"address":[],"length":0,"stats":{"Line":126}},{"line":465,"address":[],"length":0,"stats":{"Line":252}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":252}},{"line":478,"address":[],"length":0,"stats":{"Line":125}},{"line":480,"address":[],"length":0,"stats":{"Line":127}},{"line":482,"address":[],"length":0,"stats":{"Line":123}},{"line":486,"address":[],"length":0,"stats":{"Line":123}},{"line":487,"address":[],"length":0,"stats":{"Line":123}},{"line":488,"address":[],"length":0,"stats":{"Line":123}},{"line":493,"address":[],"length":0,"stats":{"Line":123}},{"line":494,"address":[],"length":0,"stats":{"Line":123}},{"line":495,"address":[],"length":0,"stats":{"Line":123}},{"line":497,"address":[],"length":0,"stats":{"Line":125}},{"line":499,"address":[],"length":0,"stats":{"Line":2}},{"line":500,"address":[],"length":0,"stats":{"Line":2}},{"line":501,"address":[],"length":0,"stats":{"Line":2}},{"line":502,"address":[],"length":0,"stats":{"Line":2}},{"line":503,"address":[],"length":0,"stats":{"Line":2}},{"line":504,"address":[],"length":0,"stats":{"Line":2}},{"line":509,"address":[],"length":0,"stats":{"Line":122}},{"line":511,"address":[],"length":0,"stats":{"Line":122}},{"line":512,"address":[],"length":0,"stats":{"Line":122}},{"line":513,"address":[],"length":0,"stats":{"Line":122}},{"line":515,"address":[],"length":0,"stats":{"Line":2}},{"line":516,"address":[],"length":0,"stats":{"Line":1}},{"line":518,"address":[],"length":0,"stats":{"Line":122}},{"line":521,"address":[],"length":0,"stats":{"Line":4}},{"line":527,"address":[],"length":0,"stats":{"Line":8}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":8}},{"line":540,"address":[],"length":0,"stats":{"Line":3}},{"line":541,"address":[],"length":0,"stats":{"Line":3}},{"line":542,"address":[],"length":0,"stats":{"Line":4}},{"line":544,"address":[],"length":0,"stats":{"Line":2}},{"line":546,"address":[],"length":0,"stats":{"Line":2}},{"line":547,"address":[],"length":0,"stats":{"Line":2}},{"line":549,"address":[],"length":0,"stats":{"Line":2}},{"line":552,"address":[],"length":0,"stats":{"Line":4}},{"line":558,"address":[],"length":0,"stats":{"Line":8}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":8}},{"line":571,"address":[],"length":0,"stats":{"Line":3}},{"line":572,"address":[],"length":0,"stats":{"Line":3}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":583,"address":[],"length":0,"stats":{"Line":3}},{"line":585,"address":[],"length":0,"stats":{"Line":7}},{"line":588,"address":[],"length":0,"stats":{"Line":3}},{"line":590,"address":[],"length":0,"stats":{"Line":3}},{"line":591,"address":[],"length":0,"stats":{"Line":3}},{"line":592,"address":[],"length":0,"stats":{"Line":3}},{"line":594,"address":[],"length":0,"stats":{"Line":3}},{"line":597,"address":[],"length":0,"stats":{"Line":19}},{"line":603,"address":[],"length":0,"stats":{"Line":38}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":606,"address":[],"length":0,"stats":{"Line":38}},{"line":616,"address":[],"length":0,"stats":{"Line":18}},{"line":617,"address":[],"length":0,"stats":{"Line":20}},{"line":619,"address":[],"length":0,"stats":{"Line":16}},{"line":621,"address":[],"length":0,"stats":{"Line":16}},{"line":622,"address":[],"length":0,"stats":{"Line":16}},{"line":624,"address":[],"length":0,"stats":{"Line":16}},{"line":627,"address":[],"length":0,"stats":{"Line":2}},{"line":628,"address":[],"length":0,"stats":{"Line":4}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":2}},{"line":633,"address":[],"length":0,"stats":{"Line":2}},{"line":634,"address":[],"length":0,"stats":{"Line":2}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":16}},{"line":677,"address":[],"length":0,"stats":{"Line":32}},{"line":688,"address":[],"length":0,"stats":{"Line":30}},{"line":699,"address":[],"length":0,"stats":{"Line":13}},{"line":701,"address":[],"length":0,"stats":{"Line":13}},{"line":702,"address":[],"length":0,"stats":{"Line":13}},{"line":703,"address":[],"length":0,"stats":{"Line":13}},{"line":705,"address":[],"length":0,"stats":{"Line":13}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":714,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":7}},{"line":754,"address":[],"length":0,"stats":{"Line":14}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":14}},{"line":769,"address":[],"length":0,"stats":{"Line":4}},{"line":770,"address":[],"length":0,"stats":{"Line":4}},{"line":772,"address":[],"length":0,"stats":{"Line":1}},{"line":776,"address":[],"length":0,"stats":{"Line":1}},{"line":780,"address":[],"length":0,"stats":{"Line":1}},{"line":784,"address":[],"length":0,"stats":{"Line":1}},{"line":787,"address":[],"length":0,"stats":{"Line":3}},{"line":789,"address":[],"length":0,"stats":{"Line":1}},{"line":790,"address":[],"length":0,"stats":{"Line":1}},{"line":791,"address":[],"length":0,"stats":{"Line":1}},{"line":792,"address":[],"length":0,"stats":{"Line":1}},{"line":795,"address":[],"length":0,"stats":{"Line":1}},{"line":796,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":1}},{"line":806,"address":[],"length":0,"stats":{"Line":1}},{"line":808,"address":[],"length":0,"stats":{"Line":1}},{"line":811,"address":[],"length":0,"stats":{"Line":3}},{"line":817,"address":[],"length":0,"stats":{"Line":6}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":6}},{"line":830,"address":[],"length":0,"stats":{"Line":2}},{"line":831,"address":[],"length":0,"stats":{"Line":3}},{"line":833,"address":[],"length":0,"stats":{"Line":1}},{"line":835,"address":[],"length":0,"stats":{"Line":1}},{"line":836,"address":[],"length":0,"stats":{"Line":1}},{"line":838,"address":[],"length":0,"stats":{"Line":1}},{"line":840,"address":[],"length":0,"stats":{"Line":111}},{"line":848,"address":[],"length":0,"stats":{"Line":222}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":222}},{"line":861,"address":[],"length":0,"stats":{"Line":111}},{"line":864,"address":[],"length":0,"stats":{"Line":111}},{"line":865,"address":[],"length":0,"stats":{"Line":111}},{"line":866,"address":[],"length":0,"stats":{"Line":111}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":110}},{"line":875,"address":[],"length":0,"stats":{"Line":110}},{"line":876,"address":[],"length":0,"stats":{"Line":110}},{"line":877,"address":[],"length":0,"stats":{"Line":110}},{"line":878,"address":[],"length":0,"stats":{"Line":110}},{"line":881,"address":[],"length":0,"stats":{"Line":108}},{"line":883,"address":[],"length":0,"stats":{"Line":108}},{"line":884,"address":[],"length":0,"stats":{"Line":108}},{"line":885,"address":[],"length":0,"stats":{"Line":108}},{"line":887,"address":[],"length":0,"stats":{"Line":108}},{"line":889,"address":[],"length":0,"stats":{"Line":4}},{"line":896,"address":[],"length":0,"stats":{"Line":8}},{"line":897,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":8}},{"line":909,"address":[],"length":0,"stats":{"Line":3}},{"line":910,"address":[],"length":0,"stats":{"Line":3}},{"line":912,"address":[],"length":0,"stats":{"Line":3}},{"line":913,"address":[],"length":0,"stats":{"Line":3}},{"line":914,"address":[],"length":0,"stats":{"Line":3}},{"line":915,"address":[],"length":0,"stats":{"Line":3}},{"line":916,"address":[],"length":0,"stats":{"Line":3}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":923,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":5}},{"line":938,"address":[],"length":0,"stats":{"Line":10}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":10}},{"line":951,"address":[],"length":0,"stats":{"Line":4}},{"line":952,"address":[],"length":0,"stats":{"Line":4}},{"line":953,"address":[],"length":0,"stats":{"Line":4}},{"line":954,"address":[],"length":0,"stats":{"Line":3}},{"line":956,"address":[],"length":0,"stats":{"Line":3}},{"line":957,"address":[],"length":0,"stats":{"Line":0}},{"line":958,"address":[],"length":0,"stats":{"Line":3}},{"line":961,"address":[],"length":0,"stats":{"Line":4}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":1}},{"line":966,"address":[],"length":0,"stats":{"Line":4}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":968,"address":[],"length":0,"stats":{"Line":1}},{"line":970,"address":[],"length":0,"stats":{"Line":5}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":3}},{"line":977,"address":[],"length":0,"stats":{"Line":3}},{"line":979,"address":[],"length":0,"stats":{"Line":3}},{"line":980,"address":[],"length":0,"stats":{"Line":3}},{"line":981,"address":[],"length":0,"stats":{"Line":3}},{"line":982,"address":[],"length":0,"stats":{"Line":3}},{"line":983,"address":[],"length":0,"stats":{"Line":3}},{"line":984,"address":[],"length":0,"stats":{"Line":3}},{"line":986,"address":[],"length":0,"stats":{"Line":3}},{"line":989,"address":[],"length":0,"stats":{"Line":5}},{"line":996,"address":[],"length":0,"stats":{"Line":10}},{"line":999,"address":[],"length":0,"stats":{"Line":2}},{"line":1002,"address":[],"length":0,"stats":{"Line":3}},{"line":1003,"address":[],"length":0,"stats":{"Line":3}},{"line":1007,"address":[],"length":0,"stats":{"Line":4}},{"line":1008,"address":[],"length":0,"stats":{"Line":2}},{"line":1012,"address":[],"length":0,"stats":{"Line":4}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":2}},{"line":1022,"address":[],"length":0,"stats":{"Line":2}},{"line":1026,"address":[],"length":0,"stats":{"Line":2}},{"line":1029,"address":[],"length":0,"stats":{"Line":2}},{"line":1032,"address":[],"length":0,"stats":{"Line":8}},{"line":1038,"address":[],"length":0,"stats":{"Line":16}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1041,"address":[],"length":0,"stats":{"Line":16}},{"line":1044,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":8}},{"line":1049,"address":[],"length":0,"stats":{"Line":8}},{"line":1050,"address":[],"length":0,"stats":{"Line":8}},{"line":1051,"address":[],"length":0,"stats":{"Line":8}},{"line":1053,"address":[],"length":0,"stats":{"Line":6}},{"line":1054,"address":[],"length":0,"stats":{"Line":2}},{"line":1055,"address":[],"length":0,"stats":{"Line":4}},{"line":1056,"address":[],"length":0,"stats":{"Line":16}},{"line":1057,"address":[],"length":0,"stats":{"Line":4}},{"line":1060,"address":[],"length":0,"stats":{"Line":9}},{"line":1061,"address":[],"length":0,"stats":{"Line":8}},{"line":1062,"address":[],"length":0,"stats":{"Line":1}},{"line":1063,"address":[],"length":0,"stats":{"Line":2}},{"line":1067,"address":[],"length":0,"stats":{"Line":5}},{"line":1069,"address":[],"length":0,"stats":{"Line":5}},{"line":1072,"address":[],"length":0,"stats":{"Line":5}},{"line":1078,"address":[],"length":0,"stats":{"Line":10}},{"line":1079,"address":[],"length":0,"stats":{"Line":0}},{"line":1080,"address":[],"length":0,"stats":{"Line":10}},{"line":1083,"address":[],"length":0,"stats":{"Line":1}},{"line":1086,"address":[],"length":0,"stats":{"Line":4}},{"line":1089,"address":[],"length":0,"stats":{"Line":1}},{"line":1092,"address":[],"length":0,"stats":{"Line":2}},{"line":1093,"address":[],"length":0,"stats":{"Line":2}},{"line":1096,"address":[],"length":0,"stats":{"Line":2}},{"line":1097,"address":[],"length":0,"stats":{"Line":0}},{"line":1099,"address":[],"length":0,"stats":{"Line":2}},{"line":1100,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":2}},{"line":1103,"address":[],"length":0,"stats":{"Line":2}},{"line":1104,"address":[],"length":0,"stats":{"Line":2}},{"line":1106,"address":[],"length":0,"stats":{"Line":2}},{"line":1107,"address":[],"length":0,"stats":{"Line":2}},{"line":1109,"address":[],"length":0,"stats":{"Line":2}},{"line":1112,"address":[],"length":0,"stats":{"Line":3}},{"line":1118,"address":[],"length":0,"stats":{"Line":6}},{"line":1120,"address":[],"length":0,"stats":{"Line":1}},{"line":1123,"address":[],"length":0,"stats":{"Line":2}},{"line":1124,"address":[],"length":0,"stats":{"Line":2}},{"line":1127,"address":[],"length":0,"stats":{"Line":2}},{"line":1128,"address":[],"length":0,"stats":{"Line":3}},{"line":1132,"address":[],"length":0,"stats":{"Line":1}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1138,"address":[],"length":0,"stats":{"Line":1}},{"line":1139,"address":[],"length":0,"stats":{"Line":1}},{"line":1140,"address":[],"length":0,"stats":{"Line":1}},{"line":1143,"address":[],"length":0,"stats":{"Line":1}},{"line":1150,"address":[],"length":0,"stats":{"Line":2}},{"line":1151,"address":[],"length":0,"stats":{"Line":0}},{"line":1153,"address":[],"length":0,"stats":{"Line":1}},{"line":1154,"address":[],"length":0,"stats":{"Line":1}},{"line":1155,"address":[],"length":0,"stats":{"Line":1}},{"line":1156,"address":[],"length":0,"stats":{"Line":1}},{"line":1157,"address":[],"length":0,"stats":{"Line":1}},{"line":1158,"address":[],"length":0,"stats":{"Line":1}},{"line":1161,"address":[],"length":0,"stats":{"Line":1}},{"line":1162,"address":[],"length":0,"stats":{"Line":1}},{"line":1163,"address":[],"length":0,"stats":{"Line":1}},{"line":1164,"address":[],"length":0,"stats":{"Line":1}},{"line":1165,"address":[],"length":0,"stats":{"Line":1}},{"line":1168,"address":[],"length":0,"stats":{"Line":46}},{"line":1169,"address":[],"length":0,"stats":{"Line":46}},{"line":1170,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":0}},{"line":1172,"address":[],"length":0,"stats":{"Line":0}},{"line":1173,"address":[],"length":0,"stats":{"Line":6}},{"line":1174,"address":[],"length":0,"stats":{"Line":7}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":10}},{"line":1181,"address":[],"length":0,"stats":{"Line":10}},{"line":1182,"address":[],"length":0,"stats":{"Line":10}},{"line":1183,"address":[],"length":0,"stats":{"Line":1}},{"line":1184,"address":[],"length":0,"stats":{"Line":1}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1188,"address":[],"length":0,"stats":{"Line":7}},{"line":1189,"address":[],"length":0,"stats":{"Line":7}},{"line":1190,"address":[],"length":0,"stats":{"Line":7}},{"line":1191,"address":[],"length":0,"stats":{"Line":7}},{"line":1192,"address":[],"length":0,"stats":{"Line":3}},{"line":1194,"address":[],"length":0,"stats":{"Line":3}},{"line":1195,"address":[],"length":0,"stats":{"Line":3}},{"line":1196,"address":[],"length":0,"stats":{"Line":3}},{"line":1197,"address":[],"length":0,"stats":{"Line":3}},{"line":1199,"address":[],"length":0,"stats":{"Line":5}},{"line":1200,"address":[],"length":0,"stats":{"Line":5}},{"line":1201,"address":[],"length":0,"stats":{"Line":5}},{"line":1202,"address":[],"length":0,"stats":{"Line":8}},{"line":1203,"address":[],"length":0,"stats":{"Line":8}},{"line":1206,"address":[],"length":0,"stats":{"Line":1}},{"line":1207,"address":[],"length":0,"stats":{"Line":1}},{"line":1208,"address":[],"length":0,"stats":{"Line":1}},{"line":1209,"address":[],"length":0,"stats":{"Line":1}},{"line":1210,"address":[],"length":0,"stats":{"Line":1}},{"line":1211,"address":[],"length":0,"stats":{"Line":1}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1218,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1221,"address":[],"length":0,"stats":{"Line":0}},{"line":1223,"address":[],"length":0,"stats":{"Line":1}},{"line":1224,"address":[],"length":0,"stats":{"Line":1}},{"line":1227,"address":[],"length":0,"stats":{"Line":1}},{"line":1228,"address":[],"length":0,"stats":{"Line":1}},{"line":1229,"address":[],"length":0,"stats":{"Line":1}},{"line":1230,"address":[],"length":0,"stats":{"Line":1}},{"line":1234,"address":[],"length":0,"stats":{"Line":6}},{"line":1235,"address":[],"length":0,"stats":{"Line":6}},{"line":1236,"address":[],"length":0,"stats":{"Line":12}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1244,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":1}},{"line":1251,"address":[],"length":0,"stats":{"Line":1}},{"line":1252,"address":[],"length":0,"stats":{"Line":2}},{"line":1253,"address":[],"length":0,"stats":{"Line":1}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":1}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":1}},{"line":1259,"address":[],"length":0,"stats":{"Line":1}},{"line":1260,"address":[],"length":0,"stats":{"Line":1}},{"line":1261,"address":[],"length":0,"stats":{"Line":1}},{"line":1262,"address":[],"length":0,"stats":{"Line":1}},{"line":1263,"address":[],"length":0,"stats":{"Line":1}},{"line":1264,"address":[],"length":0,"stats":{"Line":1}},{"line":1265,"address":[],"length":0,"stats":{"Line":1}},{"line":1266,"address":[],"length":0,"stats":{"Line":1}},{"line":1267,"address":[],"length":0,"stats":{"Line":1}},{"line":1268,"address":[],"length":0,"stats":{"Line":1}},{"line":1269,"address":[],"length":0,"stats":{"Line":1}},{"line":1273,"address":[],"length":0,"stats":{"Line":1}},{"line":1278,"address":[],"length":0,"stats":{"Line":1}},{"line":1279,"address":[],"length":0,"stats":{"Line":2}},{"line":1280,"address":[],"length":0,"stats":{"Line":1}},{"line":1282,"address":[],"length":0,"stats":{"Line":1}},{"line":1284,"address":[],"length":0,"stats":{"Line":1}},{"line":1287,"address":[],"length":0,"stats":{"Line":10}},{"line":1292,"address":[],"length":0,"stats":{"Line":10}},{"line":1293,"address":[],"length":0,"stats":{"Line":10}},{"line":1294,"address":[],"length":0,"stats":{"Line":10}},{"line":1298,"address":[],"length":0,"stats":{"Line":7}},{"line":1304,"address":[],"length":0,"stats":{"Line":7}},{"line":1305,"address":[],"length":0,"stats":{"Line":14}},{"line":1306,"address":[],"length":0,"stats":{"Line":7}},{"line":1307,"address":[],"length":0,"stats":{"Line":7}},{"line":1308,"address":[],"length":0,"stats":{"Line":7}},{"line":1309,"address":[],"length":0,"stats":{"Line":7}},{"line":1314,"address":[],"length":0,"stats":{"Line":0}},{"line":1315,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1320,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1323,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1330,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":3}},{"line":1339,"address":[],"length":0,"stats":{"Line":3}},{"line":1340,"address":[],"length":0,"stats":{"Line":3}},{"line":1341,"address":[],"length":0,"stats":{"Line":3}},{"line":1345,"address":[],"length":0,"stats":{"Line":5}},{"line":1350,"address":[],"length":0,"stats":{"Line":5}},{"line":1351,"address":[],"length":0,"stats":{"Line":5}},{"line":1352,"address":[],"length":0,"stats":{"Line":10}},{"line":1353,"address":[],"length":0,"stats":{"Line":5}},{"line":1354,"address":[],"length":0,"stats":{"Line":5}},{"line":1355,"address":[],"length":0,"stats":{"Line":5}},{"line":1356,"address":[],"length":0,"stats":{"Line":5}},{"line":1357,"address":[],"length":0,"stats":{"Line":5}},{"line":1358,"address":[],"length":0,"stats":{"Line":5}},{"line":1361,"address":[],"length":0,"stats":{"Line":8}},{"line":1366,"address":[],"length":0,"stats":{"Line":8}},{"line":1367,"address":[],"length":0,"stats":{"Line":16}},{"line":1371,"address":[],"length":0,"stats":{"Line":1}},{"line":1376,"address":[],"length":0,"stats":{"Line":1}},{"line":1377,"address":[],"length":0,"stats":{"Line":1}},{"line":1378,"address":[],"length":0,"stats":{"Line":1}},{"line":1386,"address":[],"length":0,"stats":{"Line":0}},{"line":1392,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1398,"address":[],"length":0,"stats":{"Line":1}},{"line":1399,"address":[],"length":0,"stats":{"Line":1}},{"line":1400,"address":[],"length":0,"stats":{"Line":2}},{"line":1404,"address":[],"length":0,"stats":{"Line":1}},{"line":1410,"address":[],"length":0,"stats":{"Line":1}},{"line":1411,"address":[],"length":0,"stats":{"Line":2}}],"covered":514,"coverable":619},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","error.rs"],"content":"use asset_manager::error::AssetError;\nuse asset_manager::error::PlaylistError;\nuse channel_manager::error::ChannelError;\nuse cosmwasm_std::{Coin, StdError};\nuse cw_utils::PaymentError;\nuse pauser::PauseError;\nuse thiserror::Error;\n\nuse crate::string_validation::StringValidationError;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ContractError {\n    #[error(\"{0}\")]\n    Std(#[from] StdError),\n\n    #[error(transparent)]\n    Pause(#[from] PauseError),\n\n    #[error(transparent)]\n    Channel(#[from] ChannelError),\n\n    #[error(transparent)]\n    Playlist(#[from] PlaylistError),\n\n    #[error(transparent)]\n    Asset(#[from] AssetError),\n\n    #[error(transparent)]\n    Payment(#[from] PaymentError),\n\n    #[error(transparent)]\n    StringValidationError(#[from] StringValidationError),\n\n    #[error(\"Unauthorized\")]\n    Unauthorized {},\n\n    #[error(\"Invalid minter code id\")]\n    InvalidMinterCodeId {},\n\n    #[error(\"Invalid Mint Denom\")]\n    InvalidMintDenom {},\n\n    #[error(\"Mint denom not allowed\")]\n    MintDenomNotAllowed {},\n\n    #[error(\"Missing creation fee\")]\n    MissingCreationFee {},\n\n    #[error(\"Missing minter creation fee\")]\n    MissingMinterCreationFee {},\n\n    #[error(\"Payment error\")]\n    PaymentError {\n        expected: Vec\u003cCoin\u003e,\n        received: Vec\u003cCoin\u003e,\n    },\n\n    #[error(\"Invalid ONFT data\")]\n    InvalidOnftData {},\n\n    #[error(\"Asset to be published not found\")]\n    AssetNotFound {},\n\n    #[error(\"ONFT not found collection_id: {collection_id} onft_id: {onft_id}\")]\n    OnftNotFound {\n        collection_id: String,\n        onft_id: String,\n    },\n\n    #[error(\"ONFT not owned collection_id: {collection_id} onft_id: {onft_id}\")]\n    OnftNotOwned {\n        collection_id: String,\n        onft_id: String,\n    },\n\n    #[error(\"Failed to fetch collection creation fee\")]\n    CollectionCreationFeeError {},\n\n    #[error(\"Username already taken\")]\n    UserNameAlreadyTaken {},\n\n    #[error(\"Username does not exist\")]\n    UserNameNotFound {},\n\n    #[error(\"Invalid channel query\")]\n    InvalidChannelQuery {},\n\n    #[error(\"Asset is not visible\")]\n    AssetNotVisible {},\n\n    #[error(\"Invalid user name\")]\n    InvalidUserName {},\n\n    #[error(\"Invalid description\")]\n    InvalidDescription {},\n\n    #[error(\"Username reserved\")]\n    UserNameReserved {},\n\n    #[error(\"Invalid link\")]\n    InvalidLink {},\n\n    #[error(\"Invalid channel name\")]\n    InvalidChannelName {},\n\n    #[error(\"Invalid tip denom\")]\n    InvalidTipDenom {},\n\n    #[error(\"Invalid tip amount\")]\n    InvalidTipAmount {},\n}\n\nimpl From\u003cContractError\u003e for StdError {\n    fn from(err: ContractError) -\u003e StdError {\n        StdError::generic_err(err.to_string())\n    }\n}\n","traces":[{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","helpers.rs"],"content":"use crate::access_control::get_onft_with_owner;\nuse crate::string_validation::{validate_string, StringValidationType};\nuse crate::ContractError;\nuse asset_manager::assets::AssetsManager;\nuse cosmwasm_std::{Addr, Api, Coin, Deps, Uint128};\nuse cosmwasm_std::{CosmosMsg, Storage};\nuse omniflix_channel_types::asset::{AssetKey, AssetMetadata, AssetSource};\nuse omniflix_channel_types::channel::{ChannelDetails, ChannelMetadata};\nuse omniflix_channel_types::msg::{\n    ChannelTokenDetails, ChannelsCollectionDetails, ReservedUsername,\n};\nuse omniflix_std::types::omniflix::onft::v1beta1::{Metadata, OnftQuerier};\nuse std::str::FromStr;\n\npub fn get_collection_creation_fee(deps: Deps) -\u003e Result\u003cCoin, ContractError\u003e {\n    let onft_querier = OnftQuerier::new(\u0026deps.querier);\n    let collection_creation_fee = onft_querier\n        .params()\n        .map_err(|_| ContractError::CollectionCreationFeeError {})?\n        .params\n        .ok_or_else(|| ContractError::CollectionCreationFeeError {})?\n        .denom_creation_fee\n        .ok_or_else(|| ContractError::CollectionCreationFeeError {})?;\n    // Convert omniflix std Coin to cosmwasm Coin\n    let collection_creation_fee = Coin {\n        denom: collection_creation_fee.denom,\n        amount: Uint128::from_str(\u0026collection_creation_fee.amount)\n            .map_err(|_| ContractError::CollectionCreationFeeError {})?,\n    };\n    Ok(collection_creation_fee)\n}\n/// Purpose: Filters out assets that do not exist in storage or are not visible\npub fn filter_assets_to_remove(storage: \u0026dyn Storage, asset_keys: Vec\u003cAssetKey\u003e) -\u003e Vec\u003cAssetKey\u003e {\n    let asset_manager = AssetsManager::new();\n\n    asset_keys\n        .into_iter()\n        .filter(\n            |asset_key| match asset_manager.get_asset(storage, asset_key.clone()) {\n                Ok(asset) =\u003e !asset.is_visible,\n                Err(_) =\u003e true,\n            },\n        )\n        .collect()\n}\n\n/// Validates the channel metadata, including optional fields\npub fn validate_channel_metadata(metadata: ChannelMetadata) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\u0026metadata.channel_name, StringValidationType::ChannelName)?;\n\n    if let Some(description) = \u0026metadata.description {\n        validate_string(description, StringValidationType::Description)?;\n    }\n    if let Some(profile_picture) = \u0026metadata.profile_picture {\n        validate_string(profile_picture, StringValidationType::Link)?;\n    }\n    if let Some(banner_picture) = \u0026metadata.banner_picture {\n        validate_string(banner_picture, StringValidationType::Link)?;\n    }\n\n    Ok(())\n}\n\npub fn validate_channel_details(details: ChannelDetails) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\u0026details.user_name, StringValidationType::Username)?;\n    Ok(())\n}\n\n/// Validates reserved usernames with their associated addresses\npub fn validate_reserved_usernames(\n    reserved_usernames: Vec\u003cReservedUsername\u003e,\n    api: \u0026dyn Api,\n) -\u003e Result\u003cVec\u003cReservedUsername\u003e, ContractError\u003e {\n    reserved_usernames\n        .into_iter()\n        .map(|reserved_username| {\n            validate_string(\n                \u0026reserved_username.username.clone(),\n                StringValidationType::Username,\n            )?;\n            if let Some(address) = \u0026reserved_username.address {\n                api.addr_validate(address.as_ref())?;\n            }\n            Ok(reserved_username)\n        })\n        .collect()\n}\n\npub fn validate_asset_source(\n    deps: Deps,\n    asset_source: AssetSource,\n    owner: Addr,\n) -\u003e Result\u003c(), ContractError\u003e {\n    match asset_source {\n        AssetSource::Nft {\n            collection_id,\n            onft_id,\n        } =\u003e {\n            get_onft_with_owner(deps, collection_id, onft_id, owner.to_string())?;\n            Ok(())\n        }\n        AssetSource::OffChain {} =\u003e Ok(()),\n    }\n}\n\npub fn validate_asset_metadata(metadata: AssetMetadata) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\u0026metadata.name, StringValidationType::AssetName)?;\n    validate_string(\u0026metadata.description, StringValidationType::Description)?;\n    validate_string(\u0026metadata.media_uri, StringValidationType::Link)?;\n    Ok(())\n}\n\npub fn validate_channel_token_details(\n    channel_token_details: ChannelTokenDetails,\n) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\u0026channel_token_details.media_uri, StringValidationType::Link)?;\n    validate_string(\n        \u0026channel_token_details.preview_uri,\n        StringValidationType::Link,\n    )?;\n    validate_string(\n        \u0026channel_token_details.description,\n        StringValidationType::Description,\n    )?;\n    Ok(())\n}\n\npub fn validate_channel_collection_details(\n    collection_details: ChannelsCollectionDetails,\n) -\u003e Result\u003c(), ContractError\u003e {\n    validate_string(\n        \u0026collection_details.description,\n        StringValidationType::Description,\n    )?;\n    validate_string(\u0026collection_details.preview_uri, StringValidationType::Link)?;\n    validate_string(\u0026collection_details.uri, StringValidationType::Link)?;\n    Ok(())\n}\n\npub fn generate_mint_onft_msg(\n    onft_id: String,\n    denom_id: String,\n    contract_address: String,\n    recipient: String,\n    onft_data: String,\n    user_name: String,\n    channel_token_details: ChannelTokenDetails,\n) -\u003e (CosmosMsg, Vec\u003c(String, String)\u003e) {\n    // Create the mint message\n    let mint_onft_msg: CosmosMsg = omniflix_std::types::omniflix::onft::v1beta1::MsgMintOnft {\n        id: onft_id.clone(),\n        denom_id: denom_id.clone(),\n        sender: contract_address,\n        recipient: recipient.clone(),\n        data: onft_data.clone(),\n        metadata: Some(Metadata {\n            media_uri: channel_token_details.media_uri,\n            name: user_name.clone(),\n            description: channel_token_details.description,\n            preview_uri: channel_token_details.preview_uri,\n            uri_hash: channel_token_details.uri_hash,\n        }),\n        nsfw: channel_token_details.nsfw,\n        extensible: channel_token_details.extensible,\n        royalty_share: channel_token_details.royalty_share,\n        transferable: channel_token_details.transferable,\n    }\n    .into();\n\n    // Generate detailed attributes\n    let attributes = vec![\n        // ONFT\n        (\"denom_id\".to_string(), denom_id.clone()),\n        (\"onft_id\".to_string(), onft_id.clone()),\n        (\"owner\".to_string(), recipient.clone()),\n        // Metadata\n        (\"name\".to_string(), user_name.clone()),\n        (\"description\".to_string(), \"\".to_string()),\n        (\"media_uri\".to_string(), \"\".to_string()),\n        (\"preview_uri\".to_string(), \"\".to_string()),\n        (\"uri_hash\".to_string(), \"\".to_string()),\n        // Other\n        (\"nsfw\".to_string(), \"false\".to_string()),\n        (\"data\".to_string(), onft_data.clone()),\n        (\"extensible\".to_string(), \"false\".to_string()),\n        (\"royalty_share\".to_string(), \"0\".to_string()),\n        (\"transferable\".to_string(), \"true\".to_string()),\n        (\"created_at\".to_string(), \"\".to_string()),\n    ];\n\n    (mint_onft_msg, attributes)\n}\n\npub fn generate_create_denom_msg(\n    collection_details: ChannelsCollectionDetails,\n    contract_address: String,\n    creation_fee: Coin,\n) -\u003e CosmosMsg {\n    omniflix_std::types::omniflix::onft::v1beta1::MsgCreateDenom {\n        id: collection_details.collection_id,\n        name: collection_details.collection_name,\n        symbol: collection_details.collection_symbol,\n        description: collection_details.description,\n        preview_uri: collection_details.preview_uri,\n        schema: collection_details.schema,\n        sender: contract_address,\n        creation_fee: Some(creation_fee.into()),\n        uri: collection_details.uri,\n        uri_hash: \"\".to_string(),\n        data: \"\".to_string(),\n        royalty_receivers: vec![],\n    }\n    .into()\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":72}},{"line":16,"address":[],"length":0,"stats":{"Line":72}},{"line":17,"address":[],"length":0,"stats":{"Line":144}},{"line":18,"address":[],"length":0,"stats":{"Line":72}},{"line":19,"address":[],"length":0,"stats":{"Line":144}},{"line":21,"address":[],"length":0,"stats":{"Line":72}},{"line":23,"address":[],"length":0,"stats":{"Line":72}},{"line":30,"address":[],"length":0,"stats":{"Line":72}},{"line":33,"address":[],"length":0,"stats":{"Line":3}},{"line":34,"address":[],"length":0,"stats":{"Line":3}},{"line":36,"address":[],"length":0,"stats":{"Line":3}},{"line":39,"address":[],"length":0,"stats":{"Line":7}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":64}},{"line":49,"address":[],"length":0,"stats":{"Line":65}},{"line":51,"address":[],"length":0,"stats":{"Line":126}},{"line":52,"address":[],"length":0,"stats":{"Line":1}},{"line":54,"address":[],"length":0,"stats":{"Line":63}},{"line":55,"address":[],"length":0,"stats":{"Line":1}},{"line":57,"address":[],"length":0,"stats":{"Line":62}},{"line":58,"address":[],"length":0,"stats":{"Line":1}},{"line":61,"address":[],"length":0,"stats":{"Line":60}},{"line":64,"address":[],"length":0,"stats":{"Line":61}},{"line":65,"address":[],"length":0,"stats":{"Line":62}},{"line":66,"address":[],"length":0,"stats":{"Line":60}},{"line":70,"address":[],"length":0,"stats":{"Line":76}},{"line":74,"address":[],"length":0,"stats":{"Line":76}},{"line":76,"address":[],"length":0,"stats":{"Line":153}},{"line":77,"address":[],"length":0,"stats":{"Line":77}},{"line":78,"address":[],"length":0,"stats":{"Line":77}},{"line":79,"address":[],"length":0,"stats":{"Line":77}},{"line":81,"address":[],"length":0,"stats":{"Line":77}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":75}},{"line":89,"address":[],"length":0,"stats":{"Line":125}},{"line":94,"address":[],"length":0,"stats":{"Line":125}},{"line":96,"address":[],"length":0,"stats":{"Line":13}},{"line":97,"address":[],"length":0,"stats":{"Line":13}},{"line":98,"address":[],"length":0,"stats":{"Line":13}},{"line":99,"address":[],"length":0,"stats":{"Line":15}},{"line":100,"address":[],"length":0,"stats":{"Line":11}},{"line":102,"address":[],"length":0,"stats":{"Line":112}},{"line":106,"address":[],"length":0,"stats":{"Line":123}},{"line":107,"address":[],"length":0,"stats":{"Line":123}},{"line":108,"address":[],"length":0,"stats":{"Line":123}},{"line":109,"address":[],"length":0,"stats":{"Line":123}},{"line":110,"address":[],"length":0,"stats":{"Line":123}},{"line":113,"address":[],"length":0,"stats":{"Line":72}},{"line":116,"address":[],"length":0,"stats":{"Line":72}},{"line":118,"address":[],"length":0,"stats":{"Line":72}},{"line":119,"address":[],"length":0,"stats":{"Line":72}},{"line":122,"address":[],"length":0,"stats":{"Line":72}},{"line":123,"address":[],"length":0,"stats":{"Line":72}},{"line":125,"address":[],"length":0,"stats":{"Line":72}},{"line":128,"address":[],"length":0,"stats":{"Line":72}},{"line":132,"address":[],"length":0,"stats":{"Line":72}},{"line":133,"address":[],"length":0,"stats":{"Line":72}},{"line":135,"address":[],"length":0,"stats":{"Line":72}},{"line":136,"address":[],"length":0,"stats":{"Line":72}},{"line":137,"address":[],"length":0,"stats":{"Line":72}},{"line":140,"address":[],"length":0,"stats":{"Line":56}},{"line":151,"address":[],"length":0,"stats":{"Line":56}},{"line":152,"address":[],"length":0,"stats":{"Line":56}},{"line":154,"address":[],"length":0,"stats":{"Line":56}},{"line":155,"address":[],"length":0,"stats":{"Line":56}},{"line":156,"address":[],"length":0,"stats":{"Line":56}},{"line":163,"address":[],"length":0,"stats":{"Line":56}},{"line":164,"address":[],"length":0,"stats":{"Line":56}},{"line":165,"address":[],"length":0,"stats":{"Line":56}},{"line":166,"address":[],"length":0,"stats":{"Line":56}},{"line":171,"address":[],"length":0,"stats":{"Line":56}},{"line":173,"address":[],"length":0,"stats":{"Line":56}},{"line":174,"address":[],"length":0,"stats":{"Line":56}},{"line":175,"address":[],"length":0,"stats":{"Line":56}},{"line":177,"address":[],"length":0,"stats":{"Line":56}},{"line":178,"address":[],"length":0,"stats":{"Line":56}},{"line":179,"address":[],"length":0,"stats":{"Line":56}},{"line":180,"address":[],"length":0,"stats":{"Line":56}},{"line":181,"address":[],"length":0,"stats":{"Line":56}},{"line":183,"address":[],"length":0,"stats":{"Line":56}},{"line":184,"address":[],"length":0,"stats":{"Line":56}},{"line":185,"address":[],"length":0,"stats":{"Line":56}},{"line":186,"address":[],"length":0,"stats":{"Line":56}},{"line":187,"address":[],"length":0,"stats":{"Line":56}},{"line":188,"address":[],"length":0,"stats":{"Line":56}},{"line":191,"address":[],"length":0,"stats":{"Line":56}},{"line":194,"address":[],"length":0,"stats":{"Line":70}},{"line":200,"address":[],"length":0,"stats":{"Line":70}},{"line":201,"address":[],"length":0,"stats":{"Line":70}},{"line":202,"address":[],"length":0,"stats":{"Line":70}},{"line":203,"address":[],"length":0,"stats":{"Line":70}},{"line":204,"address":[],"length":0,"stats":{"Line":70}},{"line":205,"address":[],"length":0,"stats":{"Line":70}},{"line":207,"address":[],"length":0,"stats":{"Line":70}},{"line":208,"address":[],"length":0,"stats":{"Line":70}},{"line":209,"address":[],"length":0,"stats":{"Line":70}},{"line":210,"address":[],"length":0,"stats":{"Line":70}},{"line":211,"address":[],"length":0,"stats":{"Line":70}}],"covered":98,"coverable":99},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","lib.rs"],"content":"pub mod access_control;\npub mod contract;\nmod error;\npub mod helpers;\npub mod random;\npub mod state;\npub mod string_validation;\npub use crate::error::ContractError;\npub mod bank_helpers;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","random.rs"],"content":"use cosmwasm_std::{Binary, Env};\nuse rand_core::{RngCore, SeedableRng};\nuse rand_xoshiro::Xoshiro128PlusPlus;\nuse sha2::{Digest, Sha256};\n\n/// Converts a byte to an alphanumeric character using a predefined charset\nfn byte_to_alphanumeric(byte: u8) -\u003e char {\n    const CHARSET: \u0026[u8] = b\"abcdefghijklmnopqrstuvwxyz0123456789\";\n    CHARSET[(byte % CHARSET.len() as u8) as usize] as char\n}\n\n/// Generates a random ID with a given prefix using blockchain-based entropy\n///\n/// This is a pseudorandom generator that uses blockchain data (block time, tx index, height)\n/// combined with a provided salt to generate deterministic but unpredictable IDs.\n///\n/// # Arguments\n/// * `salt` - Additional entropy source provided by the caller\n/// * `env` - Blockchain environment containing block data\n/// * `prefix` - String prefix to prepend to the generated ID\n///\n/// # Returns\n/// A string containing the prefix followed by 32 pseudorandom alphanumeric characters\npub fn generate_random_id_with_prefix(salt: \u0026Binary, env: \u0026Env, prefix: \u0026str) -\u003e String {\n    // Extract relevant data from the environment\n    let tx_index: u32 = env.transaction.as_ref().map_or(0, |tx| tx.index);\n    let block_time = env.block.time.nanos();\n    let height = env.block.height;\n\n    // Generate a SHA-256 hash of the salt, block time, tx_index, and height\n    let hash = Sha256::digest(format!(\"{}{}{}{}\", block_time, tx_index, height, salt).as_bytes());\n\n    // Use the first 16 bytes from the hash as seed\n    let randomness: [u8; 16] = hash[..16].try_into().unwrap();\n\n    // Generate a random ID using the randomness\n    let mut id = String::with_capacity(32);\n    let mut rng = Xoshiro128PlusPlus::from_seed(randomness);\n    for _ in 0..32 {\n        id.push(byte_to_alphanumeric(rng.next_u32() as u8));\n    }\n\n    // Prefix the result\n    format!(\"{}{}\", prefix, \u0026id)\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":7968}},{"line":9,"address":[],"length":0,"stats":{"Line":7968}},{"line":24,"address":[],"length":0,"stats":{"Line":249}},{"line":26,"address":[],"length":0,"stats":{"Line":747}},{"line":27,"address":[],"length":0,"stats":{"Line":249}},{"line":28,"address":[],"length":0,"stats":{"Line":249}},{"line":31,"address":[],"length":0,"stats":{"Line":249}},{"line":34,"address":[],"length":0,"stats":{"Line":249}},{"line":37,"address":[],"length":0,"stats":{"Line":249}},{"line":38,"address":[],"length":0,"stats":{"Line":249}},{"line":39,"address":[],"length":0,"stats":{"Line":16185}},{"line":40,"address":[],"length":0,"stats":{"Line":7968}},{"line":44,"address":[],"length":0,"stats":{"Line":249}}],"covered":13,"coverable":13},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","state.rs"],"content":"use cw_storage_plus::Item;\nuse omniflix_channel_types::{\n    config::{AuthDetails, ChannelConractConfig},\n    msg::ChannelTokenDetails,\n};\n\npub type ChannelsCollectionId = String;\n\n// Define storage items\npub const CONFIG: Item\u003cChannelConractConfig\u003e = Item::new(\"chcfg\");\npub const AUTH_DETAILS: Item\u003cAuthDetails\u003e = Item::new(\"auth\");\npub const CHANNEL_TOKEN_DETAILS: Item\u003cChannelTokenDetails\u003e = Item::new(\"ch_tkn_details\");\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","contracts","omniflix-channel","src","string_validation.rs"],"content":"use thiserror::Error;\n\nuse crate::ContractError;\n\n// Configuration for string validation\n#[derive(Debug, PartialEq, Eq, Clone)]\npub struct StringValidationConfig {\n    min_length: usize,\n    max_length: usize,\n    allow_numbers: bool,\n    allow_uppercase: bool,\n    allow_spaces: bool,\n    allow_special_chars: bool,\n    required_prefixes: Vec\u003cString\u003e, // Required prefixes for the string\n    required_suffixes: Vec\u003cString\u003e, // Required suffixes for the string\n    must_contain: Vec\u003cString\u003e,      // Substrings that must be present\n    allow_empty: bool,              // Whether empty strings are allowed\n}\n\n// Define string validation errors\n#[derive(Error, Debug, PartialEq, Eq)]\npub enum StringValidationError {\n    #[error(\"Invalid length sent: {sent} min_length: {min_length} max_length: {max_length}\")]\n    InvalidLength {\n        sent: String,\n        min_length: usize,\n        max_length: usize,\n    },\n    #[error(\"Invalid prefix sent: {sent} required: {required:?}\")]\n    InvalidPrefix { sent: String, required: Vec\u003cString\u003e },\n    #[error(\"Invalid suffix sent: {sent} required: {required:?}\")]\n    InvalidSuffix { sent: String, required: Vec\u003cString\u003e },\n    #[error(\"Invalid must contain sent: {sent} required: {required:?}\")]\n    InvalidMustContain { sent: String, required: Vec\u003cString\u003e },\n    #[error(\"Uppercase characters not allowed sent: {sent}\")]\n    UppercaseNotAllowed { sent: String },\n    #[error(\"Numbers not allowed sent: {sent}\")]\n    NumbersNotAllowed { sent: String },\n    #[error(\"Spaces not allowed sent: {sent}\")]\n    SpacesNotAllowed { sent: String },\n    #[error(\"Special characters not allowed sent: {sent}\")]\n    SpecialCharsNotAllowed { sent: String },\n}\n\n// Default configuration for string validation\nimpl Default for StringValidationConfig {\n    fn default() -\u003e Self {\n        StringValidationConfig {\n            min_length: 3,\n            max_length: 32,\n            allow_numbers: false,\n            allow_uppercase: false,\n            allow_spaces: false,\n            allow_special_chars: false,\n            required_prefixes: vec![],\n            required_suffixes: vec![],\n            must_contain: vec![],\n            allow_empty: false,\n        }\n    }\n}\n\n// Types of string validation\n#[derive(Debug, PartialEq, Eq, Clone)]\npub enum StringValidationType {\n    Username,\n    ChannelName,\n    Description,\n    Link,\n    AssetName,\n}\n\n// Get configuration based on validation type\nimpl StringValidationType {\n    fn get_config(\u0026self) -\u003e StringValidationConfig {\n        match self {\n            StringValidationType::Username =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 32,\n                allow_numbers: false,\n                allow_uppercase: false,\n                allow_spaces: false,\n                allow_special_chars: false,\n                ..Default::default()\n            },\n            StringValidationType::ChannelName =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 32,\n                allow_numbers: true,\n                allow_uppercase: true,\n                allow_spaces: false,\n                allow_special_chars: false,\n                ..Default::default()\n            },\n            StringValidationType::Description =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 256,\n                allow_numbers: true,\n                allow_uppercase: true,\n                allow_spaces: true,\n                allow_special_chars: true,\n                allow_empty: true,\n                ..Default::default()\n            },\n            StringValidationType::Link =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 256,\n                allow_numbers: true,\n                allow_uppercase: true,\n                allow_spaces: false,\n                allow_special_chars: true,\n                required_prefixes: vec![\n                    \"http://\".to_string(),\n                    \"https://\".to_string(),\n                    \"ipfs://\".to_string(),\n                ],\n                must_contain: vec![],\n                ..Default::default()\n            },\n            StringValidationType::AssetName =\u003e StringValidationConfig {\n                min_length: 3,\n                max_length: 64,\n                allow_numbers: true,\n                allow_uppercase: true,\n                allow_spaces: true,\n                allow_special_chars: false,\n                ..Default::default()\n            },\n        }\n    }\n}\n\n// Validate a string based on the specified validation type\npub fn validate_string(\n    input: \u0026str,\n    validation_type: StringValidationType,\n) -\u003e Result\u003c(), ContractError\u003e {\n    let config = validation_type.get_config();\n\n    if config.allow_empty \u0026\u0026 input.is_empty() {\n        return Ok(());\n    }\n\n    // Check length\n    if !(config.min_length..=config.max_length).contains(\u0026input.len()) {\n        return Err(ContractError::StringValidationError(\n            StringValidationError::InvalidLength {\n                sent: input.to_string(),\n                min_length: config.min_length,\n                max_length: config.max_length,\n            },\n        ));\n    }\n\n    // Check required prefixes\n    if !config.required_prefixes.is_empty() {\n        let has_valid_prefix = config\n            .required_prefixes\n            .iter()\n            .any(|prefix| input.starts_with(prefix));\n        if !has_valid_prefix {\n            return Err(ContractError::StringValidationError(\n                StringValidationError::InvalidPrefix {\n                    sent: input.to_string(),\n                    required: config.required_prefixes.clone(),\n                },\n            ));\n        }\n    }\n\n    // Check required suffixes\n    if !config.required_suffixes.is_empty() {\n        let has_valid_suffix = config\n            .required_suffixes\n            .iter()\n            .any(|suffix| input.ends_with(suffix));\n        if !has_valid_suffix {\n            return Err(ContractError::StringValidationError(\n                StringValidationError::InvalidSuffix {\n                    sent: input.to_string(),\n                    required: config.required_suffixes.clone(),\n                },\n            ));\n        }\n    }\n\n    // Check must contain substrings\n    for required_substring in \u0026config.must_contain {\n        if !input.contains(required_substring) {\n            return Err(ContractError::StringValidationError(\n                StringValidationError::InvalidMustContain {\n                    sent: input.to_string(),\n                    required: config.must_contain.clone(),\n                },\n            ));\n        }\n    }\n\n    // Special case: check for dots in http/https links but not in ipfs links\n    if let StringValidationType::Link = validation_type {\n        if (input.starts_with(\"http://\") || input.starts_with(\"https://\")) \u0026\u0026 !input.contains('.') {\n            return Err(ContractError::StringValidationError(\n                StringValidationError::InvalidMustContain {\n                    sent: input.to_string(),\n                    required: vec![\".\".to_string()],\n                },\n            ));\n        }\n    }\n\n    // Check character restrictions\n    for c in input.chars() {\n        match c {\n            c if c.is_ascii_lowercase() =\u003e continue,\n            c if c.is_ascii_uppercase() =\u003e {\n                if !config.allow_uppercase {\n                    return Err(ContractError::StringValidationError(\n                        StringValidationError::UppercaseNotAllowed {\n                            sent: input.to_string(),\n                        },\n                    ));\n                }\n            }\n            c if c.is_ascii_digit() =\u003e {\n                if !config.allow_numbers {\n                    return Err(ContractError::StringValidationError(\n                        StringValidationError::NumbersNotAllowed {\n                            sent: input.to_string(),\n                        },\n                    ));\n                }\n            }\n            ' ' =\u003e {\n                if !config.allow_spaces {\n                    return Err(ContractError::StringValidationError(\n                        StringValidationError::SpacesNotAllowed {\n                            sent: input.to_string(),\n                        },\n                    ));\n                }\n            }\n            c if !c.is_ascii_alphanumeric() \u0026\u0026 c != ' ' =\u003e {\n                if !config.allow_special_chars {\n                    return Err(ContractError::StringValidationError(\n                        StringValidationError::SpecialCharsNotAllowed {\n                            sent: input.to_string(),\n                        },\n                    ));\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_validate_username() {\n        // Test valid username\n        assert!(validate_string(\"validname\", StringValidationType::Username).is_ok());\n\n        // Test invalid cases\n        assert!(validate_string(\"ab\", StringValidationType::Username).is_err()); // too short\n        assert!(validate_string(\"a\".repeat(33).as_str(), StringValidationType::Username).is_err()); // too long\n        assert!(validate_string(\"Invalid123\", StringValidationType::Username).is_err()); // numbers not allowed\n        assert!(validate_string(\"Invalid!\", StringValidationType::Username).is_err()); // special chars not allowed\n        assert!(validate_string(\"invalid name\", StringValidationType::Username).is_err());\n        // spaces not allowed\n    }\n\n    #[test]\n    fn test_validate_channel_name() {\n        // Test valid channel names\n        assert!(validate_string(\"Channel123\", StringValidationType::ChannelName).is_ok());\n        assert!(validate_string(\"channelname\", StringValidationType::ChannelName).is_ok());\n\n        // Test invalid cases\n        assert!(validate_string(\"ch\", StringValidationType::ChannelName).is_err()); // too short\n        assert!(\n            validate_string(\"a\".repeat(33).as_str(), StringValidationType::ChannelName).is_err()\n        ); // too long\n        assert!(validate_string(\"channel!\", StringValidationType::ChannelName).is_err()); // special chars not allowed\n        assert!(validate_string(\"channel name\", StringValidationType::ChannelName).is_err());\n        // spaces not allowed\n    }\n\n    #[test]\n    fn test_validate_description() {\n        // Test valid descriptions\n        assert!(\n            validate_string(\"Valid description 123!\", StringValidationType::Description).is_ok()\n        );\n        assert!(validate_string(\"Short desc\", StringValidationType::Description).is_ok());\n\n        // Test invalid cases\n        assert!(validate_string(\"ab\", StringValidationType::Description).is_err()); // too short\n        assert!(\n            validate_string(\"a\".repeat(257).as_str(), StringValidationType::Description).is_err()\n        ); // too long\n    }\n\n    #[test]\n    fn test_validate_link() {\n        // Test valid links\n        assert!(validate_string(\"https://example.com\", StringValidationType::Link).is_ok());\n        assert!(validate_string(\"http://test.org/path\", StringValidationType::Link).is_ok());\n        assert!(validate_string(\n            \"https://sub.domain.com/path?query=123\",\n            StringValidationType::Link\n        )\n        .is_ok());\n\n        // Test invalid links\n        assert!(validate_string(\"not-a-url\", StringValidationType::Link).is_err());\n        assert!(validate_string(\"ftp://invalid.com\", StringValidationType::Link).is_err());\n        assert!(validate_string(\"https://\", StringValidationType::Link).is_err());\n        assert!(validate_string(\"https://nodot\", StringValidationType::Link).is_err());\n        assert!(validate_string(\n            \"ipfs://QmNqaukWqEJg8rE7T1nKDxJomvGcJF39S6HQJqm9F9PoiH\",\n            StringValidationType::Link\n        )\n        .is_ok());\n    }\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":1097}},{"line":55,"address":[],"length":0,"stats":{"Line":1097}},{"line":56,"address":[],"length":0,"stats":{"Line":1097}},{"line":57,"address":[],"length":0,"stats":{"Line":1097}},{"line":75,"address":[],"length":0,"stats":{"Line":1097}},{"line":76,"address":[],"length":0,"stats":{"Line":1097}},{"line":112,"address":[],"length":0,"stats":{"Line":422}},{"line":117,"address":[],"length":0,"stats":{"Line":422}},{"line":134,"address":[],"length":0,"stats":{"Line":1097}},{"line":138,"address":[],"length":0,"stats":{"Line":1097}},{"line":140,"address":[],"length":0,"stats":{"Line":1432}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":1097}},{"line":146,"address":[],"length":0,"stats":{"Line":10}},{"line":147,"address":[],"length":0,"stats":{"Line":10}},{"line":148,"address":[],"length":0,"stats":{"Line":10}},{"line":149,"address":[],"length":0,"stats":{"Line":10}},{"line":150,"address":[],"length":0,"stats":{"Line":10}},{"line":156,"address":[],"length":0,"stats":{"Line":1087}},{"line":157,"address":[],"length":0,"stats":{"Line":420}},{"line":158,"address":[],"length":0,"stats":{"Line":420}},{"line":160,"address":[],"length":0,"stats":{"Line":1262}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":2}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":172,"address":[],"length":0,"stats":{"Line":1085}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":1085}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":1085}},{"line":201,"address":[],"length":0,"stats":{"Line":1252}},{"line":202,"address":[],"length":0,"stats":{"Line":2}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":204,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":23079}},{"line":213,"address":[],"length":0,"stats":{"Line":2423}},{"line":214,"address":[],"length":0,"stats":{"Line":59958}},{"line":215,"address":[],"length":0,"stats":{"Line":3547}},{"line":216,"address":[],"length":0,"stats":{"Line":266}},{"line":217,"address":[],"length":0,"stats":{"Line":4}},{"line":218,"address":[],"length":0,"stats":{"Line":4}},{"line":219,"address":[],"length":0,"stats":{"Line":4}},{"line":224,"address":[],"length":0,"stats":{"Line":2791}},{"line":225,"address":[],"length":0,"stats":{"Line":21}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":305}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":236,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":2}},{"line":242,"address":[],"length":0,"stats":{"Line":9692}},{"line":243,"address":[],"length":0,"stats":{"Line":2423}},{"line":244,"address":[],"length":0,"stats":{"Line":2}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":251,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":1075}}],"covered":53,"coverable":69},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","asset-manager","src","assets.rs"],"content":"use crate::error::AssetError;\nuse cosmwasm_std::{Order, StdResult, Storage};\nuse cw_storage_plus::{Bound, Map};\n\nuse omniflix_channel_types::{\n    asset::{Asset, AssetKey, AssetMetadata, Flag, FlagKey, PublishId},\n    channel::ChannelId,\n    msg::{AssetResponse, FlagInfo},\n};\n\npub struct AssetsManager {\n    pub assets: Map\u003cAssetKey, Asset\u003e,\n    pub asset_metadata: Map\u003cAssetKey, AssetMetadata\u003e,\n    pub flags: Map\u003cFlagKey, u64\u003e,\n}\n\nconst PAGINATION_LIMIT: u32 = 50;\n\nimpl AssetsManager {\n    /// Create a new `Assets` instance.\n    pub const fn new() -\u003e Self {\n        AssetsManager {\n            assets: Map::new(\"assets\"),\n            asset_metadata: Map::new(\"asset_metadata\"),\n            flags: Map::new(\"flags\"),\n        }\n    }\n\n    /// Add a new asset, ensuring it does not already exist.\n    pub fn add_asset(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        key: AssetKey,\n        asset: Asset,\n        metadata: AssetMetadata,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        if self.assets.has(store, key.clone()) {\n            return Err(AssetError::AssetAlreadyExists {});\n        }\n\n        self.assets\n            .save(store, key.clone(), \u0026asset)\n            .map_err(|_| AssetError::SaveAssetError {})?;\n        self.asset_metadata\n            .save(store, key, \u0026metadata)\n            .map_err(|_| AssetError::SaveAssetMetadataError {})?;\n\n        Ok(())\n    }\n\n    /// Retrieve an asset by its key.\n    pub fn get_asset(\u0026self, store: \u0026dyn Storage, key: AssetKey) -\u003e Result\u003cAsset, AssetError\u003e {\n        self.assets\n            .load(store, key)\n            .map_err(|_| AssetError::AssetNotFound {})\n    }\n\n    pub fn get_asset_metadata(\n        \u0026self,\n        store: \u0026dyn Storage,\n        key: AssetKey,\n    ) -\u003e Result\u003cAssetMetadata, AssetError\u003e {\n        self.asset_metadata\n            .load(store, key)\n            .map_err(|_| AssetError::AssetMetadataNotFound {})\n    }\n\n    /// Delete an asset by its key.\n    pub fn delete_assets(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        keys: Vec\u003cAssetKey\u003e,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        for key in keys {\n            if self.assets.load(store, key.clone()).is_err() {\n                return Err(AssetError::AssetNotFound {});\n            }\n            self.assets.remove(store, key.clone());\n            self.asset_metadata.remove(store, key);\n        }\n        Ok(())\n    }\n\n    pub fn get_all_assets(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        start_after: Option\u003cPublishId\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cAssetResponse\u003e\u003e {\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(Bound::exclusive);\n\n        let assets = self\n            .assets\n            .prefix(channel_id.clone())\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|result| {\n                result.map(|(_, asset)| {\n                    let flags = self\n                        .get_all_flags_for_asset(\n                            store,\n                            channel_id.clone(),\n                            asset.publish_id.clone(),\n                        )\n                        .unwrap_or_default();\n                    let metadata = self\n                        .get_asset_metadata(store, (channel_id.clone(), asset.publish_id.clone()))\n                        .unwrap_or_default();\n\n                    AssetResponse {\n                        asset: asset.clone(),\n                        flags,\n                        metadata,\n                    }\n                })\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .unwrap_or_default();\n\n        Ok(assets)\n    }\n\n    /// Update an existing asset by its key.\n    pub fn update_asset(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        key: AssetKey,\n        updated_asset: Asset,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        if !self.assets.has(store, key.clone()) {\n            return Err(AssetError::AssetNotFound {});\n        }\n\n        self.assets\n            .save(store, key, \u0026updated_asset)\n            .map_err(|_| AssetError::SaveAssetError {})?;\n\n        Ok(())\n    }\n\n    pub fn update_asset_metadata(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        key: AssetKey,\n        metadata: AssetMetadata,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        if !self.assets.has(store, key.clone()) {\n            return Err(AssetError::AssetNotFound {});\n        }\n\n        self.asset_metadata\n            .save(store, key, \u0026metadata)\n            .map_err(|_| AssetError::SaveAssetMetadataError {})?;\n        Ok(())\n    }\n\n    /// Delete all assets for a specific channel.\n    pub fn delete_assets_by_channel_id(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        self.assets.prefix(channel_id.clone()).clear(store, None);\n        self.asset_metadata\n            .prefix(channel_id.clone())\n            .clear(store, None);\n        Ok(())\n    }\n\n    pub fn add_flag(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        publish_id: PublishId,\n        flag: Flag,\n    ) -\u003e Result\u003c(), AssetError\u003e {\n        let key = (flag.to_key(), (channel_id, publish_id));\n        let flagged_count = self.flags.load(store, key.clone()).unwrap_or(0);\n        // save the new count\n        self.flags\n            .save(store, key, \u0026(flagged_count + 1))\n            .map_err(|_| AssetError::SaveFlagError {})?;\n        Ok(())\n    }\n\n    pub fn get_flag_count(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        publish_id: PublishId,\n        flag: Flag,\n    ) -\u003e Result\u003cu64, AssetError\u003e {\n        // Check if the asset exists\n        if !self\n            .assets\n            .has(store, (channel_id.clone(), publish_id.clone()))\n        {\n            return Err(AssetError::AssetNotFound {});\n        }\n        let key = (flag.to_key(), (channel_id.clone(), publish_id.clone()));\n        let flag_count = self.flags.load(store, key).unwrap_or(0);\n        Ok(flag_count)\n    }\n\n    pub fn get_all_flags_for_asset(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        publish_id: PublishId,\n    ) -\u003e Result\u003cVec\u003cFlagInfo\u003e, AssetError\u003e {\n        let mut flags = Vec::new();\n        for flag in Flag::values() {\n            let flag_count =\n                self.get_flag_count(store, channel_id.clone(), publish_id.clone(), flag.clone())?;\n            flags.push(FlagInfo {\n                flag: flag.clone(),\n                count: flag_count,\n            });\n        }\n        Ok(flags)\n    }\n    pub fn remove_all_flags(\u0026self, store: \u0026mut dyn Storage) -\u003e Result\u003c(), AssetError\u003e {\n        self.flags.clear(store);\n        Ok(())\n    }\n}\n\n// #[cfg(test)]\n// mod tests {\n//     use super::*;\n//     use cosmwasm_std::testing::MockStorage;\n//     use omniflix_channel_types::asset::AssetSource;\n\n//     #[test]\n//     fn test_get_all_assets_with_limit() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n\n//         // Generate 100 assets and add them to the storage\n//         for i in 0..100 {\n//             let publish_id = format!(\"asset{}\", i);\n//             let asset = Asset {\n//                 publish_id: publish_id.clone(),\n//                 channel_id: channel_id.clone(),\n//                 is_visible: true,\n//                 asset_source: AssetSource::Nft {\n//                     collection_id: \"collection_id\".to_string(),\n//                     onft_id: \"onft_id\".to_string(),\n//                 },\n//                 name: \"name\".to_string(),\n//                 description: \"description\".to_string(),\n//                 media_uri: \"http://www.media.com\".to_string(),\n//             };\n//             assets\n//                 .add_asset(\u0026mut storage, (channel_id.clone(), publish_id), asset)\n//                 .unwrap();\n//         }\n\n//         // Test with a limit of 25\n//         let assets_page_1 = assets\n//             .get_all_assets(\u0026storage, channel_id.clone(), None, Some(25))\n//             .unwrap();\n//         assert_eq!(assets_page_1.len(), 25); // Should return exactly 25 assets\n\n//         // Test with a limit of 15\n//         let assets_page_2 = assets\n//             .get_all_assets(\u0026storage, channel_id.clone(), None, Some(15))\n//             .unwrap();\n//         assert_eq!(assets_page_2.len(), 15); // Should return exactly 15 assets\n\n//         // Test with a limit \u003e MAX_LIMIT\n//         let assets_page_3 = assets\n//             .get_all_assets(\n//                 \u0026storage,\n//                 channel_id.clone(),\n//                 None,\n//                 Some(PAGINATION_LIMIT + 1),\n//             )\n//             .unwrap();\n//         assert_eq!(assets_page_3.len(), PAGINATION_LIMIT as usize); // Should return exactly 25 assets\n//     }\n\n//     #[test]\n//     fn test_get_all_assets_with_start_after() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n\n//         // Generate 100 assets and add them to the storage\n//         for i in 0..100 {\n//             let publish_id = format!(\"asset{}\", i);\n//             let asset = Asset {\n//                 publish_id: publish_id.clone(),\n//                 channel_id: channel_id.clone(),\n//                 is_visible: true,\n//                 asset_source: AssetSource::Nft {\n//                     collection_id: \"collection_id\".to_string(),\n//                     onft_id: \"onft_id\".to_string(),\n//                 },\n//                 name: \"name\".to_string(),\n//                 description: \"description\".to_string(),\n//                 media_uri: \"http://www.media.com\".to_string(),\n//             };\n//             assets\n//                 .add_asset(\u0026mut storage, (channel_id.clone(), publish_id), asset)\n//                 .unwrap();\n//         }\n\n//         // Test start_after with publish_id \"asset50\"\n//         let assets_start_after = assets\n//             .get_all_assets(\n//                 \u0026storage,\n//                 channel_id.clone(),\n//                 Some(\"asset50\".to_string()),\n//                 Some(20),\n//             )\n//             .unwrap();\n//         assert_eq!(assets_start_after.len(), 20); // Should return assets starting after \"asset50\"\n\n//         // Ensure the first asset in the result is \"asset51\"\n//         assert_eq!(\n//             assets_start_after[0].asset.publish_id,\n//             \"asset51\".to_string()\n//         );\n//     }\n\n//     #[test]\n//     fn test_get_all_assets_with_limit_and_start_after() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n\n//         // Generate 100 assets and add them to the storage\n//         for i in 0..100 {\n//             let publish_id = format!(\"asset{}\", i);\n//             let asset = Asset {\n//                 publish_id: publish_id.clone(),\n//                 channel_id: channel_id.clone(),\n//                 is_visible: true,\n//                 asset_source: AssetSource::Nft {\n//                     collection_id: \"collection_id\".to_string(),\n//                     onft_id: \"onft_id\".to_string(),\n//                 },\n//                 name: \"name\".to_string(),\n//                 description: \"description\".to_string(),\n//                 media_uri: \"http://www.media.com\".to_string(),\n//             };\n//             assets\n//                 .add_asset(\u0026mut storage, (channel_id.clone(), publish_id), asset)\n//                 .unwrap();\n//         }\n\n//         // Test with a limit of 30 and start_after with publish_id \"asset40\"\n//         let assets_with_start_after_and_limit = assets\n//             .get_all_assets(\n//                 \u0026storage,\n//                 channel_id.clone(),\n//                 Some(\"asset40\".to_string()),\n//                 Some(20),\n//             )\n//             .unwrap();\n//         assert_eq!(assets_with_start_after_and_limit.len(), 20); // Should return 20 assets\n\n//         // Ensure the first asset in the result is \"asset41\"\n//         assert_eq!(\n//             assets_with_start_after_and_limit[0].asset.publish_id,\n//             \"asset41\".to_string()\n//         );\n//     }\n//     #[test]\n//     fn test_add_asset() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset\n//         let add_result = assets.add_asset(\n//             \u0026mut storage,\n//             (channel_id.clone(), publish_id.clone()),\n//             asset.clone(),\n//         );\n//         assert!(add_result.is_ok());\n\n//         // Try adding the same asset again (should fail)\n//         let add_result_again =\n//             assets.add_asset(\u0026mut storage, (channel_id.clone(), publish_id), asset);\n//         assert!(add_result_again.is_err()); // AssetAlreadyExists error\n//     }\n\n//     #[test]\n//     fn test_get_asset() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset to storage\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id.clone()),\n//                 asset,\n//             )\n//             .unwrap();\n\n//         // Retrieve the asset\n//         let retrieved_asset = assets\n//             .get_asset(\u0026storage, (channel_id.clone(), publish_id.clone()))\n//             .unwrap();\n//         assert_eq!(retrieved_asset.publish_id, publish_id);\n//     }\n\n//     #[test]\n//     fn test_delete_asset() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id.clone()),\n//                 asset,\n//             )\n//             .unwrap();\n\n//         // Delete the asset\n//         let delete_result =\n//             assets.delete_assets(\u0026mut storage, vec![(channel_id.clone(), publish_id.clone())]);\n//         assert!(delete_result.is_ok());\n\n//         // Try to get the deleted asset (should fail)\n//         let get_result = assets.get_asset(\u0026storage, (channel_id.clone(), publish_id.clone()));\n//         assert!(get_result.is_err()); // AssetNotFound error\n//     }\n\n//     #[test]\n//     fn test_update_asset() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id.clone()),\n//                 asset,\n//             )\n//             .unwrap();\n\n//         // Update the asset\n//         let updated_asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: false, // Changing visibility\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"new_collection\".to_string(),\n//                 onft_id: \"new_onft_id\".to_string(),\n//             },\n//             name: \"new_name\".to_string(),\n//             description: \"new_description\".to_string(),\n//             media_uri: \"http://www.media1.com\".to_string(),\n//         };\n//         let update_result = assets.update_asset(\n//             \u0026mut storage,\n//             (channel_id.clone(), publish_id.clone()),\n//             updated_asset,\n//         );\n//         assert!(update_result.is_ok());\n\n//         // Retrieve the updated asset\n//         let retrieved_asset = assets\n//             .get_asset(\u0026storage, (channel_id.clone(), publish_id.clone()))\n//             .unwrap();\n//         assert!(!retrieved_asset.is_visible); // Asset should be updated\n//     }\n\n//     #[test]\n//     fn test_delete_assets_by_channel_id() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id1 = \"asset1\".to_string();\n//         let publish_id2 = \"asset2\".to_string();\n//         let asset1 = Asset {\n//             publish_id: publish_id1.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n//         let asset2 = Asset {\n//             publish_id: publish_id2.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the assets\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id1.clone()),\n//                 asset1,\n//             )\n//             .unwrap();\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id2.clone()),\n//                 asset2,\n//             )\n//             .unwrap();\n\n//         // Delete all assets for the channel\n//         let delete_result = assets.delete_assets_by_channel_id(\u0026mut storage, channel_id.clone());\n//         assert!(delete_result.is_ok());\n\n//         // Try to retrieve the assets (should fail)\n//         let get_result1 = assets.get_asset(\u0026storage, (channel_id.clone(), publish_id1.clone()));\n//         let get_result2 = assets.get_asset(\u0026storage, (channel_id.clone(), publish_id2.clone()));\n//         assert!(get_result1.is_err());\n//         assert!(get_result2.is_err());\n//     }\n\n//     #[test]\n//     fn test_asset_exists() {\n//         let mut storage = MockStorage::new();\n//         let assets = AssetsManager::new();\n\n//         let channel_id = \"channel1\".to_string();\n//         let publish_id = \"asset1\".to_string();\n//         let asset = Asset {\n//             publish_id: publish_id.clone(),\n//             channel_id: channel_id.clone(),\n//             is_visible: true,\n//             asset_source: AssetSource::Nft {\n//                 collection_id: \"collection_id\".to_string(),\n//                 onft_id: \"onft_id\".to_string(),\n//             },\n//             name: \"name\".to_string(),\n//             description: \"description\".to_string(),\n//             media_uri: \"http://www.media.com\".to_string(),\n//         };\n\n//         // Add the asset\n//         assets\n//             .add_asset(\n//                 \u0026mut storage,\n//                 (channel_id.clone(), publish_id.clone()),\n//                 asset,\n//             )\n//             .unwrap();\n\n//         // Check if the asset exists\n//         let exists = assets.asset_exists(\u0026storage, (channel_id.clone(), publish_id.clone()));\n//         assert!(exists);\n\n//         // Check for an asset that doesn't exist\n//         let exists_not_found =\n//             assets.asset_exists(\u0026storage, (channel_id.clone(), \"nonexistent\".to_string()));\n//         assert!(!exists_not_found);\n//     }\n// }\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":258}},{"line":23,"address":[],"length":0,"stats":{"Line":258}},{"line":24,"address":[],"length":0,"stats":{"Line":258}},{"line":25,"address":[],"length":0,"stats":{"Line":258}},{"line":30,"address":[],"length":0,"stats":{"Line":123}},{"line":37,"address":[],"length":0,"stats":{"Line":123}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":123}},{"line":42,"address":[],"length":0,"stats":{"Line":123}},{"line":43,"address":[],"length":0,"stats":{"Line":123}},{"line":44,"address":[],"length":0,"stats":{"Line":123}},{"line":45,"address":[],"length":0,"stats":{"Line":123}},{"line":46,"address":[],"length":0,"stats":{"Line":123}},{"line":48,"address":[],"length":0,"stats":{"Line":123}},{"line":52,"address":[],"length":0,"stats":{"Line":124}},{"line":53,"address":[],"length":0,"stats":{"Line":124}},{"line":54,"address":[],"length":0,"stats":{"Line":124}},{"line":55,"address":[],"length":0,"stats":{"Line":251}},{"line":58,"address":[],"length":0,"stats":{"Line":9}},{"line":63,"address":[],"length":0,"stats":{"Line":9}},{"line":64,"address":[],"length":0,"stats":{"Line":9}},{"line":65,"address":[],"length":0,"stats":{"Line":18}},{"line":69,"address":[],"length":0,"stats":{"Line":5}},{"line":74,"address":[],"length":0,"stats":{"Line":13}},{"line":76,"address":[],"length":0,"stats":{"Line":2}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":94,"address":[],"length":0,"stats":{"Line":3}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":98,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":4}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":101,"address":[],"length":0,"stats":{"Line":1}},{"line":102,"address":[],"length":0,"stats":{"Line":1}},{"line":103,"address":[],"length":0,"stats":{"Line":1}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":107,"address":[],"length":0,"stats":{"Line":1}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":1}},{"line":122,"address":[],"length":0,"stats":{"Line":3}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":3}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":3}},{"line":138,"address":[],"length":0,"stats":{"Line":6}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":3}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":156,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":1}},{"line":188,"address":[],"length":0,"stats":{"Line":30}},{"line":196,"address":[],"length":0,"stats":{"Line":30}},{"line":197,"address":[],"length":0,"stats":{"Line":30}},{"line":198,"address":[],"length":0,"stats":{"Line":30}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":30}},{"line":203,"address":[],"length":0,"stats":{"Line":30}},{"line":204,"address":[],"length":0,"stats":{"Line":30}},{"line":207,"address":[],"length":0,"stats":{"Line":6}},{"line":213,"address":[],"length":0,"stats":{"Line":6}},{"line":214,"address":[],"length":0,"stats":{"Line":66}},{"line":215,"address":[],"length":0,"stats":{"Line":30}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":30}},{"line":218,"address":[],"length":0,"stats":{"Line":30}},{"line":219,"address":[],"length":0,"stats":{"Line":30}},{"line":222,"address":[],"length":0,"stats":{"Line":6}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}}],"covered":91,"coverable":99},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","asset-manager","src","error.rs"],"content":"use thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum PlaylistError {\n    #[error(\"Playlist not found\")]\n    PlaylistNotFound {},\n\n    #[error(\"Playlist already exists\")]\n    PlaylistAlreadyExists {},\n\n    #[error(\"Asset already exists in playlist\")]\n    AssetAlreadyExistsInPlaylist {},\n\n    #[error(\"Asset not in playlist\")]\n    AssetNotInPlaylist {},\n\n    #[error(\"Error saving playlist\")]\n    SavePlaylistError {},\n\n    #[error(\"Playlist asset limit reached\")]\n    PlaylistAssetLimitReached {},\n}\n\n#[derive(Error, Debug, PartialEq)]\npub enum AssetError {\n    #[error(\"Asset not found\")]\n    AssetNotFound {},\n\n    #[error(\"Asset already exists\")]\n    AssetAlreadyExists {},\n\n    #[error(\"Error saving asset\")]\n    SaveAssetError {},\n\n    #[error(\"Media URL cannot be empty\")]\n    MediaUriCannotBeEmpty {},\n\n    #[error(\"Name cannot be empty\")]\n    NameCannotBeEmpty {},\n\n    #[error(\"Name cannot be longer than 256 characters\")]\n    NameTooLong {},\n\n    #[error(\"Description cannot be empty\")]\n    DescriptionCannotBeEmpty {},\n\n    #[error(\"Description cannot be longer than 512 characters\")]\n    DescriptionTooLong {},\n\n    #[error(\"Media url cannot be longer than 256 characters\")]\n    MediaUriTooLong {},\n\n    #[error(\"Collection ID cannot be empty\")]\n    CollectionIdCannotBeEmpty {},\n\n    #[error(\"Onft ID cannot be empty\")]\n    OnftIdCannotBeEmpty {},\n\n    #[error(\"Error saving flag\")]\n    SaveFlagError {},\n\n    #[error(\"Error removing flags with limit\")]\n    RemoveFlagsWithLimitError {},\n\n    #[error(\"Error saving asset metadata\")]\n    SaveAssetMetadataError {},\n\n    #[error(\"Asset metadata not found\")]\n    AssetMetadataNotFound {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","asset-manager","src","lib.rs"],"content":"pub mod assets;\npub mod error;\npub mod playlists;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","asset-manager","src","playlists.rs"],"content":"use cosmwasm_std::{Order, StdResult, Storage};\nuse cw_storage_plus::{Bound, Map};\n\nuse omniflix_channel_types::asset::{AssetKey, Playlist};\n\nuse crate::assets::AssetsManager;\nuse crate::error::PlaylistError;\n\ntype ChannelId = String;\ntype PlaylistName = String;\n\nconst PLAYLISTS_STORAGE_KEY: \u0026str = \"playlists\";\nconst PLAYLISTS_ASSET_LIMIT: u32 = 100;\n\npub struct PlaylistsManager {\n    pub playlists: Map\u003c(ChannelId, PlaylistName), Playlist\u003e,\n}\n\nimpl PlaylistsManager {\n    pub const fn new() -\u003e Self {\n        PlaylistsManager {\n            playlists: Map::new(PLAYLISTS_STORAGE_KEY),\n        }\n    }\n\n    // Add a new playlist to a channel\n    pub fn add_new_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        if self\n            .playlists\n            .has(store, (channel_id.clone(), playlist_name.clone()))\n        {\n            return Err(PlaylistError::PlaylistAlreadyExists {});\n        }\n\n        let playlist = Playlist {\n            assets: Vec::new(),\n            playlist_name: playlist_name.clone(),\n        };\n\n        self.playlists\n            .save(store, (channel_id, playlist_name), \u0026playlist)\n            .map_err(|_| PlaylistError::SavePlaylistError {})?;\n\n        Ok(())\n    }\n\n    // Add an asset to a specific playlist\n    pub fn add_asset_to_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n        asset_key: AssetKey,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        let mut playlist = self\n            .playlists\n            .load(store, (channel_id.clone(), playlist_name.clone()))\n            .map_err(|_| PlaylistError::PlaylistNotFound {})?;\n\n        if playlist.assets.contains(\u0026asset_key) {\n            return Err(PlaylistError::AssetAlreadyExistsInPlaylist {});\n        }\n\n        playlist.assets.push(asset_key);\n\n        if playlist.assets.len() \u003e PLAYLISTS_ASSET_LIMIT as usize {\n            return Err(PlaylistError::PlaylistAssetLimitReached {});\n        }\n\n        self.playlists\n            .save(store, (channel_id, playlist_name), \u0026playlist)\n            .map_err(|_| PlaylistError::SavePlaylistError {})?;\n\n        Ok(())\n    }\n\n    // Remove an asset from a playlist\n    pub fn remove_assets_from_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n        asset_keys: Vec\u003cAssetKey\u003e,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        let mut playlist = self\n            .playlists\n            .load(store, (channel_id.clone(), playlist_name.clone()))\n            .map_err(|_| PlaylistError::PlaylistNotFound {})?;\n\n        for asset_key in asset_keys.iter() {\n            if let Some(index) = playlist.assets.iter().position(|x| x == asset_key) {\n                playlist.assets.remove(index);\n            } else {\n                // Asset not found in the playlist\n                return Err(PlaylistError::AssetNotInPlaylist {});\n            }\n        }\n\n        self.playlists\n            .save(store, (channel_id, playlist_name), \u0026playlist)\n            .map_err(|_| PlaylistError::SavePlaylistError {})?;\n        Ok(())\n    }\n\n    // Get a specific playlist\n    pub fn get_playlist(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n    ) -\u003e Result\u003cPlaylist, PlaylistError\u003e {\n        self.playlists\n            .load(store, (channel_id, playlist_name))\n            .map_err(|_| PlaylistError::PlaylistNotFound {})\n    }\n\n    // Get all playlists for a channel (with pagination support)\n    pub fn get_all_playlists(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cPlaylist\u003e\u003e {\n        let limit = limit.unwrap_or(25) as usize;\n        let start = start_after.map(Bound::exclusive);\n\n        self.playlists\n            .prefix(channel_id)\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| item.map(|(_, playlist)| playlist))\n            .collect()\n    }\n\n    // Delete a playlist\n    pub fn delete_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n    ) -\u003e Result\u003c(), PlaylistError\u003e {\n        if !self\n            .playlists\n            .has(store, (channel_id.clone(), playlist_name.clone()))\n        {\n            return Err(PlaylistError::PlaylistNotFound {});\n        }\n\n        self.playlists.remove(store, (channel_id, playlist_name));\n        Ok(())\n    }\n\n    // Refresh the playlist\n    pub fn refresh_playlist(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        playlist_name: PlaylistName,\n    ) -\u003e Result\u003cVec\u003cAssetKey\u003e, PlaylistError\u003e {\n        let mut playlist = self\n            .playlists\n            .load(store, (channel_id.clone(), playlist_name.clone()))\n            .map_err(|_| PlaylistError::PlaylistNotFound {})?;\n\n        let asset_manager = AssetsManager::new();\n        let mut removed_asset_keys = Vec::with_capacity(playlist.assets.len());\n\n        playlist.assets.retain(|asset_key| {\n            if let Ok(asset) = asset_manager.get_asset(store, asset_key.clone()) {\n                if asset.is_visible {\n                    return true; // Keep visible asset\n                }\n            }\n            removed_asset_keys.push(asset_key.clone()); // Add to removed if not found or not visible\n            false // Remove asset\n        });\n\n        self.playlists\n            .save(store, (channel_id, playlist_name), \u0026playlist)\n            .map_err(|_| PlaylistError::SavePlaylistError {})?;\n\n        Ok(removed_asset_keys)\n    }\n\n    // Delete all playlists for a channel\n    pub fn delete_playlists_by_channel_id(\u0026self, store: \u0026mut dyn Storage, channel_id: ChannelId) {\n        self.playlists.prefix(channel_id).clear(store, None)\n    }\n}\n\n// Test delete playlists by channel id\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::MockStorage;\n\n    #[test]\n    fn test_delete_playlists_by_channel_id() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n\n        // Add 100 playlists\n        for i in 0..24 {\n            let playlist_name = format!(\"playlist_{}\", i);\n            playlists_manager\n                .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name)\n                .unwrap();\n        }\n\n        // Check if the playlists are added\n        let all_playlists = playlists_manager\n            .get_all_playlists(\u0026storage, channel_id.clone(), None, None)\n            .unwrap();\n        assert_eq!(all_playlists.len(), 24);\n\n        // Delete all playlists for the channel\n        playlists_manager.delete_playlists_by_channel_id(\u0026mut storage, channel_id.clone());\n\n        let all_playlists = playlists_manager\n            .get_all_playlists(\u0026storage, channel_id.clone(), None, None)\n            .unwrap();\n        assert_eq!(all_playlists.len(), 0);\n\n        // Check if the playlist is deleted\n        let playlist =\n            playlists_manager.get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone());\n        assert!(playlist.is_err());\n    }\n\n    #[test]\n    fn test_add_new_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Check if the playlist is added\n        let playlist =\n            playlists_manager.get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone());\n        assert!(playlist.is_ok());\n    }\n\n    #[test]\n    fn test_add_asset_to_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n        let asset_key: AssetKey = (\"asset_channel_id\".to_string(), \"publish_id\".to_string());\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Add an asset to the playlist\n        playlists_manager\n            .add_asset_to_playlist(\n                \u0026mut storage,\n                channel_id.clone(),\n                playlist_name.clone(),\n                asset_key.clone(),\n            )\n            .unwrap();\n\n        // Check if the asset is added to the playlist\n        let playlist = playlists_manager\n            .get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n        assert_eq!(playlist.assets.len(), 1);\n        assert_eq!(playlist.assets[0], asset_key);\n    }\n\n    #[test]\n    fn test_remove_assets_from_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n        let asset_key: AssetKey = (\"asset_channel_id\".to_string(), \"publish_id\".to_string());\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Add an asset to the playlist\n        playlists_manager\n            .add_asset_to_playlist(\n                \u0026mut storage,\n                channel_id.clone(),\n                playlist_name.clone(),\n                asset_key.clone(),\n            )\n            .unwrap();\n\n        // Remove the asset from the playlist\n        playlists_manager\n            .remove_assets_from_playlist(\n                \u0026mut storage,\n                channel_id.clone(),\n                playlist_name.clone(),\n                vec![asset_key.clone()],\n            )\n            .unwrap();\n\n        // Check if the asset is removed from the playlist\n        let playlist = playlists_manager\n            .get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n        assert_eq!(playlist.assets.len(), 0);\n    }\n\n    #[test]\n    fn test_get_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Get the playlist\n        let playlist = playlists_manager\n            .get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n        assert_eq!(playlist.playlist_name, playlist_name);\n    }\n\n    #[test]\n    fn test_get_all_playlists_with_start_after() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n\n        // Add 100 playlists\n        for i in 0..100 {\n            let playlist_name = format!(\"playlist_{}\", i);\n            playlists_manager\n                .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name)\n                .unwrap();\n        }\n\n        // Get 25 playlists starting after the 25th playlist\n        let all_playlists = playlists_manager\n            .get_all_playlists(\n                \u0026storage,\n                channel_id.clone(),\n                Some(\"playlist_24\".to_string()),\n                Some(25),\n            )\n            .unwrap();\n        assert_eq!(all_playlists.len(), 25);\n        assert_eq!(all_playlists[0].playlist_name, \"playlist_25\");\n    }\n\n    #[test]\n    fn test_delete_playlist() {\n        let mut storage = MockStorage::new();\n        let playlists_manager = PlaylistsManager::new();\n\n        let channel_id = \"channel_id\".to_string();\n        let playlist_name = \"playlist_name\".to_string();\n\n        // Add a new playlist\n        playlists_manager\n            .add_new_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Delete the playlist\n        playlists_manager\n            .delete_playlist(\u0026mut storage, channel_id.clone(), playlist_name.clone())\n            .unwrap();\n\n        // Check if the playlist is deleted\n        let playlist =\n            playlists_manager.get_playlist(\u0026storage, channel_id.clone(), playlist_name.clone());\n        assert!(playlist.is_err());\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":166}},{"line":22,"address":[],"length":0,"stats":{"Line":166}},{"line":27,"address":[],"length":0,"stats":{"Line":147}},{"line":33,"address":[],"length":0,"stats":{"Line":147}},{"line":34,"address":[],"length":0,"stats":{"Line":147}},{"line":35,"address":[],"length":0,"stats":{"Line":147}},{"line":37,"address":[],"length":0,"stats":{"Line":2}},{"line":41,"address":[],"length":0,"stats":{"Line":145}},{"line":42,"address":[],"length":0,"stats":{"Line":145}},{"line":45,"address":[],"length":0,"stats":{"Line":145}},{"line":46,"address":[],"length":0,"stats":{"Line":145}},{"line":47,"address":[],"length":0,"stats":{"Line":145}},{"line":49,"address":[],"length":0,"stats":{"Line":145}},{"line":53,"address":[],"length":0,"stats":{"Line":114}},{"line":60,"address":[],"length":0,"stats":{"Line":227}},{"line":61,"address":[],"length":0,"stats":{"Line":114}},{"line":62,"address":[],"length":0,"stats":{"Line":114}},{"line":63,"address":[],"length":0,"stats":{"Line":230}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":112}},{"line":71,"address":[],"length":0,"stats":{"Line":112}},{"line":72,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":111}},{"line":76,"address":[],"length":0,"stats":{"Line":111}},{"line":77,"address":[],"length":0,"stats":{"Line":111}},{"line":79,"address":[],"length":0,"stats":{"Line":111}},{"line":83,"address":[],"length":0,"stats":{"Line":7}},{"line":90,"address":[],"length":0,"stats":{"Line":13}},{"line":91,"address":[],"length":0,"stats":{"Line":7}},{"line":92,"address":[],"length":0,"stats":{"Line":7}},{"line":93,"address":[],"length":0,"stats":{"Line":16}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":12}},{"line":100,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":4}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":107,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":19}},{"line":117,"address":[],"length":0,"stats":{"Line":19}},{"line":118,"address":[],"length":0,"stats":{"Line":19}},{"line":119,"address":[],"length":0,"stats":{"Line":40}},{"line":123,"address":[],"length":0,"stats":{"Line":10}},{"line":130,"address":[],"length":0,"stats":{"Line":10}},{"line":131,"address":[],"length":0,"stats":{"Line":10}},{"line":133,"address":[],"length":0,"stats":{"Line":10}},{"line":134,"address":[],"length":0,"stats":{"Line":10}},{"line":135,"address":[],"length":0,"stats":{"Line":10}},{"line":136,"address":[],"length":0,"stats":{"Line":10}},{"line":137,"address":[],"length":0,"stats":{"Line":185}},{"line":142,"address":[],"length":0,"stats":{"Line":3}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":2}},{"line":193,"address":[],"length":0,"stats":{"Line":2}}],"covered":59,"coverable":71},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","channel-manager","src","channel.rs"],"content":"use cosmwasm_std::{Addr, Decimal, Order, StdResult, Storage};\nuse cw_storage_plus::{Bound, Map};\n\nuse crate::error::ChannelError;\nuse omniflix_channel_types::{\n    channel::{ChannelCollaborator, ChannelDetails, ChannelId, ChannelMetadata, UserName},\n    msg::{CollaboratorInfo, ReservedUsername},\n};\n\nconst CHANNEL_DETAILS: \u0026str = \"cd\"; // channel_details\nconst CHANNEL_METADATA: \u0026str = \"cm\"; // channel_metadata\nconst USERNAME_TO_CHANNEL_ID: \u0026str = \"u2i\"; // username_to_channel_id\nconst CHANNEL_ID_TO_USERNAME: \u0026str = \"i2u\"; // channel_id_to_username\nconst RESERVED_USERNAMES: \u0026str = \"ru\"; // reserved_usernames\nconst CHANNEL_COLLABORATORS: \u0026str = \"col\"; // channel_collaborators\nconst TOTAL_COLLABORATOR_SHARES: \u0026str = \"tcs\"; // total_collaborator_shares\nconst TOTAL_UNIQUE_COLLABORATOR_LIMIT: u32 = 10;\n\nconst FOLLOWERS: \u0026str = \"f\"; // followers\nconst FOLLOWERS_COUNT: \u0026str = \"fc\"; // followers_count\n\nconst PAGINATION_LIMIT: u32 = 50;\n\npub struct ChannelsManager {\n    pub channel_details: Map\u003cChannelId, ChannelDetails\u003e,\n    pub channel_metadata: Map\u003cChannelId, ChannelMetadata\u003e,\n    pub username_to_channel_id: Map\u003cUserName, ChannelId\u003e,\n    pub channel_id_to_username: Map\u003cChannelId, UserName\u003e,\n    pub reserved_usernames: Map\u003cUserName, Option\u003cAddr\u003e\u003e,\n    pub channel_collaborators: Map\u003c(ChannelId, Addr), ChannelCollaborator\u003e,\n    pub total_collaborator_shares: Map\u003cChannelId, Decimal\u003e,\n    pub followers: Map\u003c(ChannelId, Addr), bool\u003e,\n    pub followers_count: Map\u003cChannelId, u64\u003e,\n}\n\nimpl ChannelsManager {\n    pub const fn new() -\u003e Self {\n        ChannelsManager {\n            channel_details: Map::new(CHANNEL_DETAILS),\n            username_to_channel_id: Map::new(USERNAME_TO_CHANNEL_ID),\n            channel_id_to_username: Map::new(CHANNEL_ID_TO_USERNAME),\n            reserved_usernames: Map::new(RESERVED_USERNAMES),\n            channel_metadata: Map::new(CHANNEL_METADATA),\n            channel_collaborators: Map::new(CHANNEL_COLLABORATORS),\n            total_collaborator_shares: Map::new(TOTAL_COLLABORATOR_SHARES),\n            followers: Map::new(FOLLOWERS),\n            followers_count: Map::new(FOLLOWERS_COUNT),\n        }\n    }\n\n    pub fn add_reserved_usernames(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        usernames: Vec\u003cReservedUsername\u003e,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        for username in usernames {\n            self.reserved_usernames\n                .save(store, username.username.clone(), \u0026username.address)\n                .map_err(|_| ChannelError::SaveReservedUsernamesFailed {})?;\n        }\n        Ok(())\n    }\n    pub fn remove_reserved_usernames(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        usernames: Vec\u003cUserName\u003e,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        for username in usernames {\n            // return error if username does not exist\n            if !self.reserved_usernames.has(store, username.clone()) {\n                return Err(ChannelError::UsernameNotReserved {});\n            }\n            self.reserved_usernames.remove(store, username.clone());\n        }\n        Ok(())\n    }\n\n    pub fn get_reserved_usernames(\n        \u0026self,\n        store: \u0026dyn Storage,\n        start_after: Option\u003cUserName\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cReservedUsername\u003e\u003e {\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(Bound::exclusive);\n\n        let reserved_usernames: Vec\u003cReservedUsername\u003e = self\n            .reserved_usernames\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(username, address)| ReservedUsername {\n                    username,\n                    address: address.clone(),\n                })\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .unwrap_or_default();\n        Ok(reserved_usernames)\n    }\n\n    pub fn get_reserved_status(\n        \u0026self,\n        store: \u0026dyn Storage,\n        username: UserName,\n    ) -\u003e StdResult\u003cOption\u003cOption\u003cAddr\u003e\u003e\u003e {\n        // Check if the username exists in the map\n        if !self.reserved_usernames.has(store, username.clone()) {\n            return Ok(None); // Username doesn't exist\n        }\n        // Username exists, get its value (which might be None)\n        let reserved_address = self.reserved_usernames.load(store, username)?;\n        Ok(Some(reserved_address)) // Return Some(None) or Some(Some(addr))\n    }\n\n    pub fn add_channel(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        channel_details: ChannelDetails,\n        channel_metadata: ChannelMetadata,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if the channel ID or username already exists\n        if self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdAlreadyExists {});\n        }\n        if self\n            .username_to_channel_id\n            .has(store, channel_details.user_name.clone())\n        {\n            return Err(ChannelError::UserNameAlreadyTaken {});\n        }\n\n        // Save the details and mappings\n        self.channel_details\n            .save(store, channel_id.clone(), \u0026channel_details)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        self.username_to_channel_id\n            .save(store, channel_details.user_name.clone(), \u0026channel_id)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        self.channel_id_to_username\n            .save(store, channel_id.clone(), \u0026channel_details.user_name)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        self.channel_metadata\n            .save(store, channel_id, \u0026channel_metadata)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        Ok(())\n    }\n\n    pub fn delete_channel(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let user_name = self\n            .channel_id_to_username\n            .load(store, channel_id.clone())\n            .map_err(|_| ChannelError::UserNameNotFound {})?;\n\n        // Remove channel details and mappings\n        self.channel_details.remove(store, channel_id.clone());\n        self.username_to_channel_id.remove(store, user_name.clone());\n        self.channel_id_to_username.remove(store, channel_id);\n\n        Ok(())\n    }\n\n    pub fn get_channels_list(\n        \u0026self,\n        store: \u0026dyn Storage,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e StdResult\u003cVec\u003cChannelDetails\u003e\u003e {\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(Bound::exclusive);\n\n        self.channel_details\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| item.map(|(_, details)| details))\n            .collect()\n    }\n\n    pub fn get_channel_details(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cChannelDetails, ChannelError\u003e {\n        self.channel_details\n            .load(store, channel_id)\n            .map_err(|_| ChannelError::ChannelIdNotFound {})\n    }\n\n    pub fn update_payment_address(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        payment_address: Addr,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        let mut channel_details = self.get_channel_details(store, channel_id.clone())?;\n        channel_details.payment_address = payment_address;\n        self.channel_details\n            .save(store, channel_id.clone(), \u0026channel_details)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        Ok(())\n    }\n\n    pub fn get_channel_metadata(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cChannelMetadata, ChannelError\u003e {\n        self.channel_metadata\n            .load(store, channel_id)\n            .map_err(|_| ChannelError::ChannelIdNotFound {})\n    }\n\n    pub fn update_channel_metadata(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        channel_metadata: ChannelMetadata,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        if !self.channel_metadata.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        self.channel_metadata\n            .save(store, channel_id, \u0026channel_metadata)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        Ok(())\n    }\n\n    pub fn get_channel_id(\n        \u0026self,\n        store: \u0026dyn Storage,\n        user_name: UserName,\n    ) -\u003e Result\u003cChannelId, ChannelError\u003e {\n        self.username_to_channel_id\n            .load(store, user_name)\n            .map_err(|_| ChannelError::UserNameNotFound {})\n    }\n\n    pub fn get_channel_id_from_username(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        user_name: UserName,\n    ) -\u003e Result\u003cChannelId, ChannelError\u003e {\n        self.username_to_channel_id\n            .load(store, user_name)\n            .map_err(|_| ChannelError::UserNameNotFound {})\n    }\n\n    pub fn get_username_from_channel_id(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cUserName, ChannelError\u003e {\n        self.channel_id_to_username\n            .load(store, channel_id)\n            .map_err(|_| ChannelError::ChannelIdNotFound {})\n    }\n\n    pub fn add_collaborator(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        address: Addr,\n        collaborator: ChannelCollaborator,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        // Check if collaborator already exists\n        if self\n            .channel_collaborators\n            .has(store, (channel_id.clone(), address.clone()))\n        {\n            return Err(ChannelError::CollaboratorExists {});\n        }\n\n        // Calculate new total share\n        let current_total = self\n            .total_collaborator_shares\n            .load(store, channel_id.clone())\n            .unwrap_or(Decimal::zero());\n        let new_total = current_total + collaborator.share;\n\n        // Check if the number of unique collaborators exceeds the limit\n        let unique_collaborators = self\n            .channel_collaborators\n            .prefix(channel_id.clone())\n            .keys(store, None, None, Order::Ascending)\n            .count();\n        if unique_collaborators \u003e= TOTAL_UNIQUE_COLLABORATOR_LIMIT as usize {\n            return Err(ChannelError::TotalUniqueCollaboratorsLimitExceeded {});\n        }\n\n        // Validate total share doesn't exceed 100%\n        if new_total \u003e Decimal::one() {\n            return Err(ChannelError::InvalidSharePercentage {});\n        }\n\n        // Save collaborator and update total shares\n        self.channel_collaborators\n            .save(store, (channel_id.clone(), address), \u0026collaborator)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        self.total_collaborator_shares\n            .save(store, channel_id, \u0026new_total)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        Ok(())\n    }\n\n    pub fn remove_collaborator(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        address: Addr,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        // Check if the collaborator exists\n        if !self\n            .channel_collaborators\n            .has(store, (channel_id.clone(), address.clone()))\n        {\n            return Err(ChannelError::CollaboratorNotFound {});\n        }\n        let collaborator = self\n            .channel_collaborators\n            .load(store, (channel_id.clone(), address.clone()))\n            .unwrap();\n        // Remove the collaborator\n        self.channel_collaborators\n            .remove(store, (channel_id.clone(), address.clone()));\n        // Update total shares\n        let current_total = self\n            .total_collaborator_shares\n            .load(store, channel_id.clone())\n            .unwrap_or(Decimal::zero());\n        let new_total = current_total - collaborator.share;\n        self.total_collaborator_shares\n            .save(store, channel_id, \u0026new_total)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        Ok(())\n    }\n    pub fn get_collaborator_shares(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cVec\u003c(Addr, Decimal)\u003e, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let shares: Vec\u003c(Addr, Decimal)\u003e = self\n            .channel_collaborators\n            .prefix(channel_id)\n            .range(store, None, None, Order::Ascending)\n            .filter_map(|item| item.ok())\n            .map(|(addr, collaborator)| (addr, collaborator.share))\n            .collect();\n        Ok(shares)\n    }\n\n    pub fn is_collaborator(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        sender: Addr,\n    ) -\u003e Result\u003cbool, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let collaborator = self\n            .channel_collaborators\n            .has(store, (channel_id.clone(), sender.clone()));\n        Ok(collaborator)\n    }\n    pub fn get_collaborator(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        sender: Addr,\n    ) -\u003e Result\u003cChannelCollaborator, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let collaborator = self\n            .channel_collaborators\n            .load(store, (channel_id.clone(), sender.clone()));\n        if collaborator.is_err() {\n            return Err(ChannelError::CollaboratorNotFound {});\n        }\n        Ok(collaborator.unwrap())\n    }\n\n    pub fn get_channel_collaborators(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cVec\u003cCollaboratorInfo\u003e, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(|addr| Bound::exclusive(Addr::unchecked(addr)));\n\n        let channel_collaborators = self\n            .channel_collaborators\n            .prefix(channel_id)\n            .range(store, start, None, Order::Ascending)\n            .take(limit)\n            .map(|item| {\n                item.map(|(addr, collab)| CollaboratorInfo {\n                    address: addr.to_string(),\n                    role: collab.role.to_string(),\n                    share: collab.share,\n                })\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .unwrap_or_default();\n        Ok(channel_collaborators)\n    }\n\n    pub fn add_follower(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        follower: Addr,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        // Check if the follower already exists\n        if self\n            .followers\n            .has(store, (channel_id.clone(), follower.clone()))\n        {\n            return Err(ChannelError::AlreadyFollowing {});\n        }\n\n        self.followers\n            .save(store, (channel_id.clone(), follower.clone()), \u0026true)\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n\n        let current_count = self\n            .followers_count\n            .load(store, channel_id.clone())\n            .unwrap_or(0);\n        self.followers_count\n            .save(store, channel_id.clone(), \u0026(current_count + 1))\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        Ok(())\n    }\n\n    pub fn remove_follower(\n        \u0026self,\n        store: \u0026mut dyn Storage,\n        channel_id: ChannelId,\n        follower: Addr,\n    ) -\u003e Result\u003c(), ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        // Check if the follower exists\n        if !self\n            .followers\n            .has(store, (channel_id.clone(), follower.clone()))\n        {\n            return Err(ChannelError::FollowerNotFound {});\n        }\n        self.followers\n            .remove(store, (channel_id.clone(), follower.clone()));\n\n        let current_count = self\n            .followers_count\n            .load(store, channel_id.clone())\n            .unwrap_or(0);\n        self.followers_count\n            .save(store, channel_id.clone(), \u0026(current_count - 1))\n            .map_err(|_| ChannelError::SaveChannelDetailsFailed {})?;\n        Ok(())\n    }\n\n    pub fn get_followers_count(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n    ) -\u003e Result\u003cu64, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        let count = self\n            .followers_count\n            .load(store, channel_id.clone())\n            .unwrap_or(0);\n        Ok(count)\n    }\n\n    pub fn is_follower(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        follower: Addr,\n    ) -\u003e Result\u003cbool, ChannelError\u003e {\n        // Check if channel exists\n        if !self.channel_details.has(store, channel_id.clone()) {\n            return Err(ChannelError::ChannelIdNotFound {});\n        }\n        let follower = self\n            .followers\n            .has(store, (channel_id.clone(), follower.clone()));\n        Ok(follower)\n    }\n\n    pub fn get_followers(\n        \u0026self,\n        store: \u0026dyn Storage,\n        channel_id: ChannelId,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    ) -\u003e Result\u003cVec\u003cAddr\u003e, ChannelError\u003e {\n        let limit = limit.unwrap_or(PAGINATION_LIMIT).min(PAGINATION_LIMIT) as usize;\n        let start = start_after.map(|addr| Bound::exclusive(Addr::unchecked(addr)));\n\n        let followers = self\n            .followers\n            .prefix(channel_id)\n            .keys(store, start, None, Order::Ascending)\n            .take(limit)\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .unwrap_or_default();\n        Ok(followers)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::mock_dependencies;\n    use omniflix_channel_types::channel::Role;\n\n    #[test]\n    fn test_collaborator_operations() {\n        let mut deps = mock_dependencies();\n        let channels = ChannelsManager::new();\n        let channel_id1 = \"channel1\".to_string();\n        let channel_id2 = \"channel2\".to_string();\n\n        // Create channel 1\n        let channel_details1 = ChannelDetails {\n            channel_id: channel_id1.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user1\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id1.clone(),\n                channel_details1,\n                ChannelMetadata {\n                    channel_name: \"channel1\".to_string(),\n                    description: Some(\"description1\".to_string()),\n                    profile_picture: Some(\"profile_picture1\".to_string()),\n                    banner_picture: Some(\"banner_picture1\".to_string()),\n                },\n            )\n            .unwrap();\n\n        // Create channel 2\n        let channel_details2 = ChannelDetails {\n            channel_id: channel_id2.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user2\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id2.clone(),\n                channel_details2,\n                ChannelMetadata {\n                    channel_name: \"channel2\".to_string(),\n                    description: Some(\"description2\".to_string()),\n                    profile_picture: Some(\"profile_picture2\".to_string()),\n                    banner_picture: Some(\"banner_picture2\".to_string()),\n                },\n            )\n            .unwrap();\n\n        let addr1 = Addr::unchecked(\"addr1\");\n        let addr2 = Addr::unchecked(\"addr2\");\n        let addr3 = Addr::unchecked(\"addr3\");\n        let addr4 = Addr::unchecked(\"addr4\");\n\n        // Test adding collaborators to channel 1\n        let collab1 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50), // 50%\n        };\n\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id1.clone(),\n            addr1.clone(),\n            collab1,\n        );\n        assert!(result.is_ok());\n\n        let collab2 = ChannelCollaborator {\n            role: Role::Publisher,\n            share: Decimal::percent(50), // 50%\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id1.clone(),\n            addr2.clone(),\n            collab2,\n        );\n        assert!(result.is_ok());\n\n        // Test adding collaborators to channel 2\n        let collab3 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(30), // 30%\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id2.clone(),\n            addr3.clone(),\n            collab3,\n        );\n        assert!(result.is_ok());\n\n        let collab4 = ChannelCollaborator {\n            role: Role::Publisher,\n            share: Decimal::percent(70), // 70%\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id2.clone(),\n            addr4.clone(),\n            collab4,\n        );\n        assert!(result.is_ok());\n\n        // Verify shares for channel 1\n        let shares1 = channels\n            .get_collaborator_shares(\u0026deps.storage, channel_id1.clone())\n            .unwrap();\n        assert_eq!(shares1.len(), 2);\n        assert!(shares1.contains(\u0026(addr1.clone(), Decimal::percent(50))));\n        assert!(shares1.contains(\u0026(addr2.clone(), Decimal::percent(50))));\n\n        // Verify shares for channel 2\n        let shares2 = channels\n            .get_collaborator_shares(\u0026deps.storage, channel_id2.clone())\n            .unwrap();\n        assert_eq!(shares2.len(), 2);\n        assert!(shares2.contains(\u0026(addr3.clone(), Decimal::percent(30))));\n        assert!(shares2.contains(\u0026(addr4.clone(), Decimal::percent(70))));\n\n        // Test removing collaborator from channel 1 doesn't affect channel 2\n        let result =\n            channels.remove_collaborator(\u0026mut deps.storage, channel_id1.clone(), addr1.clone());\n        assert!(result.is_ok());\n\n        // Verify channel 1 shares updated\n        let shares1_after = channels\n            .get_collaborator_shares(\u0026deps.storage, channel_id1.clone())\n            .unwrap();\n        assert_eq!(shares1_after.len(), 1);\n        assert!(shares1_after.contains(\u0026(addr2.clone(), Decimal::percent(50))));\n\n        // Verify channel 2 shares unchanged\n        let shares2_after = channels\n            .get_collaborator_shares(\u0026deps.storage, channel_id2.clone())\n            .unwrap();\n        assert_eq!(shares2_after.len(), 2);\n        assert!(shares2_after.contains(\u0026(addr3.clone(), Decimal::percent(30))));\n        assert!(shares2_after.contains(\u0026(addr4.clone(), Decimal::percent(70))));\n    }\n\n    #[test]\n    fn test_add_collaborator_overflow() {\n        let mut deps = mock_dependencies();\n        let channels = ChannelsManager::new();\n        let channel_id = \"channel1\".to_string();\n        let addr1 = Addr::unchecked(\"addr1\");\n        let addr2 = Addr::unchecked(\"addr2\");\n        let addr3 = Addr::unchecked(\"addr3\");\n\n        // Create channel\n        let channel_details = ChannelDetails {\n            channel_id: channel_id.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user1\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id.clone(),\n                channel_details,\n                ChannelMetadata {\n                    channel_name: \"channel1\".to_string(),\n                    description: Some(\"description1\".to_string()),\n                    profile_picture: Some(\"profile_picture1\".to_string()),\n                    banner_picture: Some(\"banner_picture1\".to_string()),\n                },\n            )\n            .unwrap();\n\n        // Add first collaborator\n        let collab1 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50),\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr1.clone(),\n            collab1,\n        );\n        assert!(result.is_ok());\n\n        // Now we are at 50%\n        // Add another collaborator with 50% share. This should work\n        let collab2 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50),\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr2.clone(),\n            collab2,\n        );\n        assert!(result.is_ok());\n\n        // Add another collaborator with 50% share. This should overflow\n        let collab3 = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50),\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr3.clone(),\n            collab3,\n        );\n        assert_eq!(result.unwrap_err(), ChannelError::InvalidSharePercentage {});\n    }\n\n    #[test]\n    fn test_duplicate_collaborator() {\n        let mut deps = mock_dependencies();\n        let channels = ChannelsManager::new();\n        let channel_id = \"channel1\".to_string();\n        let addr1 = Addr::unchecked(\"addr1\");\n\n        // Create channel\n        let channel_details = ChannelDetails {\n            channel_id: channel_id.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user1\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id.clone(),\n                channel_details,\n                ChannelMetadata {\n                    channel_name: \"channel1\".to_string(),\n                    description: Some(\"description1\".to_string()),\n                    profile_picture: Some(\"profile_picture1\".to_string()),\n                    banner_picture: Some(\"banner_picture1\".to_string()),\n                },\n            )\n            .unwrap();\n\n        // Add first collaborator\n        let collab = ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(50),\n        };\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr1.clone(),\n            collab.clone(),\n        );\n        assert!(result.is_ok());\n\n        // Try to add same collaborator again\n        let result = channels.add_collaborator(\n            \u0026mut deps.storage,\n            channel_id.clone(),\n            addr1.clone(),\n            collab.clone(),\n        );\n        assert!(matches!(result, Err(ChannelError::CollaboratorExists {})));\n    }\n\n    #[test]\n    fn test_follower_operations() {\n        let mut deps = mock_dependencies();\n        let channels = ChannelsManager::new();\n        let channel_id = \"channel1\".to_string();\n        let follower1 = deps.api.addr_make(\"follower1\");\n        let follower2 = deps.api.addr_make(\"follower2\");\n        let non_follower = deps.api.addr_make(\"non_follower\");\n\n        // Create channel\n        let channel_details = ChannelDetails {\n            channel_id: channel_id.clone(),\n            onft_id: \"\".to_string(),\n            payment_address: Addr::unchecked(\"payment_address\"),\n            user_name: \"user1\".to_string(),\n        };\n        channels\n            .add_channel(\n                \u0026mut deps.storage,\n                channel_id.clone(),\n                channel_details,\n                ChannelMetadata {\n                    channel_name: \"channel1\".to_string(),\n                    description: Some(\"description1\".to_string()),\n                    profile_picture: Some(\"profile_picture1\".to_string()),\n                    banner_picture: Some(\"banner_picture1\".to_string()),\n                },\n            )\n            .unwrap();\n\n        // Test initial followers count\n        let count = channels\n            .get_followers_count(\u0026deps.storage, channel_id.clone())\n            .unwrap();\n        assert_eq!(count, 0);\n\n        // Test adding followers\n        let result =\n            channels.add_follower(\u0026mut deps.storage, channel_id.clone(), follower1.clone());\n        assert!(result.is_ok());\n        let result =\n            channels.add_follower(\u0026mut deps.storage, channel_id.clone(), follower2.clone());\n        assert!(result.is_ok());\n\n        // Test followers count after adding\n        let count = channels\n            .get_followers_count(\u0026deps.storage, channel_id.clone())\n            .unwrap();\n        assert_eq!(count, 2);\n\n        // Test is_follower\n        assert!(channels\n            .is_follower(\u0026deps.storage, channel_id.clone(), follower1.clone())\n            .unwrap());\n        assert!(channels\n            .is_follower(\u0026deps.storage, channel_id.clone(), follower2.clone())\n            .unwrap());\n        assert!(!channels\n            .is_follower(\u0026deps.storage, channel_id.clone(), non_follower.clone())\n            .unwrap());\n\n        // Test get_followers\n        let followers = channels\n            .get_followers(\u0026deps.storage, channel_id.clone(), None, None)\n            .unwrap();\n        assert_eq!(followers.len(), 2);\n        assert!(followers.contains(\u0026follower1));\n        assert!(followers.contains(\u0026follower2));\n\n        // Test removing follower\n        let result =\n            channels.remove_follower(\u0026mut deps.storage, channel_id.clone(), follower1.clone());\n        assert!(result.is_ok());\n\n        // Test followers count after removing\n        let count = channels\n            .get_followers_count(\u0026deps.storage, channel_id.clone())\n            .unwrap();\n        assert_eq!(count, 1);\n\n        // Test removing non-existent follower\n        let result =\n            channels.remove_follower(\u0026mut deps.storage, channel_id.clone(), non_follower.clone());\n        assert!(matches!(result, Err(ChannelError::FollowerNotFound {})));\n\n        // Verify remaining followers\n        let followers = channels\n            .get_followers(\u0026deps.storage, channel_id.clone(), None, None)\n            .unwrap();\n        assert_eq!(followers.len(), 1);\n        assert!(followers.contains(\u0026follower2));\n        assert!(!followers.contains(\u0026follower1));\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":496}},{"line":39,"address":[],"length":0,"stats":{"Line":496}},{"line":40,"address":[],"length":0,"stats":{"Line":496}},{"line":41,"address":[],"length":0,"stats":{"Line":496}},{"line":42,"address":[],"length":0,"stats":{"Line":496}},{"line":43,"address":[],"length":0,"stats":{"Line":496}},{"line":44,"address":[],"length":0,"stats":{"Line":496}},{"line":45,"address":[],"length":0,"stats":{"Line":496}},{"line":46,"address":[],"length":0,"stats":{"Line":496}},{"line":47,"address":[],"length":0,"stats":{"Line":496}},{"line":51,"address":[],"length":0,"stats":{"Line":74}},{"line":56,"address":[],"length":0,"stats":{"Line":224}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":74}},{"line":63,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":11}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":3}},{"line":75,"address":[],"length":0,"stats":{"Line":3}},{"line":78,"address":[],"length":0,"stats":{"Line":8}},{"line":84,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":8}},{"line":87,"address":[],"length":0,"stats":{"Line":8}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":8}},{"line":90,"address":[],"length":0,"stats":{"Line":8}},{"line":91,"address":[],"length":0,"stats":{"Line":17}},{"line":92,"address":[],"length":0,"stats":{"Line":18}},{"line":93,"address":[],"length":0,"stats":{"Line":9}},{"line":94,"address":[],"length":0,"stats":{"Line":9}},{"line":99,"address":[],"length":0,"stats":{"Line":8}},{"line":102,"address":[],"length":0,"stats":{"Line":59}},{"line":108,"address":[],"length":0,"stats":{"Line":59}},{"line":109,"address":[],"length":0,"stats":{"Line":56}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":62}},{"line":124,"address":[],"length":0,"stats":{"Line":62}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":62}},{"line":128,"address":[],"length":0,"stats":{"Line":62}},{"line":129,"address":[],"length":0,"stats":{"Line":62}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":61}},{"line":136,"address":[],"length":0,"stats":{"Line":61}},{"line":137,"address":[],"length":0,"stats":{"Line":61}},{"line":138,"address":[],"length":0,"stats":{"Line":61}},{"line":139,"address":[],"length":0,"stats":{"Line":61}},{"line":140,"address":[],"length":0,"stats":{"Line":61}},{"line":141,"address":[],"length":0,"stats":{"Line":61}},{"line":142,"address":[],"length":0,"stats":{"Line":61}},{"line":143,"address":[],"length":0,"stats":{"Line":61}},{"line":144,"address":[],"length":0,"stats":{"Line":61}},{"line":145,"address":[],"length":0,"stats":{"Line":61}},{"line":146,"address":[],"length":0,"stats":{"Line":61}},{"line":148,"address":[],"length":0,"stats":{"Line":61}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":1}},{"line":162,"address":[],"length":0,"stats":{"Line":1}},{"line":163,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":170,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":1}},{"line":180,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":1}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":1}},{"line":185,"address":[],"length":0,"stats":{"Line":5}},{"line":189,"address":[],"length":0,"stats":{"Line":311}},{"line":194,"address":[],"length":0,"stats":{"Line":311}},{"line":195,"address":[],"length":0,"stats":{"Line":311}},{"line":196,"address":[],"length":0,"stats":{"Line":626}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":5}},{"line":218,"address":[],"length":0,"stats":{"Line":5}},{"line":219,"address":[],"length":0,"stats":{"Line":5}},{"line":220,"address":[],"length":0,"stats":{"Line":10}},{"line":223,"address":[],"length":0,"stats":{"Line":1}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":235,"address":[],"length":0,"stats":{"Line":2}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":260,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":24}},{"line":278,"address":[],"length":0,"stats":{"Line":24}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":24}},{"line":283,"address":[],"length":0,"stats":{"Line":24}},{"line":284,"address":[],"length":0,"stats":{"Line":24}},{"line":286,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":23}},{"line":291,"address":[],"length":0,"stats":{"Line":23}},{"line":292,"address":[],"length":0,"stats":{"Line":23}},{"line":293,"address":[],"length":0,"stats":{"Line":23}},{"line":294,"address":[],"length":0,"stats":{"Line":23}},{"line":297,"address":[],"length":0,"stats":{"Line":23}},{"line":298,"address":[],"length":0,"stats":{"Line":23}},{"line":299,"address":[],"length":0,"stats":{"Line":23}},{"line":300,"address":[],"length":0,"stats":{"Line":23}},{"line":302,"address":[],"length":0,"stats":{"Line":23}},{"line":303,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":22}},{"line":308,"address":[],"length":0,"stats":{"Line":2}},{"line":312,"address":[],"length":0,"stats":{"Line":20}},{"line":313,"address":[],"length":0,"stats":{"Line":20}},{"line":314,"address":[],"length":0,"stats":{"Line":20}},{"line":316,"address":[],"length":0,"stats":{"Line":20}},{"line":317,"address":[],"length":0,"stats":{"Line":20}},{"line":318,"address":[],"length":0,"stats":{"Line":20}},{"line":320,"address":[],"length":0,"stats":{"Line":20}},{"line":323,"address":[],"length":0,"stats":{"Line":1}},{"line":330,"address":[],"length":0,"stats":{"Line":1}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":1}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":336,"address":[],"length":0,"stats":{"Line":1}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":1}},{"line":346,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":1}},{"line":349,"address":[],"length":0,"stats":{"Line":1}},{"line":350,"address":[],"length":0,"stats":{"Line":1}},{"line":351,"address":[],"length":0,"stats":{"Line":1}},{"line":352,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":354,"address":[],"length":0,"stats":{"Line":1}},{"line":355,"address":[],"length":0,"stats":{"Line":1}},{"line":356,"address":[],"length":0,"stats":{"Line":1}},{"line":358,"address":[],"length":0,"stats":{"Line":6}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":6}},{"line":369,"address":[],"length":0,"stats":{"Line":6}},{"line":370,"address":[],"length":0,"stats":{"Line":6}},{"line":371,"address":[],"length":0,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":20}},{"line":373,"address":[],"length":0,"stats":{"Line":20}},{"line":375,"address":[],"length":0,"stats":{"Line":6}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":386,"address":[],"length":0,"stats":{"Line":0}},{"line":389,"address":[],"length":0,"stats":{"Line":0}},{"line":390,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":12}},{"line":401,"address":[],"length":0,"stats":{"Line":12}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":405,"address":[],"length":0,"stats":{"Line":12}},{"line":406,"address":[],"length":0,"stats":{"Line":12}},{"line":407,"address":[],"length":0,"stats":{"Line":12}},{"line":408,"address":[],"length":0,"stats":{"Line":12}},{"line":409,"address":[],"length":0,"stats":{"Line":10}},{"line":411,"address":[],"length":0,"stats":{"Line":2}},{"line":414,"address":[],"length":0,"stats":{"Line":1}},{"line":422,"address":[],"length":0,"stats":{"Line":1}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":1}},{"line":427,"address":[],"length":0,"stats":{"Line":2}},{"line":429,"address":[],"length":0,"stats":{"Line":1}},{"line":430,"address":[],"length":0,"stats":{"Line":1}},{"line":431,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":1}},{"line":433,"address":[],"length":0,"stats":{"Line":1}},{"line":434,"address":[],"length":0,"stats":{"Line":1}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":1}},{"line":446,"address":[],"length":0,"stats":{"Line":6}},{"line":453,"address":[],"length":0,"stats":{"Line":6}},{"line":454,"address":[],"length":0,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":5}},{"line":458,"address":[],"length":0,"stats":{"Line":5}},{"line":459,"address":[],"length":0,"stats":{"Line":5}},{"line":461,"address":[],"length":0,"stats":{"Line":1}},{"line":464,"address":[],"length":0,"stats":{"Line":4}},{"line":465,"address":[],"length":0,"stats":{"Line":4}},{"line":466,"address":[],"length":0,"stats":{"Line":4}},{"line":468,"address":[],"length":0,"stats":{"Line":4}},{"line":469,"address":[],"length":0,"stats":{"Line":4}},{"line":470,"address":[],"length":0,"stats":{"Line":4}},{"line":472,"address":[],"length":0,"stats":{"Line":4}},{"line":473,"address":[],"length":0,"stats":{"Line":4}},{"line":474,"address":[],"length":0,"stats":{"Line":4}},{"line":475,"address":[],"length":0,"stats":{"Line":4}},{"line":478,"address":[],"length":0,"stats":{"Line":2}},{"line":485,"address":[],"length":0,"stats":{"Line":2}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":2}},{"line":490,"address":[],"length":0,"stats":{"Line":2}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":493,"address":[],"length":0,"stats":{"Line":1}},{"line":495,"address":[],"length":0,"stats":{"Line":1}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":498,"address":[],"length":0,"stats":{"Line":1}},{"line":499,"address":[],"length":0,"stats":{"Line":1}},{"line":500,"address":[],"length":0,"stats":{"Line":1}},{"line":502,"address":[],"length":0,"stats":{"Line":1}},{"line":503,"address":[],"length":0,"stats":{"Line":1}},{"line":504,"address":[],"length":0,"stats":{"Line":1}},{"line":505,"address":[],"length":0,"stats":{"Line":1}},{"line":508,"address":[],"length":0,"stats":{"Line":5}},{"line":514,"address":[],"length":0,"stats":{"Line":5}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":5}},{"line":518,"address":[],"length":0,"stats":{"Line":5}},{"line":519,"address":[],"length":0,"stats":{"Line":5}},{"line":521,"address":[],"length":0,"stats":{"Line":5}},{"line":524,"address":[],"length":0,"stats":{"Line":3}},{"line":531,"address":[],"length":0,"stats":{"Line":3}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":3}},{"line":535,"address":[],"length":0,"stats":{"Line":3}},{"line":536,"address":[],"length":0,"stats":{"Line":3}},{"line":537,"address":[],"length":0,"stats":{"Line":3}},{"line":540,"address":[],"length":0,"stats":{"Line":3}},{"line":547,"address":[],"length":0,"stats":{"Line":3}},{"line":548,"address":[],"length":0,"stats":{"Line":6}},{"line":550,"address":[],"length":0,"stats":{"Line":3}},{"line":551,"address":[],"length":0,"stats":{"Line":3}},{"line":552,"address":[],"length":0,"stats":{"Line":3}},{"line":553,"address":[],"length":0,"stats":{"Line":3}},{"line":554,"address":[],"length":0,"stats":{"Line":3}},{"line":557,"address":[],"length":0,"stats":{"Line":3}}],"covered":211,"coverable":251},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","channel-manager","src","error.rs"],"content":"use thiserror::Error;\n\n#[derive(Error, Debug, PartialEq)]\npub enum ChannelError {\n    #[error(\"Channel ID not found\")]\n    ChannelIdNotFound {},\n\n    #[error(\"Channel ID already exists\")]\n    ChannelIdAlreadyExists {},\n\n    #[error(\"User name not found\")]\n    UserNameNotFound {},\n\n    #[error(\"User name already taken\")]\n    UserNameAlreadyTaken {},\n\n    #[error(\"Saving channel details failed\")]\n    SaveChannelDetailsFailed {},\n\n    #[error(\"Saving reserved usernames failed\")]\n    SaveReservedUsernamesFailed {},\n\n    #[error(\"Reserved username not found\")]\n    UsernameNotReserved {},\n\n    #[error(\"Collaborator already exists\")]\n    CollaboratorExists {},\n\n    #[error(\"Invalid share percentage\")]\n    InvalidSharePercentage {},\n\n    #[error(\"Collaborator not found\")]\n    CollaboratorNotFound {},\n\n    #[error(\"Collaborator expired\")]\n    CollaboratorExpired {},\n\n    #[error(\"Total unique collaborators limit exceeded\")]\n    TotalUniqueCollaboratorsLimitExceeded {},\n\n    #[error(\"Follower not found\")]\n    FollowerNotFound {},\n\n    #[error(\"Already following\")]\n    AlreadyFollowing {},\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","channel-manager","src","lib.rs"],"content":"pub mod channel;\npub mod error;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","pauser","src","lib.rs"],"content":"use cosmwasm_std::{Addr, StdError, Storage};\nuse cw_storage_plus::Item;\nuse thiserror::Error;\n\npub const PAUSED_KEY: \u0026str = \"paused\";\npub const PAUSERS_KEY: \u0026str = \"pausers\";\n\n#[derive(Error, Debug, PartialEq)]\npub enum PauseError {\n    #[error(transparent)]\n    Std(#[from] StdError),\n\n    #[error(\"contract is paused\")]\n    Paused {},\n\n    #[error(\"unauthorized pauser ({sender})\")]\n    Unauthorized { sender: Addr },\n}\n\npub struct PauseState {\n    pub paused: Item\u003cbool\u003e,\n    pub pausers: Item\u003cVec\u003cAddr\u003e\u003e,\n}\n\nimpl PauseState {\n    /// Creates a new pause orchestrator using the provided storage\n    /// keys.\n    pub fn new() -\u003e Result\u003cSelf, PauseError\u003e {\n        // Initiate the storage items empty\n        let paused = Item::new(PAUSED_KEY);\n        let pausers = Item::new(PAUSERS_KEY);\n        Ok(PauseState { paused, pausers })\n    }\n\n    /// Sets a new pauser who may pause the contract.\n    /// If no pausers are set, sets pausers to the provided addresses without authorization.\n    /// If pausers are already set, sender must be one of the pausers.\n    /// Also unpauses\n    pub fn set_pausers(\n        \u0026self,\n        storage: \u0026mut dyn Storage,\n        sender: Addr,\n        pausers: Vec\u003cAddr\u003e,\n    ) -\u003e Result\u003c(), PauseError\u003e {\n        let mut current_pausers = self.pausers.load(storage).unwrap_or_default();\n        if current_pausers.is_empty() {\n            current_pausers = pausers;\n        } else {\n            self.error_if_unauthorized(storage, \u0026sender)?;\n            current_pausers = pausers;\n        }\n        self.pausers.save(storage, \u0026current_pausers)?;\n        self.paused.save(storage, \u0026false)?;\n        Ok(())\n    }\n\n    /// Errors if the module is paused, does nothing otherwise.\n    pub fn error_if_paused(\u0026self, storage: \u0026dyn Storage) -\u003e Result\u003c(), PauseError\u003e {\n        if self.paused.load(storage)? {\n            Err(PauseError::Paused {})\n        } else {\n            Ok(())\n        }\n    }\n    pub fn error_if_unauthorized(\n        \u0026self,\n        storage: \u0026dyn Storage,\n        sender: \u0026Addr,\n    ) -\u003e Result\u003c(), PauseError\u003e {\n        let pausers = self.pausers.load(storage)?;\n        if !pausers.contains(sender) {\n            Err(PauseError::Unauthorized {\n                sender: sender.clone(),\n            })\n        } else {\n            Ok(())\n        }\n    }\n\n    pub fn pause(\u0026self, storage: \u0026mut dyn Storage, sender: \u0026Addr) -\u003e Result\u003c(), PauseError\u003e {\n        self.error_if_paused(storage)?;\n        self.error_if_unauthorized(storage, sender)?;\n        self.paused.save(storage, \u0026true)?;\n        Ok(())\n    }\n\n    pub fn unpause(\u0026self, storage: \u0026mut dyn Storage, sender: \u0026Addr) -\u003e Result\u003c(), PauseError\u003e {\n        self.error_if_unauthorized(storage, sender)?;\n        self.paused.save(storage, \u0026false)?;\n        Ok(())\n    }\n\n    pub fn is_paused(\u0026self, storage: \u0026dyn Storage) -\u003e Result\u003cbool, PauseError\u003e {\n        let is_paused = self.paused.load(storage).unwrap_or(false);\n        Ok(is_paused)\n    }\n\n    pub fn get_pausers(\u0026self, storage: \u0026dyn Storage) -\u003e Result\u003cVec\u003cAddr\u003e, PauseError\u003e {\n        let pausers = self.pausers.load(storage).unwrap_or_default();\n        Ok(pausers)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use cosmwasm_std::testing::mock_dependencies;\n\n    #[test]\n    fn test_pause_state() {\n        let mut deps = mock_dependencies();\n\n        let pauser1 = Addr::unchecked(\"pauser1\");\n        let pauser2 = Addr::unchecked(\"pauser2\");\n        let pauser3 = Addr::unchecked(\"pauser3\");\n\n        let state = PauseState::new().unwrap();\n\n        // no pausers set\n        assert_eq!(\n            state.set_pausers(\u0026mut deps.storage, pauser1.clone(), vec![]),\n            Ok(())\n        );\n        assert_eq!(\n            state.set_pausers(\u0026mut deps.storage, pauser2.clone(), vec![]),\n            Ok(())\n        );\n        assert_eq!(\n            state.set_pausers(\u0026mut deps.storage, pauser3.clone(), vec![]),\n            Ok(())\n        );\n\n        // pausers set\n        assert_eq!(\n            state.set_pausers(\n                \u0026mut deps.storage,\n                pauser1.clone(),\n                vec![pauser1.clone(), pauser2.clone()]\n            ),\n            Ok(())\n        );\n\n        assert_eq!(\n            state.set_pausers(\n                \u0026mut deps.storage,\n                pauser2.clone(),\n                vec![pauser1.clone(), pauser2.clone()]\n            ),\n            Ok(())\n        );\n        assert_eq!(\n            state.set_pausers(\n                \u0026mut deps.storage,\n                pauser3.clone(),\n                vec![pauser1.clone(), pauser2.clone()]\n            ),\n            Err(PauseError::Unauthorized {\n                sender: pauser3.clone()\n            })\n        );\n\n        // pause\n        assert_eq!(state.pause(\u0026mut deps.storage, \u0026pauser1), Ok(()));\n        assert_eq!(\n            state.pause(\u0026mut deps.storage, \u0026pauser2),\n            Err(PauseError::Paused {})\n        );\n        assert_eq!(\n            state.pause(\u0026mut deps.storage, \u0026pauser3.clone()),\n            Err(PauseError::Paused {})\n        );\n\n        // unpause\n        assert_eq!(state.unpause(\u0026mut deps.storage, \u0026pauser1), Ok(()));\n        assert_eq!(state.unpause(\u0026mut deps.storage, \u0026pauser2), Ok(()));\n        assert_eq!(\n            state.unpause(\u0026mut deps.storage, \u0026pauser3),\n            Err(PauseError::Unauthorized { sender: pauser3 })\n        );\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":440}},{"line":30,"address":[],"length":0,"stats":{"Line":440}},{"line":31,"address":[],"length":0,"stats":{"Line":440}},{"line":32,"address":[],"length":0,"stats":{"Line":440}},{"line":39,"address":[],"length":0,"stats":{"Line":78}},{"line":45,"address":[],"length":0,"stats":{"Line":78}},{"line":46,"address":[],"length":0,"stats":{"Line":154}},{"line":47,"address":[],"length":0,"stats":{"Line":76}},{"line":49,"address":[],"length":0,"stats":{"Line":3}},{"line":50,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":77}},{"line":53,"address":[],"length":0,"stats":{"Line":77}},{"line":54,"address":[],"length":0,"stats":{"Line":77}},{"line":58,"address":[],"length":0,"stats":{"Line":370}},{"line":59,"address":[],"length":0,"stats":{"Line":370}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[],"length":0,"stats":{"Line":366}},{"line":65,"address":[],"length":0,"stats":{"Line":8}},{"line":70,"address":[],"length":0,"stats":{"Line":16}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":2}},{"line":76,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":5}},{"line":81,"address":[],"length":0,"stats":{"Line":7}},{"line":82,"address":[],"length":0,"stats":{"Line":3}},{"line":83,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":3}},{"line":87,"address":[],"length":0,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":4}},{"line":89,"address":[],"length":0,"stats":{"Line":2}},{"line":90,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}}],"covered":31,"coverable":37},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","testing","src","app.rs"],"content":"use std::ops::{Deref, DerefMut};\n\nuse crate::stargate::StargateKeeper;\nuse cosmwasm_std::{testing::MockApi, Empty, GovMsg, IbcMsg, IbcQuery, MemoryStorage};\nuse cw_multi_test::{no_init, App, AppBuilder, BankKeeper, FailingModule, WasmKeeper};\n\n#[allow(clippy::type_complexity)]\npub struct OmniflixApp(\n    App\u003c\n        BankKeeper,\n        MockApi,\n        MemoryStorage,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        WasmKeeper\u003cEmpty, Empty\u003e,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        FailingModule\u003cIbcMsg, IbcQuery, Empty\u003e,\n        FailingModule\u003cGovMsg, Empty, Empty\u003e,\n        StargateKeeper,\n    \u003e,\n);\n\nimpl Deref for OmniflixApp {\n    type Target = App\u003c\n        BankKeeper,\n        MockApi,\n        MemoryStorage,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        WasmKeeper\u003cEmpty, Empty\u003e,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        FailingModule\u003cEmpty, Empty, Empty\u003e,\n        FailingModule\u003cIbcMsg, IbcQuery, Empty\u003e,\n        FailingModule\u003cGovMsg, Empty, Empty\u003e,\n        StargateKeeper,\n    \u003e;\n\n    fn deref(\u0026self) -\u003e \u0026Self::Target {\n        \u0026self.0\n    }\n}\n\nimpl DerefMut for OmniflixApp {\n    fn deref_mut(\u0026mut self) -\u003e \u0026mut Self::Target {\n        \u0026mut self.0\n    }\n}\n\nimpl Default for OmniflixApp {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl OmniflixApp {\n    pub fn new() -\u003e Self {\n        let stargate = StargateKeeper {};\n        let app_builder = AppBuilder::new();\n        let app = app_builder.with_stargate(stargate).build(no_init);\n        OmniflixApp(app)\n    }\n}\n","traces":[{"line":37,"address":[],"length":0,"stats":{"Line":57}},{"line":38,"address":[],"length":0,"stats":{"Line":57}},{"line":43,"address":[],"length":0,"stats":{"Line":1087}},{"line":44,"address":[],"length":0,"stats":{"Line":1087}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":70}},{"line":56,"address":[],"length":0,"stats":{"Line":70}},{"line":57,"address":[],"length":0,"stats":{"Line":70}},{"line":58,"address":[],"length":0,"stats":{"Line":70}},{"line":59,"address":[],"length":0,"stats":{"Line":70}}],"covered":9,"coverable":11},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","testing","src","lib.rs"],"content":"pub mod app;\npub mod stargate;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","testing","src","stargate.rs"],"content":"use anyhow::{bail, Result};\nuse cosmwasm_std::{from_json, to_json_binary, Addr, Api, Binary, BlockInfo, Querier, Storage};\nuse cw_multi_test::{error::AnyResult, AppResponse, CosmosRouter, Stargate};\nuse omniflix_std::types::omniflix::onft::v1beta1::{\n    Collection, Denom, MsgCreateDenom, MsgMintOnft, QueryOnftRequest, QueryOnftResponse,\n};\nuse omniflix_std::types::{\n    cosmos::base::v1beta1::Coin,\n    omniflix::onft::v1beta1::{Onft, Params, QueryParamsResponse},\n};\nuse prost::{DecodeError, Message};\n\nconst COLLECTION_PREFIX: \u0026str = \"collection\";\n\npub struct StargateKeeper {}\n\nimpl StargateKeeper {}\n\nimpl Stargate for StargateKeeper {\n    fn execute_stargate\u003cExecC, QueryC\u003e(\n        \u0026self,\n        _api: \u0026dyn Api,\n        storage: \u0026mut dyn Storage,\n        _router: \u0026dyn CosmosRouter\u003cExecC = ExecC, QueryC = QueryC\u003e,\n        _block: \u0026BlockInfo,\n        sender: Addr,\n        type_url: String,\n        value: Binary,\n    ) -\u003e AnyResult\u003cAppResponse\u003e {\n        if type_url == *\"/OmniFlix.onft.v1beta1.MsgCreateDenom\" {\n            let parsed_msg: Result\u003cMsgCreateDenom, DecodeError\u003e = Message::decode(value.as_slice());\n            if let Ok(msg) = parsed_msg {\n                let collection = Collection {\n                    denom: Some(Denom {\n                        creator: sender.to_string(),\n                        data: msg.data,\n                        name: msg.name,\n                        id: msg.id.clone(),\n                        preview_uri: msg.preview_uri,\n                        description: msg.description,\n                        schema: msg.schema,\n                        symbol: msg.symbol,\n                        uri: msg.uri,\n                        uri_hash: msg.uri_hash,\n                        royalty_receivers: msg.royalty_receivers,\n                    }),\n                    onfts: vec![],\n                };\n                let key = format!(\"collections:{}:{}\", COLLECTION_PREFIX, msg.id);\n                let serialized_collection =\n                    to_json_binary(\u0026collection).expect(\"Failed to serialize Collection\");\n                storage.set(key.as_bytes(), \u0026serialized_collection);\n            }\n        }\n        if type_url == *\"/OmniFlix.onft.v1beta1.MsgMintONFT\" {\n            let parsed_msg: Result\u003cMsgMintOnft, DecodeError\u003e = Message::decode(value.as_slice());\n            if let Ok(msg) = parsed_msg {\n                let key = format!(\"collections:{}:{}\", COLLECTION_PREFIX, msg.denom_id);\n                let serialized_collection = storage.get(key.as_bytes());\n                let mut collection: Collection = from_json(serialized_collection.unwrap())\n                    .expect(\"Failed to deserialize Collection\");\n                let onft = Onft {\n                    id: msg.id,\n                    created_at: None,\n                    nsfw: msg.nsfw,\n                    owner: msg.recipient,\n                    data: msg.data,\n                    transferable: msg.transferable,\n                    extensible: msg.extensible,\n                    metadata: msg.metadata,\n                    royalty_share: msg.royalty_share,\n                };\n                collection.onfts.push(onft);\n                let serialized_collection =\n                    to_json_binary(\u0026collection).expect(\"Failed to serialize Collection\");\n                storage.set(key.as_bytes(), \u0026serialized_collection);\n            };\n        }\n        Ok(AppResponse::default())\n    }\n\n    fn query_stargate(\n        \u0026self,\n        _api: \u0026dyn Api,\n        storage: \u0026dyn Storage,\n        _querier: \u0026dyn Querier,\n        _block: \u0026BlockInfo,\n        path: String,\n        data: Binary,\n    ) -\u003e AnyResult\u003cBinary\u003e {\n        if path == *\"/OmniFlix.onft.v1beta1.Query/Params\" {\n            let params = QueryParamsResponse {\n                params: Some(Params {\n                    denom_creation_fee: Some(Coin {\n                        denom: \"uflix\".to_string(),\n                        amount: \"1000000\".to_string(),\n                    }),\n                }),\n            };\n            return Ok(to_json_binary(\u0026params)?);\n        }\n        if path == *\"/OmniFlix.onft.v1beta1.Query/ONFT\" {\n            let query_msg: Result\u003cQueryOnftRequest, DecodeError\u003e = Message::decode(data.as_slice());\n            if let Ok(msg) = query_msg {\n                let key = format!(\"collections:{}:{}\", COLLECTION_PREFIX, msg.denom_id);\n                let serialized_collection = storage.get(key.as_bytes());\n                if serialized_collection.is_none() {\n                    return Ok(to_json_binary(\u0026QueryOnftResponse { onft: None })?);\n                }\n                let collection: Collection = from_json(serialized_collection.unwrap())\n                    .expect(\"Failed to deserialize Collection\");\n                let onft = collection\n                    .onfts\n                    .iter()\n                    .find(|onft| onft.id == msg.id)\n                    .expect(\"Onft not found\");\n                let response = QueryOnftResponse {\n                    onft: Some(onft.clone()),\n                };\n                return Ok(to_json_binary(\u0026response)?);\n            }\n        }\n        Ok(data)\n    }\n\n    fn execute_any\u003cExecC, QueryC\u003e(\n        \u0026self,\n        _api: \u0026dyn Api,\n        _storage: \u0026mut dyn Storage,\n        _router: \u0026dyn CosmosRouter\u003cExecC = ExecC, QueryC = QueryC\u003e,\n        _block: \u0026BlockInfo,\n        _sender: Addr,\n        _msg: cosmwasm_std::AnyMsg,\n    ) -\u003e AnyResult\u003cAppResponse\u003e\n    where\n        ExecC: cosmwasm_std::CustomMsg + serde::de::DeserializeOwned + 'static,\n        QueryC: cosmwasm_std::CustomQuery + serde::de::DeserializeOwned + 'static,\n    {\n        bail!(\"execute_any not implemented\")\n    }\n\n    fn query_grpc(\n        \u0026self,\n        _api: \u0026dyn Api,\n        _storage: \u0026dyn Storage,\n        _querier: \u0026dyn Querier,\n        _block: \u0026BlockInfo,\n        _request: cosmwasm_std::GrpcQuery,\n    ) -\u003e AnyResult\u003cBinary\u003e {\n        bail!(\"query_grpc not implemented\")\n    }\n}\n","traces":[{"line":20,"address":[],"length":0,"stats":{"Line":152}},{"line":30,"address":[],"length":0,"stats":{"Line":152}},{"line":31,"address":[],"length":0,"stats":{"Line":83}},{"line":32,"address":[],"length":0,"stats":{"Line":166}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":152}},{"line":56,"address":[],"length":0,"stats":{"Line":69}},{"line":57,"address":[],"length":0,"stats":{"Line":207}},{"line":58,"address":[],"length":0,"stats":{"Line":69}},{"line":59,"address":[],"length":0,"stats":{"Line":69}},{"line":60,"address":[],"length":0,"stats":{"Line":69}},{"line":63,"address":[],"length":0,"stats":{"Line":69}},{"line":65,"address":[],"length":0,"stats":{"Line":69}},{"line":66,"address":[],"length":0,"stats":{"Line":69}},{"line":67,"address":[],"length":0,"stats":{"Line":69}},{"line":68,"address":[],"length":0,"stats":{"Line":69}},{"line":69,"address":[],"length":0,"stats":{"Line":69}},{"line":70,"address":[],"length":0,"stats":{"Line":69}},{"line":71,"address":[],"length":0,"stats":{"Line":69}},{"line":73,"address":[],"length":0,"stats":{"Line":69}},{"line":74,"address":[],"length":0,"stats":{"Line":69}},{"line":75,"address":[],"length":0,"stats":{"Line":69}},{"line":76,"address":[],"length":0,"stats":{"Line":69}},{"line":79,"address":[],"length":0,"stats":{"Line":152}},{"line":82,"address":[],"length":0,"stats":{"Line":384}},{"line":91,"address":[],"length":0,"stats":{"Line":384}},{"line":93,"address":[],"length":0,"stats":{"Line":72}},{"line":100,"address":[],"length":0,"stats":{"Line":72}},{"line":102,"address":[],"length":0,"stats":{"Line":312}},{"line":103,"address":[],"length":0,"stats":{"Line":312}},{"line":104,"address":[],"length":0,"stats":{"Line":624}},{"line":108,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":311}},{"line":112,"address":[],"length":0,"stats":{"Line":311}},{"line":113,"address":[],"length":0,"stats":{"Line":311}},{"line":115,"address":[],"length":0,"stats":{"Line":624}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}}],"covered":35,"coverable":47},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","asset.rs"],"content":"use cosmwasm_schema::cw_serde;\n\nuse crate::channel::ChannelId;\n\npub type PublishId = String;\n/// Used to identify an asset over a channel and all contract\npub type AssetKey = (ChannelId, PublishId);\n/// Used to identify a flags of assets\npub type FlagKey = (String, AssetKey);\n\n#[cw_serde]\npub struct Playlist {\n    pub playlist_name: String,\n    pub assets: Vec\u003cAssetKey\u003e,\n}\n\n#[cw_serde]\npub enum AssetSource {\n    Nft {\n        collection_id: String,\n        onft_id: String,\n    },\n    OffChain {},\n}\n\n// Implement to string for AssetSource\nimpl std::fmt::Display for AssetSource {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            AssetSource::Nft {\n                collection_id,\n                onft_id,\n            } =\u003e write!(f, \"ONFT: {} {}\", collection_id, onft_id),\n            AssetSource::OffChain {} =\u003e write!(f, \"OffChain\"),\n        }\n    }\n}\n\n#[cw_serde]\npub struct Asset {\n    pub channel_id: String,\n    pub publish_id: String,\n    pub asset_source: AssetSource,\n    pub is_visible: bool,\n}\n\n#[cw_serde]\n#[derive(Default)]\npub struct AssetMetadata {\n    pub name: String,\n    pub description: String,\n    pub media_uri: String,\n}\n\n#[cw_serde]\npub enum Flag {\n    NSFW,\n    Explicit,\n    Spam,\n    Hateful,\n    Other(String),\n}\nimpl std::fmt::Display for Flag {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        match self {\n            Flag::NSFW =\u003e write!(f, \"NSFW\"),\n            Flag::Explicit =\u003e write!(f, \"Explicit\"),\n            Flag::Spam =\u003e write!(f, \"Spam\"),\n            Flag::Hateful =\u003e write!(f, \"Hateful\"),\n            Flag::Other(s) =\u003e write!(f, \"Other: {}\", s),\n        }\n    }\n}\n\nimpl Flag {\n    pub fn to_key(\u0026self) -\u003e String {\n        match self {\n            Flag::NSFW =\u003e \"n\".to_string(),\n            Flag::Explicit =\u003e \"e\".to_string(),\n            Flag::Spam =\u003e \"s\".to_string(),\n            Flag::Hateful =\u003e \"h\".to_string(),\n            Flag::Other(_) =\u003e \"o\".to_string(),\n        }\n    }\n    pub fn values() -\u003e Vec\u003cFlag\u003e {\n        vec![\n            Flag::NSFW,\n            Flag::Explicit,\n            Flag::Spam,\n            Flag::Hateful,\n            Flag::Other(String::new()), // Assuming you want to include this variant\n        ]\n    }\n}\n","traces":[{"line":28,"address":[],"length":0,"stats":{"Line":122}},{"line":29,"address":[],"length":0,"stats":{"Line":122}},{"line":31,"address":[],"length":0,"stats":{"Line":10}},{"line":32,"address":[],"length":0,"stats":{"Line":10}},{"line":33,"address":[],"length":0,"stats":{"Line":10}},{"line":34,"address":[],"length":0,"stats":{"Line":112}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":66,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":31}},{"line":77,"address":[],"length":0,"stats":{"Line":31}},{"line":78,"address":[],"length":0,"stats":{"Line":7}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":6}},{"line":82,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":6}},{"line":89,"address":[],"length":0,"stats":{"Line":6}},{"line":90,"address":[],"length":0,"stats":{"Line":6}},{"line":91,"address":[],"length":0,"stats":{"Line":6}}],"covered":23,"coverable":27},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","channel.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Decimal};\npub type ChannelId = String;\npub type UserName = String;\n\n#[cw_serde]\npub struct ChannelDetails {\n    pub channel_id: String,\n    pub user_name: String,\n    pub onft_id: String,\n    pub payment_address: Addr,\n}\n\n#[cw_serde]\npub struct ChannelMetadata {\n    pub channel_name: String,\n    pub description: Option\u003cString\u003e,\n    pub profile_picture: Option\u003cString\u003e,\n    pub banner_picture: Option\u003cString\u003e,\n}\n\n#[cw_serde]\n// This is a struct that used for each onft's additional data field.\npub struct ChannelOnftData {\n    pub onft_id: String,\n    pub channel_id: String,\n    pub user_name: String,\n}\n#[cw_serde]\npub struct ChannelCollaborator {\n    pub role: Role,\n    pub share: Decimal,\n}\n\n#[cw_serde]\npub enum Role {\n    Admin,\n    Publisher,\n    Moderator,\n}\nuse std::fmt::{Display, Formatter, Result};\n\nimpl Display for Role {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e Result {\n        match self {\n            Role::Admin =\u003e write!(f, \"admin\"),\n            Role::Moderator =\u003e write!(f, \"moderator\"),\n            Role::Publisher =\u003e write!(f, \"publisher\"),\n        }\n    }\n}\n","traces":[{"line":44,"address":[],"length":0,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":2}},{"line":48,"address":[],"length":0,"stats":{"Line":0}}],"covered":3,"coverable":5},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","config.rs"],"content":"use cosmwasm_schema::cw_serde;\nuse cosmwasm_std::{Addr, Coin};\n\n#[cw_serde]\npub struct ChannelConractConfig {\n    pub channels_collection_id: String,\n    pub channel_creation_fee: Vec\u003cCoin\u003e,\n    pub accepted_tip_denoms: Vec\u003cString\u003e,\n    pub auth_details: AuthDetails,\n}\n\n#[cw_serde]\npub struct AuthDetails {\n    pub protocol_admin: Addr,\n    pub fee_collector: Addr,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","lib.rs"],"content":"pub mod asset;\npub mod channel;\npub mod config;\npub mod msg;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","packages","types","src","msg.rs"],"content":"use cosmwasm_schema::{cw_serde, QueryResponses};\nuse cosmwasm_std::{Addr, Binary, Coin, Decimal};\n\nuse crate::{\n    asset::{Asset, AssetKey, AssetMetadata, AssetSource, Flag, Playlist},\n    channel::{ChannelCollaborator, ChannelDetails, ChannelMetadata},\n    config::ChannelConractConfig,\n};\n\n#[cw_serde]\npub struct InstantiateMsg {\n    pub protocol_admin: Addr,\n    pub fee_collector: Addr,\n    pub channels_collection_details: ChannelsCollectionDetails,\n    pub channel_token_details: ChannelTokenDetails,\n    pub channel_creation_fee: Vec\u003cCoin\u003e,\n    pub accepted_tip_denoms: Vec\u003cString\u003e,\n    pub reserved_usernames: Vec\u003cReservedUsername\u003e,\n}\n\n#[cw_serde]\npub struct ChannelsCollectionDetails {\n    pub collection_id: String,\n    pub collection_name: String,\n    pub collection_symbol: String,\n    pub description: String,\n    pub preview_uri: String,\n    pub schema: String,\n    pub uri: String,\n    pub uri_hash: String,\n    pub data: String,\n}\n\n#[cw_serde]\npub struct ChannelTokenDetails {\n    pub description: String,\n    pub media_uri: String,\n    pub preview_uri: String,\n    pub uri_hash: String,\n    pub transferable: bool,\n    pub extensible: bool,\n    pub nsfw: bool,\n    pub royalty_share: String,\n}\n\n#[cw_serde]\npub struct ReservedUsername {\n    pub username: String,\n    pub address: Option\u003cAddr\u003e,\n}\n\n#[cw_serde]\npub enum ExecuteMsg {\n    /// Updates the configuration of the contract, including the channel creation fee,\n    /// protocol admin, and fee collector. Only callable by the protocol admin.\n    AdminSetConfig {\n        /// (Optional) The new channel creation fee.\n        channel_creation_fee: Option\u003cVec\u003cCoin\u003e\u003e,\n        /// (Optional) The new admin address.\n        protocol_admin: Option\u003cString\u003e,\n        /// (Optional) The new fee collector address.\n        fee_collector: Option\u003cString\u003e,\n    },\n    /// Removes assets from the contract.\n    /// Only callable by the protocol admin.    \n    AdminRemoveAssets {\n        /// The keys of the assets to be removed.\n        asset_keys: Vec\u003cAssetKey\u003e,\n        /// Removes all flags from the assets if set to true.\n        refresh_flags: Option\u003cbool\u003e,\n    },\n    /// Manages reserved usernames.\n    /// Only callable by the protocol admin.\n    /// Can set an address as a reserved username\n    /// Can remove reserved usernames\n    /// Can add reserved usernames\n    AdminManageReservedUsernames {\n        /// (Optional) A list of addresses to be set as reserved usernames.\n        add_usernames: Option\u003cVec\u003cReservedUsername\u003e\u003e,\n        /// (Optional) A list of addresses to be removed from reserved usernames.\n        remove_usernames: Option\u003cVec\u003cString\u003e\u003e,\n    },\n    /// Pauses all channel-related operations. Only callable by a pauser.\n    Pause {},\n\n    /// Resumes all paused operations. Only callable by a pauser.\n    Unpause {},\n\n    /// Updates the list of accounts allowed to pause and unpause the contract.\n    /// Only callable by an admin.\n    SetPausers {\n        /// A list of addresses to be set as pausers.\n        pausers: Vec\u003cString\u003e,\n    },\n    /// Publishes an asset to a channel. The contract will generate and store a publish ID.\n    /// Only callable by the channel owner or a collaborator.\n    AssetPublish {\n        /// The source of the asset.\n        asset_source: AssetSource,\n        /// A salt value used for unique identification.\n        salt: Binary,\n        /// The ID of the channel where the asset is published.\n        channel_id: String,\n        /// (Optional) The name of the playlist where the asset is added.\n        playlist_name: Option\u003cString\u003e,\n        /// A flag indicating if the asset is visible to the public.\n        is_visible: bool,\n        /// The metadata of the asset.\n        metadata: AssetMetadata,\n    },\n\n    /// Unpublishes an asset from a channel. The publish ID and related asset details will\n    /// be removed from the contract state. Only callable by the channel owner or a collaborator.\n    AssetUnpublish {\n        /// The ID of the publish to be removed.\n        publish_id: String,\n        /// The ID of the channel where the asset is unpublished.\n        channel_id: String,\n    },\n\n    /// Updates the details of a published asset, including its visibility status.\n    /// Only callable by the channel owner.\n    AssetUpdateDetails {\n        /// The ID of the publish to be updated.\n        publish_id: String,\n        /// The ID of the channel where the asset is published.\n        channel_id: String,\n        /// The new visibility status of the asset.\n        is_visible: Option\u003cbool\u003e,\n        /// The new name of the asset.\n        name: Option\u003cString\u003e,\n        /// The new description of the asset.\n        description: Option\u003cString\u003e,\n        /// The new media URI of the asset.\n        media_uri: Option\u003cString\u003e,\n    },\n    AssetFlag {\n        /// The ID of the channel where the asset is published.\n        channel_id: String,\n        /// The ID of the publish to be flagged.\n        publish_id: String,\n        /// The flag value.\n        flag: Flag,\n    },\n    /// Creates a new playlist in the specified channel. The playlist name must be unique\n    /// within the channel. Only callable by the channel owner or a collaborator.\n    PlaylistCreate {\n        /// The unique name of the playlist.\n        playlist_name: String,\n        /// The ID of the channel where the playlist is created.\n        channel_id: String,\n    },\n\n    /// Deletes an existing playlist from the channel.\n    /// Only callable by the channel owner or a collaborator.\n    PlaylistDelete {\n        /// The name of the playlist to be deleted.\n        playlist_name: String,\n        /// The ID of the channel where the playlist exists.\n        channel_id: String,\n    },\n\n    /// Adds an asset to a playlist. The asset must already be published in the channel\n    /// and must be visible. Only callable by the channel owner or a collaborator.\n    PlaylistAddAsset {\n        /// The publish ID of the asset to be added.\n        publish_id: String,\n        /// The ID of the channel where the asset is currently published.\n        asset_channel_id: String,\n        /// The ID of the channel where the playlist exists.\n        channel_id: String,\n        /// The name of the playlist where the asset will be added.\n        playlist_name: String,\n    },\n\n    /// Removes an asset from a playlist.\n    /// Only callable by the channel owner or a collaborator.\n    PlaylistRemoveAsset {\n        /// The publish ID of the asset to be removed.\n        publish_id: String,\n        /// The ID of the channel where the playlist exists.\n        channel_id: String,\n        /// The name of the playlist where the asset is being removed.\n        playlist_name: String,\n    },\n\n    /// Refreshes a playlist by removing all assets that are either unpublished\n    /// or no longer visible. Only callable by the channel owner or a collaborator.\n    PlaylistRefresh {\n        /// The ID of the channel where the playlist exists.\n        channel_id: String,\n        /// The name of the playlist to be refreshed.\n        playlist_name: String,\n    },\n\n    /// Creates a new channel. The contract will generate a channel ID and mint an NFT\n    /// for the owner.\n    /// The owner must pay the `channel_creation_fee` to create a channel.\n    ChannelCreate {\n        /// A salt value used for unique identification.\n        salt: Binary,\n        /// The user name of the channel owner.\n        user_name: String,\n        /// Name of the channel\n        channel_name: String,\n        /// A description of the channel.\n        description: Option\u003cString\u003e,\n        /// The payment address of the channel owner.\n        payment_address: Addr,\n        /// (Optional) Profile image of the channel\n        profile_picture: Option\u003cString\u003e,\n        /// (Optional) Banner image of the channel\n        banner_picture: Option\u003cString\u003e,\n    },\n\n    /// Deletes an existing channel. The channel ID and related details will be removed\n    /// from the contract state. Only callable by the channel owner.\n    ChannelDelete {\n        /// The ID of the channel to be deleted.\n        channel_id: String,\n    },\n    /// Updates the details of an existing channel. Only callable by the channel owner.\n    ChannelUpdateDetails {\n        /// The ID of the channel to be updated.\n        channel_id: String,\n        /// The new description of the channel.\n        /// (Optional) The new description of the channel.\n        description: Option\u003cString\u003e,\n        /// (Optional) The new name of the channel.\n        channel_name: Option\u003cString\u003e,\n        /// (Optional) The new profile image of the channel.\n        profile_picture: Option\u003cString\u003e,\n        /// (Optional) The new banner image of the channel.\n        banner_picture: Option\u003cString\u003e,\n        /// (Optional) The new payment address of the channel.\n        payment_address: Option\u003cString\u003e,\n    },\n    /// Tipping a channel\n    ChannelTip {\n        /// The ID of the channel to be tipped.\n        channel_id: String,\n        /// The amount of tokens to be tipped.\n        amount: Coin,\n        /// The asset id to be tipped. Only for indexing purposes. Not used for anything else.\n        asset_id: Option\u003cString\u003e,\n    },\n    /// Adds a collaborator to a channel.\n    /// Only callable by the channel owner.\n    ChannelAddCollaborator {\n        /// The ID of the channel to add the collaborator to.\n        channel_id: String,\n        /// The address of the collaborator to be added.\n        collaborator_address: String,\n        /// Collaborator details\n        collaborator_details: ChannelCollaborator,\n    },\n    /// Removes a collaborator from a channel.\n    /// Only callable by the channel owner.\n    ChannelRemoveCollaborator {\n        /// The ID of the channel to remove the collaborator from.\n        channel_id: String,\n        /// The address of the collaborator to be removed.\n        collaborator_address: String,\n    },\n\n    /// Follow a channel\n    ChannelFollow {\n        /// The ID of the channel to follow.\n        channel_id: String,\n    },\n\n    /// Unfollow a channel\n    ChannelUnfollow {\n        /// The ID of the channel to unfollow.\n        channel_id: String,\n    },\n}\n\n#[cw_serde]\n#[derive(QueryResponses)]\npub enum QueryMsg {\n    #[returns(bool)]\n    IsPaused {},\n\n    #[returns(Vec\u003cString\u003e)]\n    Pausers {},\n\n    #[returns(ChannelDetails)]\n    ChannelDetails { channel_id: String },\n\n    #[returns(ChannelMetadata)]\n    ChannelMetadata { channel_id: String },\n\n    #[returns(ChannelResponse)]\n    Channel { channel_id: String },\n\n    #[returns(Vec\u003cChannelResponse\u003e)]\n    Channels {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(String)]\n    ChannelId { user_name: String },\n\n    #[returns(Playlist)]\n    Playlist {\n        channel_id: String,\n        playlist_name: String,\n    },\n\n    #[returns(Vec\u003cPlaylist\u003e)]\n    Playlists {\n        channel_id: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(ChannelConractConfig)]\n    Config {},\n\n    #[returns(Vec\u003cAssetResponse\u003e)]\n    Assets {\n        channel_id: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(AssetResponse)]\n    Asset {\n        channel_id: String,\n        publish_id: String,\n    },\n\n    #[returns(Vec\u003cReservedUsername\u003e)]\n    ReservedUsernames {\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(CollaboratorInfo)]\n    GetChannelCollaborator {\n        channel_id: String,\n        collaborator_address: Addr,\n    },\n\n    #[returns(Vec\u003cCollaboratorInfo\u003e)]\n    GetChannelCollaborators {\n        channel_id: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n\n    #[returns(u64)]\n    FollowersCount { channel_id: String },\n\n    #[returns(Vec\u003cString\u003e)]\n    Followers {\n        channel_id: String,\n        start_after: Option\u003cString\u003e,\n        limit: Option\u003cu32\u003e,\n    },\n}\n// Response for Channel query\n#[cw_serde]\npub struct ChannelResponse {\n    pub channel_id: String,\n    pub user_name: String,\n    pub onft_id: String,\n    pub payment_address: String,\n    pub channel_name: String,\n    pub description: Option\u003cString\u003e,\n    pub profile_picture: Option\u003cString\u003e,\n    pub banner_picture: Option\u003cString\u003e,\n    pub collaborators: Vec\u003cCollaboratorInfo\u003e,\n    pub follower_count: u64,\n}\n\n#[cw_serde]\npub struct AssetResponse {\n    pub asset: Asset,\n    pub flags: Vec\u003cFlagInfo\u003e,\n    pub metadata: AssetMetadata,\n}\n#[cw_serde]\npub struct CollaboratorInfo {\n    pub address: String,\n    pub role: String,\n    pub share: Decimal,\n}\n\n// Create this new type to avoid tuples\n#[cw_serde]\npub struct FlagInfo {\n    pub flag: Flag,\n    pub count: u64,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","helpers","mod.rs"],"content":"#[allow(dead_code)]\npub mod setup;\n#[allow(dead_code)]\npub mod utils;\n\n#[allow(dead_code)]\npub mod msg_wrapper;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","helpers","msg_wrapper.rs"],"content":"use cosmwasm_std::{Addr, Binary};\nuse omniflix_channel_types::{\n    asset::{AssetMetadata, AssetSource},\n    msg::{\n        ChannelTokenDetails, ChannelsCollectionDetails, ExecuteMsg, InstantiateMsg,\n        ReservedUsername,\n    },\n};\n\npub fn get_channel_instantiate_msg(admin: Addr) -\u003e InstantiateMsg {\n    InstantiateMsg {\n        channel_creation_fee: vec![],\n        fee_collector: admin.clone(),\n        protocol_admin: admin.clone(),\n        accepted_tip_denoms: vec![\"uflix\".to_string()],\n        channel_token_details: ChannelTokenDetails {\n            media_uri: \"https://example.com/media.png\".to_string(),\n            preview_uri: \"https://example.com/preview.png\".to_string(),\n            description: \"Channel token details\".to_string(),\n            uri_hash: \"\".to_string(),\n            transferable: true,\n            extensible: true,\n            nsfw: false,\n            royalty_share: \"0\".to_string(),\n        },\n        channels_collection_details: ChannelsCollectionDetails {\n            collection_id: \"Channels\".to_string(),\n            collection_name: \"Channels\".to_string(),\n            collection_symbol: \"CH\".to_string(),\n            description: \"Channels collection\".to_string(),\n            preview_uri: \"https://example.com/preview.png\".to_string(),\n            uri: \"https://example.com/uri\".to_string(),\n            schema: \"https://example.com/schema\".to_string(),\n            uri_hash: \"\".to_string(),\n            data: \"\".to_string(),\n        },\n        reserved_usernames: vec![ReservedUsername {\n            username: \"reserved\".to_string(),\n            address: None,\n        }],\n    }\n}\n\npub struct CreateChannelMsgBuilder {\n    salt: Binary,\n    user_name: String,\n    description: String,\n    channel_name: String,\n    banner_picture: Option\u003cString\u003e,\n    profile_picture: Option\u003cString\u003e,\n    payment_address: Addr,\n}\n\nimpl CreateChannelMsgBuilder {\n    pub fn new(user_name: \u0026str, payment_address: Addr) -\u003e Self {\n        Self {\n            salt: Binary::from(\"salt\".as_bytes()),\n            user_name: user_name.to_string(),\n            description: \"Default description\".to_string(),\n            channel_name: user_name.to_string(), // Default to the same as user_name\n            banner_picture: None,\n            profile_picture: None,\n            payment_address,\n        }\n    }\n\n    pub fn description(mut self, description: String) -\u003e Self {\n        self.description = description;\n        self\n    }\n\n    pub fn channel_name(mut self, channel_name: String) -\u003e Self {\n        self.channel_name = channel_name;\n        self\n    }\n\n    pub fn banner_picture(mut self, banner_picture: String) -\u003e Self {\n        self.banner_picture = Some(banner_picture);\n        self\n    }\n\n    pub fn profile_picture(mut self, profile_picture: String) -\u003e Self {\n        self.profile_picture = Some(profile_picture);\n        self\n    }\n\n    pub fn salt(mut self, salt: Binary) -\u003e Self {\n        self.salt = salt;\n        self\n    }\n\n    pub fn build(self) -\u003e ExecuteMsg {\n        ExecuteMsg::ChannelCreate {\n            salt: self.salt,\n            user_name: self.user_name,\n            description: Some(self.description),\n            banner_picture: self.banner_picture,\n            profile_picture: self.profile_picture,\n            channel_name: self.channel_name,\n            payment_address: self.payment_address,\n        }\n    }\n}\n\npub struct AssetPublishMsgBuilder {\n    asset_source: AssetSource,\n    salt: Binary,\n    channel_id: String,\n    playlist_name: Option\u003cString\u003e,\n    is_visible: bool,\n    name: String,\n    description: String,\n    media_uri: String,\n}\n\nimpl AssetPublishMsgBuilder {\n    pub fn new(channel_id: String) -\u003e Self {\n        Self {\n            asset_source: AssetSource::OffChain {},\n            salt: Binary::from(\"salt\".as_bytes()),\n            channel_id,\n            playlist_name: None,\n            is_visible: true,\n            name: \"validassetname\".to_string(),\n            description: \"validassetdescription\".to_string(),\n            media_uri: \"https://example.com/media.png\".to_string(),\n        }\n    }\n\n    pub fn asset_source(mut self, asset_source: AssetSource) -\u003e Self {\n        self.asset_source = asset_source;\n        self\n    }\n\n    pub fn playlist_name(mut self, playlist_name: String) -\u003e Self {\n        self.playlist_name = Some(playlist_name);\n        self\n    }\n\n    pub fn set_visible(mut self, is_visible: bool) -\u003e Self {\n        self.is_visible = is_visible;\n        self\n    }\n\n    pub fn name(mut self, name: String) -\u003e Self {\n        self.name = name;\n        self\n    }\n\n    pub fn description(mut self, description: String) -\u003e Self {\n        self.description = description;\n        self\n    }\n\n    pub fn media_uri(mut self, media_uri: String) -\u003e Self {\n        self.media_uri = media_uri;\n        self\n    }\n\n    pub fn build(self) -\u003e ExecuteMsg {\n        ExecuteMsg::AssetPublish {\n            asset_source: self.asset_source,\n            salt: self.salt,\n            channel_id: self.channel_id,\n            playlist_name: self.playlist_name,\n            is_visible: self.is_visible,\n            metadata: AssetMetadata {\n                name: self.name,\n                description: self.description,\n                media_uri: self.media_uri,\n            },\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","helpers","setup.rs"],"content":"use cosmwasm_std::{coin, Addr, BlockInfo, Timestamp};\nuse cw_multi_test::{ContractWrapper, MockApiBech32};\n\nuse super::utils::mint_to_address;\nuse testing::app::OmniflixApp;\n\npub fn setup() -\u003e SetupResponse {\n    let api = MockApiBech32::new(\"cosmwasm\");\n    let mut app = OmniflixApp::new();\n\n    let admin = api.addr_make(\"admin\");\n    let creator = api.addr_make(\"creator\");\n    let creator2 = api.addr_make(\"creator2\");\n    let collector = api.addr_make(\"collector\");\n    let collaborator = api.addr_make(\"collaborator\");\n\n    app.set_block(BlockInfo {\n        chain_id: \"test_1\".to_string(),\n        height: 1_000,\n        time: Timestamp::from_nanos(1_000),\n    });\n\n    // Mint multiple denominations at once for each address\n    mint_to_address(\n        \u0026mut app,\n        creator.to_string(),\n        vec![\n            coin(1_000_000_000, \"uflix\"),\n            coin(1_000_000_000_000, \"different_denom\"),\n            coin(1_000_000_000_000, \"incorrect_denom\"),\n        ],\n    );\n    mint_to_address(\n        \u0026mut app,\n        creator2.to_string(),\n        vec![\n            coin(1_000_000_000, \"uflix\"),\n            coin(1_000_000_000_000, \"different_denom\"),\n            coin(1_000_000_000_000, \"incorrect_denom\"),\n        ],\n    );\n    mint_to_address(\n        \u0026mut app,\n        collector.to_string(),\n        vec![\n            coin(1_000_000_000, \"uflix\"),\n            coin(1_000_000_000_000, \"different_denom\"),\n            coin(1_000_000_000_000, \"incorrect_denom\"),\n        ],\n    );\n    mint_to_address(\n        \u0026mut app,\n        admin.to_string(),\n        vec![\n            coin(1_000_000_000, \"uflix\"),\n            coin(1_000_000_000_000, \"different_denom\"),\n            coin(1_000_000_000_000, \"incorrect_denom\"),\n        ],\n    );\n    mint_to_address(\n        \u0026mut app,\n        collaborator.to_string(),\n        vec![coin(1_000_000_000, \"uflix\")],\n    );\n\n    let channel_contract = Box::new(ContractWrapper::new(\n        omniflix_channel::contract::execute,\n        omniflix_channel::contract::instantiate,\n        omniflix_channel::contract::query,\n    ));\n\n    let channel_contract_code_id = app.store_code(channel_contract);\n\n    SetupResponse {\n        app,\n        test_accounts: TestAccounts {\n            admin,\n            creator,\n            creator2,\n            collaborator,\n            collector,\n        },\n        channel_contract_code_id,\n    }\n}\n\npub struct SetupResponse {\n    pub app: OmniflixApp,\n    pub test_accounts: TestAccounts,\n    pub channel_contract_code_id: u64,\n}\n\npub struct TestAccounts {\n    pub admin: Addr,\n    pub creator: Addr,\n    pub creator2: Addr,\n    pub collaborator: Addr,\n    pub collector: Addr,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","helpers","utils.rs"],"content":"use cosmwasm_std::{from_json, Addr, Coin, CosmosMsg, MemoryStorage, Storage};\nuse cw_multi_test::AppResponse;\nuse omniflix_std::types::omniflix::onft::v1beta1::{Collection, MsgCreateDenom, MsgMintOnft};\nuse testing::app::OmniflixApp;\n\npub fn get_contract_address_from_res(res: AppResponse) -\u003e String {\n    res.events\n        .iter()\n        .find(|e| e.ty == \"instantiate\")\n        .unwrap()\n        .attributes\n        .iter()\n        .find(|a| a.key == \"_contract_address\")\n        .unwrap()\n        .value\n        .clone()\n}\n\npub fn query_onft_collection(storage: \u0026MemoryStorage, minter_address: String) -\u003e Collection {\n    let key = format!(\"collections:{}:{}\", \"collection\", minter_address);\n    let collection = storage.get(key.as_bytes()).unwrap();\n    let collection_details: Collection = from_json(collection).unwrap();\n    collection_details\n}\npub fn mint_to_address(app: \u0026mut OmniflixApp, to_address: String, amount: Vec\u003cCoin\u003e) {\n    app.init_modules(|router, _, storage| {\n        router\n            .bank\n            .init_balance(\n                storage,\n                \u0026Addr::unchecked(to_address.clone()),\n                amount.clone(),\n            )\n            .unwrap()\n    });\n}\npub fn get_event_attribute(res: AppResponse, event_type: \u0026str, attribute_key: \u0026str) -\u003e String {\n    res.events\n        .iter()\n        .find(|e| e.ty == event_type) // Find the event by type\n        .and_then(|e| {\n            e.attributes.iter().find(|attr| attr.key == attribute_key) // Find the attribute by key\n        })\n        .map_or(String::new(), |attr| attr.value.clone()) // Return value or empty string\n}\n\n/// Generates a CosmosMsg to create a denom\npub fn create_denom_msg(\n    sender: String,\n    denom_id: String,\n    name: Option\u003cString\u003e, // Optional: if not provided, default is used\n) -\u003e CosmosMsg {\n    let create_denom_msg = MsgCreateDenom {\n        data: \"data\".to_string(),\n        sender: sender.clone(),\n        creation_fee: None,\n        description: \"description\".to_string(),\n        id: denom_id.clone(),\n        name: name.unwrap_or_else(|| \"Media asset collection\".to_string()),\n        preview_uri: \"preview_uri\".to_string(),\n        royalty_receivers: vec![],\n        schema: \"schema\".to_string(),\n        symbol: \"symbol\".to_string(),\n        uri: \"uri\".to_string(),\n        uri_hash: \"uri_hash\".to_string(),\n    };\n\n    create_denom_msg.into() // Convert to CosmosMsg\n}\n\n/// Generates a CosmosMsg to mint an ONFT\npub fn mint_onft_msg(\n    denom_id: String,\n    onft_id: String, // Renamed from asset_id to onft_id\n    recipient: String,\n) -\u003e CosmosMsg {\n    let mint_onft_msg = MsgMintOnft {\n        denom_id: denom_id.clone(),\n        id: onft_id.clone(),\n        nsfw: false, // Default is false\n        recipient: recipient.clone(),\n        ..Default::default() // Use default values for remaining fields\n    };\n\n    mint_onft_msg.into() // Convert to CosmosMsg\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","lib.rs"],"content":"mod helpers;\n\nmod tests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","admin","mod.rs"],"content":"pub mod remove_assets;\npub mod set_config;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","admin","remove_assets.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::Asset;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{AssetPublishMsgBuilder, CreateChannelMsgBuilder};\nuse crate::helpers::utils::get_event_attribute;\nuse crate::helpers::{msg_wrapper::get_channel_instantiate_msg, setup::setup};\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Admin removes the asset\n    let remove_assets_msg = ExecuteMsg::AdminRemoveAssets {\n        asset_keys: vec![(channel_id.clone(), publish_id.clone())],\n        refresh_flags: None,\n    };\n\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_assets_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the asset and check if it is removed\n    let query_msg = QueryMsg::Assets {\n        channel_id: channel_id.clone(),\n        start_after: None,\n        limit: None,\n    };\n\n    let assets: Vec\u003cAsset\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert!(assets.is_empty());\n}\n\n#[test]\nfn unauthorized() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Asset creator can not remove the asset with admin remove assets.\n    let remove_assets_msg = ExecuteMsg::AdminRemoveAssets {\n        asset_keys: vec![(channel_id.clone(), publish_id.clone())],\n        refresh_flags: None,\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_assets_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    let err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n\n    assert_eq!(err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn asset_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Admin removes the asset that does not exist\n    let remove_assets_msg = ExecuteMsg::AdminRemoveAssets {\n        asset_keys: vec![(channel_id.clone(), \"publish_id\".to_string())],\n        refresh_flags: None,\n    };\n\n    let res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_assets_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    let err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n\n    assert_eq!(\n        err,\n        \u0026ContractError::Asset(asset_manager::error::AssetError::AssetNotFound {})\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","admin","set_config.rs"],"content":"use cosmwasm_std::{coin, StdError};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::config::ChannelConractConfig;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::{msg_wrapper::get_channel_instantiate_msg, setup::setup};\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Set the config\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                protocol_admin: Some(creator.to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check the contract config\n    let config: ChannelConractConfig = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr, \u0026QueryMsg::Config {})\n        .unwrap();\n    assert_eq!(config.auth_details.protocol_admin, creator);\n}\n\n#[test]\nfn unauthorized() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Set the config\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                protocol_admin: Some(creator.to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn invalid() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Set the config\n    let res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                // Invalid address\n                protocol_admin: Some(\"creator\".to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Std(StdError::generic_err(\"Error decoding bech32\"))\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","flag.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel_types::{\n    asset::{AssetSource, Flag},\n    msg::ExecuteMsg,\n};\n\nuse crate::helpers::msg_wrapper::AssetPublishMsgBuilder;\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::{create_denom_msg, get_event_attribute, mint_onft_msg},\n};\n\n#[test]\nfn flag_asset_happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create an asset for the channel\n    let collection_id = \"collection1\";\n    let asset_id = \"asset1\";\n\n    // Create collection and mint asset\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        collection_id.to_string(),\n        Some(\"Test Collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n\n    let mint_asset_msg = mint_onft_msg(\n        collection_id.to_string(),\n        asset_id.to_string(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_asset_msg);\n\n    // Publish the asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: collection_id.to_string(),\n            onft_id: asset_id.to_string(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // User flags the asset\n    let flag_msg = ExecuteMsg::AssetFlag {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n        flag: Flag::NSFW,\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026flag_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify correct event attributes\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"action\"),\n        \"asset_flag\"\n    );\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"publish_id\"),\n        publish_id\n    );\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"channel_id\"),\n        channel_id\n    );\n    assert_eq!(get_event_attribute(res.clone(), \"wasm\", \"flag\"), \"NSFW\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","mod.rs"],"content":"pub mod flag;\npub mod publish;\npub mod unpublish;\npub mod update_details;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","publish.rs"],"content":"use asset_manager::error::PlaylistError;\nuse cosmwasm_std::{coin, CosmosMsg};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::{AssetSource, Playlist};\nuse omniflix_channel_types::msg::{AssetResponse, ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::AssetPublishMsgBuilder;\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::{create_denom_msg, get_event_attribute, mint_onft_msg},\n};\n\n#[test]\nfn asset_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Try publishing an asset without it existing\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: \"id\".to_string(),\n            onft_id: \"asset_id\".to_string(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::OnftNotFound {\n            collection_id: \"id\".to_string(),\n            onft_id: \"asset_id\".to_string()\n        }\n    );\n}\n#[test]\nfn channel_not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n    // Creator owns the channel\n    // Lets create a asset for collector and try to publish it\n\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        collector.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        collector.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(collector.clone(), cosmos_msg);\n\n    // Publish the asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn playlist_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Creator owns the channel\n    // Lets create a asset for creator and try to publish it\n\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(creator.clone(), cosmos_msg);\n\n    // Publish the asset with wrong playlist name\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .playlist_name(\"Wrong playlist\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistNotFound {})\n    );\n}\n\n#[test]\nfn with_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n    println!(\"channel_id: {}\", channel_id);\n\n    // Creator owns the channel\n    // Lets create a asset for creator and try to publish it\n\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(creator.clone(), cosmos_msg);\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Publish the asset under the new playlist\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .playlist_name(\"My Videos\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Query the new playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Videos\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 1);\n    assert_eq!(playlist.assets[0].1, publish_id);\n}\n\n#[test]\nfn asset_not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        collector.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    // Asset is owned by collector\n    // Creator tries to publish the asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::OnftNotOwned {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone()\n        }\n    );\n}\n\n#[test]\nfn publish_off_chain_asset() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::OffChain {})\n        .name(\"name\".to_string())\n        .description(\"description\".to_string())\n        .media_uri(\"https://omniflix.network/\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Query the asset\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(asset.asset.publish_id, publish_id);\n    assert_eq!(asset.asset.asset_source, AssetSource::OffChain {});\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // We need to create a denom for creator\n    // Then we will mint a onft representing the asset\n    // Then we will publish the asset\n\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(creator.clone(), cosmos_msg);\n\n    // Publish the asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Query the asset\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(asset.asset.publish_id, publish_id);\n    assert_eq!(\n        asset.asset.asset_source,\n        AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        }\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","unpublish.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::AssetSource;\nuse omniflix_channel_types::msg::{AssetResponse, ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::AssetPublishMsgBuilder;\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::{create_denom_msg, get_event_attribute, mint_onft_msg},\n};\n\n#[test]\nfn channel_not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    // Create a collection\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Asset Collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    // Publish an asset\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Unpublish the asset with a different user\n    let unpublish_msg = ExecuteMsg::AssetUnpublish {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026unpublish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn asset_not_pubished() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Unpublish the asset\n    // Should return an error\n    let unpublish_msg = ExecuteMsg::AssetUnpublish {\n        publish_id: \"publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026unpublish_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Asset(asset_manager::error::AssetError::AssetNotFound {})\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    // Create a collection\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Asset Collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Query the asset and check if it is published\n    let query_msg = QueryMsg::Assets {\n        channel_id: channel_id.clone(),\n        start_after: None,\n        limit: None,\n    };\n\n    let assets: Vec\u003cAssetResponse\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(assets.len(), 1);\n    assert_eq!(assets[0].asset.publish_id, publish_id.clone());\n\n    // Unpublish the asset\n    let unpublish_msg = ExecuteMsg::AssetUnpublish {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026unpublish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the asset and check if it is unpublished\n    let query_msg = QueryMsg::Assets {\n        channel_id: channel_id.clone(),\n        start_after: None,\n        limit: None,\n    };\n\n    let assets: Vec\u003cAssetResponse\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(assets.len(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","assets","update_details.rs"],"content":"use asset_manager::error::AssetError;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::channel::Role;\nuse omniflix_channel_types::msg::{AssetResponse, ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::AssetPublishMsgBuilder;\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::get_event_attribute,\n};\n\n#[test]\nfn asset_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Try to update details of a non-existent asset\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: \"non_existent_publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n        is_visible: Some(false),\n        name: Some(\"Updated Name\".to_string()),\n        description: Some(\"Updated Description\".to_string()),\n        media_uri: Some(\"https://updated-media-uri.com\".to_string()),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026update_details_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Asset(AssetError::AssetNotFound {})\n    );\n}\n\n#[test]\nfn channel_not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let other_user = setup_response.test_accounts.creator2.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Try to update asset details from a non-owner account\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        is_visible: Some(false),\n        name: Some(\"Updated Name\".to_string()),\n        description: Some(\"Updated Description\".to_string()),\n        media_uri: Some(\"https://updated-media-uri.com\".to_string()),\n    };\n\n    let err = app\n        .execute_contract(\n            other_user.clone(),\n            channel_contract_addr.clone(),\n            \u0026update_details_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = err.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn partial_update() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let original_name = \"Original Asset Name\";\n    let original_description = \"Original Asset Description\";\n    let original_media_uri = \"https://original-media-uri.com\";\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .name(original_name.to_string())\n        .description(original_description.to_string())\n        .media_uri(original_media_uri.to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Update only the name of the asset\n    let new_name = \"Updated Asset Name\";\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        is_visible: None,\n        name: Some(new_name.to_string()),\n        description: None,\n        media_uri: None,\n    };\n\n    app.execute_contract(\n        creator.clone(),\n        channel_contract_addr.clone(),\n        \u0026update_details_msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query the asset to verify the update\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset_response: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Verify that only the name was updated\n    assert_eq!(asset_response.metadata.name, new_name);\n    assert_eq!(asset_response.metadata.description, original_description);\n    assert_eq!(asset_response.metadata.media_uri, original_media_uri);\n    assert!(asset_response.asset.is_visible);\n}\n\n#[test]\nfn full_update() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let original_name = \"Original Asset Name\";\n    let original_description = \"Original Asset Description\";\n    let original_media_uri = \"https://original-media-uri.com\";\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .name(original_name.to_string())\n        .description(original_description.to_string())\n        .media_uri(original_media_uri.to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Update all fields of the asset\n    let new_name = \"Completely Updated Name\";\n    let new_description = \"Completely Updated Description\";\n    let new_media_uri = \"https://completely-updated-media-uri.com\";\n\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        is_visible: Some(false),\n        name: Some(new_name.to_string()),\n        description: Some(new_description.to_string()),\n        media_uri: Some(new_media_uri.to_string()),\n    };\n\n    app.execute_contract(\n        creator.clone(),\n        channel_contract_addr.clone(),\n        \u0026update_details_msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query the asset to verify the update\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset_response: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Verify that all fields were updated\n    assert_eq!(asset_response.metadata.name, new_name);\n    assert_eq!(asset_response.metadata.description, new_description);\n    assert_eq!(asset_response.metadata.media_uri, new_media_uri);\n    assert!(!asset_response.asset.is_visible);\n}\n\n#[test]\nfn collaborator_update() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collaborator = setup_response.test_accounts.collaborator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Add collaborator to the channel\n    let add_collaborator_msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collaborator.to_string(),\n        collaborator_details: omniflix_channel_types::channel::ChannelCollaborator {\n            role: Role::Publisher,\n            share: cosmwasm_std::Decimal::percent(10),\n        },\n    };\n\n    app.execute_contract(\n        creator.clone(),\n        channel_contract_addr.clone(),\n        \u0026add_collaborator_msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Publish an asset\n    let original_name = \"Original Asset Name\";\n    let original_description = \"Original Asset Description\";\n    let original_media_uri = \"https://original-media-uri.com\";\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .name(original_name.to_string())\n        .description(original_description.to_string())\n        .media_uri(original_media_uri.to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the publish_id from the event\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Collaborator updates the asset details\n    let new_name = \"Collaborator Updated Name\";\n    let update_details_msg = ExecuteMsg::AssetUpdateDetails {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        is_visible: Some(false),\n        name: Some(new_name.to_string()),\n        description: None,\n        media_uri: None,\n    };\n\n    // This should succeed since collaborators should be able to update assets\n    app.execute_contract(\n        collaborator.clone(),\n        channel_contract_addr.clone(),\n        \u0026update_details_msg,\n        \u0026[],\n    )\n    .unwrap();\n\n    // Query the asset to verify the update\n    let query_msg = QueryMsg::Asset {\n        channel_id: channel_id.clone(),\n        publish_id: publish_id.clone(),\n    };\n\n    let asset_response: AssetResponse = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Verify that the name was updated and visibility changed\n    assert_eq!(asset_response.metadata.name, new_name);\n    assert_eq!(asset_response.metadata.description, original_description);\n    assert_eq!(asset_response.metadata.media_uri, original_media_uri);\n    assert!(!asset_response.asset.is_visible);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","collaborators.rs"],"content":"use channel_manager::error::ChannelError;\nuse cosmwasm_std::{coin, Decimal, Uint128};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::channel::{ChannelCollaborator, Role};\nuse omniflix_channel_types::msg::{CollaboratorInfo, ExecuteMsg, QueryMsg};\n\nuse crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::get_event_attribute,\n};\n\n#[test]\nfn add_collaborator_unauthorized() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Try to add collaborator as unauthorized user\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: creator.clone().into_string(),\n        collaborator_details: ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::from_ratio(Uint128::one(), Uint128::from(3u128)),\n        },\n    };\n\n    let res = app\n        .execute_contract(collector.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn add_collaborator_invalid_share() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Try to add collaborator with share \u003e 100%\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collector.clone().into_string(),\n        collaborator_details: ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(101),\n        },\n    };\n\n    let res = app\n        .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::InvalidSharePercentage {})\n    );\n}\n\n#[test]\nfn add_collaborator_total_unique_limit_exceeded() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Need to add 10 collaborators\n    for i in 0..10 {\n        // Generate a valid cosmos collaborator address\n        let collaborator_address = app.api().addr_make(format!(\"collaborator_{}\", i).as_str());\n\n        let msg = ExecuteMsg::ChannelAddCollaborator {\n            channel_id: channel_id.clone(),\n            collaborator_address: collaborator_address.clone().into_string(),\n            collaborator_details: ChannelCollaborator {\n                role: Role::Moderator,\n                share: Decimal::percent(9),\n            },\n        };\n\n        let _res = app\n            .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n            .unwrap();\n    }\n\n    // Try to add another collaborator should fail\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: app.api().addr_make(\"new_collaborator\").into_string(),\n        collaborator_details: ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(9),\n        },\n    };\n\n    let res = app\n        .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::TotalUniqueCollaboratorsLimitExceeded {})\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Add collaborator successfully\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collector.clone().into_string(),\n        collaborator_details: ChannelCollaborator {\n            role: Role::Moderator,\n            share: Decimal::percent(30),\n        },\n    };\n\n    let _res = app\n        .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Verify collaborator was added\n    let query_msg = QueryMsg::GetChannelCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collector.clone(),\n    };\n\n    let collaborator: CollaboratorInfo = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(collaborator.role, Role::Moderator.to_string());\n    assert_eq!(collaborator.share, Decimal::percent(30));\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","create.rs"],"content":"use crate::helpers::msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\nuse channel_manager::error::ChannelError;\nuse cosmwasm_std::{coin, Binary};\nuse cw_multi_test::Executor;\nuse omniflix_channel::string_validation::StringValidationError;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::msg::{ChannelResponse, ExecuteMsg, QueryMsg, ReservedUsername};\n\n#[test]\nfn missing_creation_fee() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Missing creation fee creating a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::PaymentError {\n            expected: [coin(1000000, \"uflix\")].to_vec(),\n            received: (vec![])\n        }\n    );\n}\n\n#[test]\nfn paused() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Pause the contract\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::Pause {},\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Pause(pauser::PauseError::Paused {})\n    );\n}\n\n#[test]\nfn failed_validations() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let channel_create_msg =\n        CreateChannelMsgBuilder::new(\"creatorcreatorcreatorcreatorcreator\", creator.clone())\n            .build();\n\n    // Too long username\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::StringValidationError(StringValidationError::InvalidLength {\n            sent: \"creatorcreatorcreatorcreatorcreator\".to_string(),\n            min_length: 3,\n            max_length: 32,\n        })\n    );\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone())\n        .description(\"a\".repeat(257))\n        .build();\n\n    // Too long description\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::StringValidationError(StringValidationError::InvalidLength {\n            sent: \"a\".repeat(257),\n            min_length: 3,\n            max_length: 256,\n        })\n    );\n}\n#[test]\nfn username_already_exists() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Happy path\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone())\n        .salt(Binary::from(\"salt2\".as_bytes()))\n        .build();\n\n    // Try to create a channel with the same username\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::UserNameAlreadyTaken {})\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Happy path\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    // Validate the creation fee was sent to the fee collector\n    let amount = get_event_attribute(res.clone(), \"transfer\", \"amount\");\n    assert_eq!(amount, \"1000000uflix\");\n    let recipient = get_event_attribute(res.clone(), \"transfer\", \"recipient\");\n    assert_eq!(recipient, admin.to_string());\n\n    // Get onftid from events\n    let onft_id = get_event_attribute(res.clone(), \"wasm\", \"onft_id\");\n\n    // Query channels\n    let channels: Vec\u003cChannelResponse\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::Channels {\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n    assert_eq!(channels.len(), 1);\n    assert_eq!(channels[0].user_name, \"creator\");\n    // Validate the onft_id\n    assert_eq!(channels[0].onft_id, onft_id);\n}\n\n#[test]\nfn create_reserved_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n    // Username \"admin\" is reserved for the actor admin\n    instantiate_msg.reserved_usernames = vec![\n        ReservedUsername {\n            username: \"admin\".to_string(),\n            address: Some(admin.clone()),\n        },\n        ReservedUsername {\n            username: \"reserved\".to_string(),\n            address: None,\n        },\n    ];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"admin\", creator.clone()).build();\n\n    // Creator can not use the reserved username \"admin\"\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::UserNameReserved {});\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"reserved\", creator.clone()).build();\n    // No one can use the reserved username \"reserved\"\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    // Admin can use the reserved username \"admin\"\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"admin\", admin.clone()).build();\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    // Whenever a reserved username is used, remove it from the reserved list\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 1);\n    assert_eq!(res[0].username, \"reserved\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","delete.rs"],"content":"use crate::helpers::msg_wrapper::CreateChannelMsgBuilder;\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::{\n    channel::ChannelDetails,\n    msg::{ExecuteMsg, QueryMsg},\n};\n\n#[test]\nfn delete_channel_happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026crate::helpers::msg_wrapper::get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel first\n    let username = \"creator\";\n    let channel_create_msg = CreateChannelMsgBuilder::new(username, creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Extract channel_id from the response\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Verify channel exists\n    let channel_details_query: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel_details_query.user_name, username);\n\n    // Delete the channel\n    let delete_msg = ExecuteMsg::ChannelDelete {\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify correct event attributes\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"action\"),\n        \"delete_channel\"\n    );\n    assert_eq!(\n        get_event_attribute(res.clone(), \"wasm\", \"channel_id\"),\n        channel_id\n    );\n\n    // Verify that the channel no longer exists\n    let query_result = app.wrap().query_wasm_smart::\u003cChannelDetails\u003e(\n        channel_contract_addr.clone(),\n        \u0026QueryMsg::ChannelDetails {\n            channel_id: channel_id.clone(),\n        },\n    );\n\n    // Query should fail with channel not found error\n    assert!(query_result.is_err());\n}\n\n#[test]\nfn delete_channel_not_creator() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let creator2 = setup_response.test_accounts.creator2.clone();\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026crate::helpers::msg_wrapper::get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel first\n    let username = \"creator\";\n    let channel_create_msg = CreateChannelMsgBuilder::new(username, creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Extract channel_id from the response\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Try to delete channel with non creator\n    let delete_msg = ExecuteMsg::ChannelDelete {\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    // Verify error is about permissions\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n\n    // Verify channel still exists\n    let channel_details_query: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel_details_query.user_name, username);\n}\n\n#[test]\nfn delete_channel_when_paused() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026crate::helpers::msg_wrapper::get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel first\n    let username = \"creator\";\n    let channel_create_msg = CreateChannelMsgBuilder::new(username, creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Extract channel_id from the response\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Pause the contract\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::Pause {},\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to delete the channel when contract is paused\n    let delete_msg = ExecuteMsg::ChannelDelete {\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    // Verify error is about contract being paused\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Pause(pauser::PauseError::Paused {})\n    );\n}\n\n#[test]\nfn delete_nonexistent_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026crate::helpers::msg_wrapper::get_channel_instantiate_msg(admin.clone()),\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Try to delete a channel that doesn't exist\n    let nonexistent_channel_id = \"nonexistent_channel_id\";\n    let delete_msg = ExecuteMsg::ChannelDelete {\n        channel_id: nonexistent_channel_id.to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    // Verify error is about channel not found\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(channel_manager::error::ChannelError::ChannelIdNotFound {})\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","follow.rs"],"content":"use crate::helpers::msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\nuse channel_manager::error::ChannelError;\nuse cosmwasm_std::{coin, Addr};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\n#[test]\nfn follow_non_existent_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let follower = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let res = app.execute_contract(\n        follower.clone(),\n        channel_contract_addr.clone(),\n        \u0026ExecuteMsg::ChannelFollow {\n            channel_id: \"non_existent_channel\".to_string(),\n        },\n        \u0026[],\n    );\n\n    assert!(res.is_err());\n}\n#[test]\nfn already_following() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let follower = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Follow the channel\n    let _res = app\n        .execute_contract(\n            follower.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelFollow {\n                channel_id: channel_id.clone(),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to follow again\n    let res = app\n        .execute_contract(\n            follower.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelFollow {\n                channel_id: channel_id.clone(),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::AlreadyFollowing {})\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let follower = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Follow the channel\n    let _res = app\n        .execute_contract(\n            follower.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelFollow {\n                channel_id: channel_id.clone(),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query followers count\n    let followers_count: u64 = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::FollowersCount {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n\n    assert_eq!(followers_count, 1);\n\n    // Query followers\n    let followers: Vec\u003cAddr\u003e = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::Followers {\n                channel_id: channel_id.clone(),\n                start_after: None,\n                limit: None,\n            },\n        )\n        .unwrap();\n\n    assert_eq!(followers.len(), 1);\n    assert_eq!(followers[0], follower);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","manage_reserved_usernames.rs"],"content":"use cosmwasm_std::{coin, Addr};\nuse cw_multi_test::Executor;\nuse omniflix_channel::string_validation::StringValidationError;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg, ReservedUsername};\n\nuse crate::helpers::msg_wrapper::get_channel_instantiate_msg;\nuse crate::helpers::setup::setup;\n\n#[test]\nfn add_reserved_usernames() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    // Query reserved_usernames\n    // Default reserved usernames has 1 entry\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 1);\n\n    // Add a reserved username but dont set an address\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"admin\".to_string(),\n            address: None,\n        }]),\n        remove_usernames: None,\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 2);\n\n    // Add invalid reserved username\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"Admin\".to_string(),\n            address: None,\n        }]),\n        remove_usernames: None,\n    };\n\n    let res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::StringValidationError(StringValidationError::UppercaseNotAllowed {\n            sent: \"Admin\".to_string()\n        })\n    );\n    // Add valid reserved username with invalid address\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"Admin\".to_string(),\n            address: Some(Addr::unchecked(\"\")),\n        }]),\n        remove_usernames: None,\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n    // Username admin is already added but we want to sent an valid address\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"admin\".to_string(),\n            address: Some(creator.clone()),\n        }]),\n        remove_usernames: None,\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(res.len(), 2);\n    assert_eq!(res[0].address, Some(creator.clone()));\n\n    // Remove designated address from reserved username\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"admin\".to_string(),\n            address: None,\n        }]),\n        remove_usernames: None,\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 2);\n    assert_eq!(res[0].address, None);\n}\n\n#[test]\nfn remove_reserved_usernames() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let _creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    // Query reserved_usernames\n    // Default reserved usernames has 1 entry\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 1);\n\n    // Remove a reserved username that does not exist\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: None,\n        remove_usernames: vec![\"admin\".to_string()].into(),\n    };\n\n    let res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(channel_manager::error::ChannelError::UsernameNotReserved {})\n    );\n\n    // Remove a reserved username\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: None,\n        remove_usernames: vec![\"reserved\".to_string()].into(),\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 0);\n\n    // Remove usernames while adding\n    let msg = ExecuteMsg::AdminManageReservedUsernames {\n        add_usernames: Some(vec![ReservedUsername {\n            username: \"admin\".to_string(),\n            address: None,\n        }]),\n        remove_usernames: vec![\"admin\".to_string()].into(),\n    };\n\n    let _res = app\n        .execute_contract(admin.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Query reserved_usernames\n    let query_msg = QueryMsg::ReservedUsernames {\n        limit: None,\n        start_after: None,\n    };\n    let res: Vec\u003cReservedUsername\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(res.len(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","mod.rs"],"content":"pub mod collaborators;\npub mod create;\npub mod manage_reserved_usernames;\npub mod tipping;\npub mod update_channel_details;\n\npub mod follow;\n\npub mod delete;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","tipping.rs"],"content":"use crate::helpers::msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\nuse cosmwasm_std::{coin, Addr, Decimal, Uint128};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::msg::ExecuteMsg;\n\n#[test]\nfn invalid_payment_address() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg =\n        CreateChannelMsgBuilder::new(\"creator\", Addr::unchecked(\"invalid\")).build();\n\n    // Create a channel with an invalid payment address\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n}\n\n#[test]\nfn invalid_tipping_denom() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Channel contracts tipping denom is uflix\n    // Try to tip with a different denom\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(100000, \"different_denom\"),\n                asset_id: None,\n            },\n            \u0026[coin(1000000, \"different_denom\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::InvalidTipDenom {});\n}\n\n#[test]\nfn invalid_tip_amount() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Amount in the message is different from the amount in the coins\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(1000, \"uflix\"),\n                asset_id: None,\n            },\n            \u0026[coin(100, \"uflix\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::InvalidTipAmount {});\n    // Denom in the message is different from the denom in the coins\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(1000, \"uflix\"),\n                asset_id: None,\n            },\n            \u0026[coin(1000, \"different_denom\")],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Payment(cw_utils::PaymentError::MissingDenom(\"uflix\".to_string()))\n    );\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg.clone(),\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Tip the creator\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(100000, \"uflix\"),\n                asset_id: None,\n            },\n            \u0026[coin(100000, \"uflix\")],\n        )\n        .unwrap();\n\n    // Validate the tip was sent to the creator\n    let amount = get_event_attribute(res.clone(), \"transfer\", \"amount\");\n    assert_eq!(amount, \"100000uflix\");\n    let recipient = get_event_attribute(res, \"transfer\", \"recipient\");\n    assert_eq!(recipient, creator.to_string());\n\n    // Add collaborator\n    let msg = ExecuteMsg::ChannelAddCollaborator {\n        channel_id: channel_id.clone(),\n        collaborator_address: collector.clone().into_string(),\n        collaborator_details: omniflix_channel_types::channel::ChannelCollaborator {\n            role: omniflix_channel_types::channel::Role::Moderator,\n            share: Decimal::from_ratio(Uint128::one(), Uint128::from(3u128)),\n        },\n    };\n\n    let _res = app\n        .execute_contract(creator.clone(), channel_contract_addr.clone(), \u0026msg, \u0026[])\n        .unwrap();\n\n    // Execute a tip\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelTip {\n                channel_id: channel_id.clone(),\n                amount: coin(100000, \"uflix\"),\n                asset_id: None,\n            },\n            \u0026[coin(100000, \"uflix\")],\n        )\n        .unwrap();\n\n    // Validate the tip was sent to the creator\n    let amount = get_event_attribute(res.clone(), \"wasm\", \u0026creator.into_string());\n    assert_eq!(amount, \"66667uflix\");\n\n    let amount = get_event_attribute(res.clone(), \"wasm\", \u0026collector.into_string());\n    assert_eq!(amount, \"33333uflix\");\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","channels","update_channel_details.rs"],"content":"use crate::helpers::{\n    msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder},\n    setup::setup,\n    utils::get_event_attribute,\n};\nuse channel_manager::error::ChannelError;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::channel::ChannelDetails;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\n#[test]\nfn missing_channel_id() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Missing channel_id\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: \"\".to_string(),\n                description: Some(\"creator\".to_string()),\n                banner_picture: None,\n                profile_picture: None,\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(channel_manager::error::ChannelError::ChannelIdNotFound {})\n    );\n}\n#[test]\nfn invalid_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Channel not found\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: \"1\".to_string(),\n                description: Some(\"creator\".to_string()),\n                banner_picture: None,\n                profile_picture: None,\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Channel(ChannelError::ChannelIdNotFound {})\n    );\n}\n\n#[test]\nfn unauthorized() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Query Channel Details\n    let channel: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel.channel_id, channel_id);\n\n    // Unauthorized\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: Some(\"creator\".to_string()),\n                banner_picture: None,\n                profile_picture: None,\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n    // Create a channel\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Query Channel\n    let channel: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel.channel_id, channel_id);\n\n    // Happy path\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: Some(\"new description\".to_string()),\n                banner_picture: None,\n                profile_picture: None,\n                channel_name: None,\n                payment_address: Some(creator.clone().to_string()),\n            },\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n\n    // Query Channel Details\n    let channel: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel.payment_address, creator.clone());\n}\n\n#[test]\nfn invalid() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    let mut instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    instantiate_msg.channel_creation_fee = vec![coin(1000000, \"uflix\")];\n\n    // Instantiate the contract\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap();\n    let channel_id = get_event_attribute(res, \"wasm\", \"channel_id\");\n\n    // Query Channel Details\n    let channel: ChannelDetails = app\n        .wrap()\n        .query_wasm_smart(\n            channel_contract_addr.clone(),\n            \u0026QueryMsg::ChannelDetails {\n                channel_id: channel_id.clone(),\n            },\n        )\n        .unwrap();\n    assert_eq!(channel.channel_id, channel_id);\n\n    // Invalid banner link\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: None,\n                banner_picture: Some(\"i\".repeat(1001)),\n                profile_picture: None,\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    // Invalid profile link\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: None,\n                banner_picture: None,\n                profile_picture: Some(\"i\".repeat(1001)),\n                channel_name: None,\n                payment_address: None,\n            },\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n\n    // Invalid channel name\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::ChannelUpdateDetails {\n                channel_id: channel_id.clone(),\n                description: None,\n                banner_picture: None,\n                profile_picture: None,\n                // No special characters\n                channel_name: Some(\"creator_1\".to_string()),\n                payment_address: None,\n            },\n            \u0026[coin(1000000, \"uflix\")],\n        )\n        .unwrap_err();\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","instantiate.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::{\n    config::ChannelConractConfig,\n    msg::{ExecuteMsg, QueryMsg},\n};\n\nuse crate::helpers::{msg_wrapper::get_channel_instantiate_msg, setup::setup};\n\n#[test]\nfn instantiate_channel_contract() {\n    // Setup     testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    // Missed Onft collection creation fee. This variable is set to 1000000 uflix\n    let res = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::PaymentError {\n            expected: [coin(1000000, \"uflix\")].to_vec(),\n            received: (vec![])\n        }\n    );\n\n    // Send more than the required fee\n    let res = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000001, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::PaymentError {\n            expected: [coin(1000000, \"uflix\")].to_vec(),\n            received: [coin(1000001, \"uflix\")].to_vec()\n        }\n    );\n\n    // Happy path\n    let res = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Check the contract config\n    let config: ChannelConractConfig = app\n        .wrap()\n        .query_wasm_smart(res, \u0026QueryMsg::Config {})\n        .unwrap();\n    assert_eq!(config.auth_details.protocol_admin, admin);\n    assert_eq!(config.channels_collection_id, \"Channels\");\n    assert_eq!(config.channel_creation_fee, vec![]);\n}\n\n#[test]\nfn set_config() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate the contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Unauthorized attempt to set the config\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                protocol_admin: Some(creator.to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n\n    // Happy path\n    let _res = app\n        .execute_contract(\n            admin.clone(),\n            channel_contract_addr.clone(),\n            \u0026ExecuteMsg::AdminSetConfig {\n                protocol_admin: Some(creator.to_string()),\n                channel_creation_fee: Some(vec![]),\n                fee_collector: Some(creator.to_string()),\n            },\n            \u0026[],\n        )\n        .unwrap();\n\n    // Check the contract config\n    let config: ChannelConractConfig = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr, \u0026QueryMsg::Config {})\n        .unwrap();\n    assert_eq!(config.auth_details.protocol_admin, creator);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","mod.rs"],"content":"#[cfg(test)]\npub mod instantiate;\n\n#[cfg(test)]\npub mod channels;\n\n#[cfg(test)]\npub mod assets;\n\n#[cfg(test)]\npub mod playlist;\n\n#[cfg(test)]\npub mod admin;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","add_asset.rs"],"content":"use cosmwasm_std::{coin, BlockInfo, Timestamp};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::{AssetSource, Playlist};\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{\n    get_channel_instantiate_msg, AssetPublishMsgBuilder, CreateChannelMsgBuilder,\n};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::{create_denom_msg, get_event_attribute, mint_onft_msg};\n\n#[test]\nfn asset_not_visible() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let _collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: asset_id.clone(),\n        asset_channel_id: asset_collection_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let error = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        error,\n        \u0026ContractError::Asset(asset_manager::error::AssetError::AssetNotFound {})\n    );\n}\n#[test]\nfn asset_from_diffirent_channel() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let creator2 = setup_response.test_accounts.creator2.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Creator 1 creates a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creatorone\", creator.clone())\n        .description(\"Creator 1 Description\".to_string())\n        .channel_name(\"Creator1\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let creator1_channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Creator 2 creates a channel\n    app.set_block(BlockInfo {\n        chain_id: \"test_1\".to_string(),\n        height: 5_000_000,\n        time: Timestamp::from_nanos(5_000_000),\n    });\n\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creatortwo\", creator2.clone())\n        .description(\"Creator 2 Description\".to_string())\n        .channel_name(\"Creator2\".to_string())\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let creator2_channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        \"id\".to_string(),\n        \"asset_id\".to_string(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(creator1_channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Create a playlist under creator 2's channel\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"Creator2 Playlist\".to_string(),\n        channel_id: creator2_channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: creator1_channel_id.clone(),\n        channel_id: creator2_channel_id.clone(),\n        playlist_name: \"Creator2 Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: creator2_channel_id.clone(),\n        playlist_name: \"Creator2 Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 1);\n    assert_eq!(playlist.assets[0].1, publish_id);\n}\n\n#[test]\nfn asset_already_exists_in_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        asset_collection_id.clone(),\n        asset_id.clone(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try to add the same asset again\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    // Verify error is about asset already in playlist\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(\n            asset_manager::error::PlaylistError::AssetAlreadyExistsInPlaylist {}\n        )\n    );\n}\n\n#[test]\nfn playlist_asset_limit_reached() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Create and publish 101 assets (1 more than the limit)\n    // The constant PLAYLISTS_ASSET_LIMIT is typically set to 100\n    for i in 0..101 {\n        let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n        // Increase block time by 1 ns every iteration\n        app.update_block(|block| {\n            block.time = block.time.plus_nanos(1);\n        });\n\n        let res = app\n            .execute_contract(\n                creator.clone(),\n                channel_contract_addr.clone(),\n                \u0026publish_msg,\n                \u0026[],\n            )\n            .unwrap();\n\n        let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n        // Add assets to the playlist (first 100 should succeed)\n        let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n            publish_id: publish_id.clone(),\n            asset_channel_id: channel_id.clone(),\n            channel_id: channel_id.clone(),\n            playlist_name: \"My Playlist\".to_string(),\n        };\n\n        // The first 100 adds should succeed, the 101st should fail\n        if i \u003c 100 {\n            let _res = app\n                .execute_contract(\n                    creator.clone(),\n                    channel_contract_addr.clone(),\n                    \u0026add_asset_msg,\n                    \u0026[],\n                )\n                .unwrap();\n        } else {\n            // The 101st add should fail with PlaylistAssetLimitReached\n            let res = app\n                .execute_contract(\n                    creator.clone(),\n                    channel_contract_addr.clone(),\n                    \u0026add_asset_msg,\n                    \u0026[],\n                )\n                .unwrap_err();\n\n            // Verify error is about playlist asset limit reached\n            let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n            assert_eq!(\n                typed_err,\n                \u0026ContractError::Playlist(\n                    asset_manager::error::PlaylistError::PlaylistAssetLimitReached {}\n                )\n            );\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","create.rs"],"content":"use asset_manager::error::PlaylistError;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::Playlist;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{get_channel_instantiate_msg, CreateChannelMsgBuilder};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\n\n// Create a playlist that already exists\n#[test]\nfn already_exists() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify that the playlist exists under the channel\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Videos\");\n\n    // Create a playlist that already exists\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistAlreadyExists {})\n    );\n}\n\n// Create a playlist without owning the channel\n#[test]\nfn not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist without owning the channel\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            // Collector does not own the channel\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify that the playlist exists under the channel\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Videos\");\n}\n\n#[test]\nfn try_creating_same_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Verify that the playlist exists under the channel\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Videos\");\n\n    // Creator tries to create a playlist named \"My Videos\"\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Videos\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistAlreadyExists {})\n    );\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","delete.rs"],"content":"use crate::helpers::msg_wrapper::{\n    get_channel_instantiate_msg, AssetPublishMsgBuilder, CreateChannelMsgBuilder,\n};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::{create_denom_msg, get_event_attribute, mint_onft_msg};\nuse asset_manager::error::PlaylistError;\nuse cosmwasm_std::{coin, CosmosMsg};\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::{AssetSource, Playlist};\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\n#[test]\nfn does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Remove a playlist that does not exist\n    let delete_playlist_msg = ExecuteMsg::PlaylistDelete {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistNotFound {})\n    );\n}\n\n// Delete a playlist without owning the channel\n#[test]\nfn not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Remove a playlist without owning the channel\n    let delete_playlist_msg = ExecuteMsg::PlaylistDelete {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n\n// Happy path\n#[test]\nfn happy_path() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        \"id\".to_string(),\n        \"asset_id\".to_string(),\n        creator.clone().to_string(),\n    );\n    let cosmos_msg: CosmosMsg = mint_onft_msg;\n    let _res = app.execute(creator.clone(), cosmos_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Playlist Add Asset\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Validate the asset was added to the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 1);\n    assert_eq!(playlist.assets[0].1, publish_id.clone());\n\n    // Delete the playlist\n    let delete_playlist_msg = ExecuteMsg::PlaylistDelete {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026delete_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Validate the playlist was removed\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 0);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","mod.rs"],"content":"pub mod create;\n\npub mod delete;\n\npub mod remove_asset_from_playlist;\n\npub mod add_asset;\n\npub mod refresh_playlist;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","refresh_playlist.rs"],"content":"use cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::Playlist;\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{\n    get_channel_instantiate_msg, AssetPublishMsgBuilder, CreateChannelMsgBuilder,\n};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::get_event_attribute;\n\n#[test]\nfn empty_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let _collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 0);\n\n    // Refresh the playlist\n    let refresh_playlist_msg = ExecuteMsg::PlaylistRefresh {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026refresh_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 0);\n}\n\n#[test]\nfn playlist_with_assets() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let _collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish the assets\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    app.update_block(|block| {\n        block.time = block.time.plus_nanos(1);\n    });\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id2 = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id2.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 2);\n    assert_eq!(playlist.assets[0], (channel_id.clone(), publish_id.clone()));\n    assert_eq!(\n        playlist.assets[1],\n        (channel_id.clone(), publish_id2.clone())\n    );\n\n    // Refresh the playlist\n    let refresh_playlist_msg = ExecuteMsg::PlaylistRefresh {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026refresh_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Playlist should have the same assets\n    assert_eq!(playlist.assets.len(), 2);\n    assert_eq!(playlist.assets[0], (channel_id.clone(), publish_id.clone()));\n    assert_eq!(\n        playlist.assets[1],\n        (channel_id.clone(), publish_id2.clone())\n    );\n}\n\n#[test]\nfn playlist_with_assets_and_removed_assets() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let _collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Publish the assets\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg.clone(),\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    app.update_block(|block| {\n        block.time = block.time.plus_nanos(1);\n    });\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let publish_id2 = get_event_attribute(res.clone(), \"wasm\", \"publish_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Add an asset to the playlist\n\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id2.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 2);\n\n    // Unpublish the first asset\n    let unpublish_msg = ExecuteMsg::AssetUnpublish {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026unpublish_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Refresh the playlist\n    let refresh_playlist_msg = ExecuteMsg::PlaylistRefresh {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026refresh_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Query the playlist\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    // Playlist should have the second asset only\n    assert_eq!(playlist.assets.len(), 1);\n    assert_eq!(\n        playlist.assets[0],\n        (channel_id.clone(), publish_id2.clone())\n    );\n}\n\n#[test]\nfn not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let creator2 = setup_response.test_accounts.creator2.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let channel_create_msg = CreateChannelMsgBuilder::new(\"username\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026channel_create_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Try refreshing the playlist with a different user\n    let refresh_playlist_msg = ExecuteMsg::PlaylistRefresh {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator2.clone(),\n            channel_contract_addr.clone(),\n            \u0026refresh_playlist_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let error = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(error, \u0026ContractError::Unauthorized {});\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","adnandenizcorlu","workspace","contracts","omniflix-channel","tests","src","tests","playlist","remove_asset_from_playlist.rs"],"content":"use asset_manager::error::PlaylistError;\nuse cosmwasm_std::coin;\nuse cw_multi_test::Executor;\nuse omniflix_channel::ContractError;\nuse omniflix_channel_types::asset::{AssetSource, Playlist};\nuse omniflix_channel_types::msg::{ExecuteMsg, QueryMsg};\n\nuse crate::helpers::msg_wrapper::{\n    get_channel_instantiate_msg, AssetPublishMsgBuilder, CreateChannelMsgBuilder,\n};\nuse crate::helpers::setup::setup;\nuse crate::helpers::utils::{create_denom_msg, get_event_attribute, mint_onft_msg};\n\n#[test]\nfn asset_not_in_playlist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Validate the creator have added a playlist\n\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Playlist\");\n\n    // Remove an unexisting asset from a playlist\n    let remove_asset_msg = ExecuteMsg::PlaylistRemoveAsset {\n        publish_id: \"publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::AssetNotInPlaylist {})\n    );\n}\n\n#[test]\nfn playlist_does_not_exist() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Remove an asset from a playlist that does not exist\n    let remove_asset_msg = ExecuteMsg::PlaylistRemoveAsset {\n        publish_id: \"publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::PlaylistNotFound {})\n    );\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Validate the creator have added a playlist\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Playlist\");\n    assert_eq!(playlists[0].assets.len(), 0);\n\n    // Playlist does not have any assets\n    // Remove an asset from a playlist\n\n    let remove_asset_msg = ExecuteMsg::PlaylistRemoveAsset {\n        publish_id: \"publish_id\".to_string(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(\n        typed_err,\n        \u0026ContractError::Playlist(PlaylistError::AssetNotInPlaylist {})\n    );\n}\n\n#[test]\nfn not_owned() {\n    // Setup testing environment\n    let setup_response = setup();\n    let mut app = setup_response.app;\n\n    // Actors\n    let admin = setup_response.test_accounts.admin.clone();\n    let creator = setup_response.test_accounts.creator.clone();\n    let collector = setup_response.test_accounts.collector.clone();\n\n    // Instantiate Channel Contract\n    let instantiate_msg = get_channel_instantiate_msg(admin.clone());\n\n    let channel_contract_addr = app\n        .instantiate_contract(\n            setup_response.channel_contract_code_id,\n            admin.clone(),\n            \u0026instantiate_msg,\n            \u0026[coin(1000000, \"uflix\")],\n            \"Instantiate Channel Contract\",\n            None,\n        )\n        .unwrap();\n\n    // Create a channel\n    let create_channel_msg = CreateChannelMsgBuilder::new(\"creator\", creator.clone()).build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_channel_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Get the channel_id from the event\n    let channel_id = get_event_attribute(res.clone(), \"wasm\", \"channel_id\");\n\n    // Create a playlist\n    let create_playlist_msg = ExecuteMsg::PlaylistCreate {\n        playlist_name: \"My Playlist\".to_string(),\n        channel_id: channel_id.clone(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026create_playlist_msg,\n            \u0026[],\n        )\n        .unwrap();\n    // Validate the creator have added a playlist\n    let query_msg = QueryMsg::Playlists {\n        channel_id: channel_id.clone(),\n        limit: None,\n        start_after: None,\n    };\n\n    let playlists: Vec\u003cPlaylist\u003e = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n    assert_eq!(playlists.len(), 1);\n    assert_eq!(playlists[0].playlist_name, \"My Playlist\");\n\n    // Publish an asset\n    let asset_collection_id = \"id\".to_string();\n    let asset_id = \"asset_id\".to_string();\n\n    let create_denom_msg = create_denom_msg(\n        creator.clone().to_string(),\n        asset_collection_id.clone(),\n        Some(\"Media asset collection\".to_string()),\n    );\n    let _res = app.execute(creator.clone(), create_denom_msg);\n    let mint_onft_msg = mint_onft_msg(\n        \"id\".to_string(),\n        \"asset_id\".to_string(),\n        creator.clone().to_string(),\n    );\n    let _res = app.execute(creator.clone(), mint_onft_msg);\n\n    let publish_msg = AssetPublishMsgBuilder::new(channel_id.clone())\n        .asset_source(AssetSource::Nft {\n            collection_id: asset_collection_id.clone(),\n            onft_id: asset_id.clone(),\n        })\n        .build();\n\n    let res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026publish_msg,\n            \u0026[],\n        )\n        .unwrap();\n    let publish_id = get_event_attribute(res, \"wasm\", \"publish_id\");\n\n    // Add an asset to a playlist\n    let add_asset_msg = ExecuteMsg::PlaylistAddAsset {\n        publish_id: publish_id.clone(),\n        asset_channel_id: channel_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let _res = app\n        .execute_contract(\n            creator.clone(),\n            channel_contract_addr.clone(),\n            \u0026add_asset_msg,\n            \u0026[],\n        )\n        .unwrap();\n\n    // Validate the asset was added to the playlist\n    let query_msg = QueryMsg::Playlist {\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let playlist: Playlist = app\n        .wrap()\n        .query_wasm_smart(channel_contract_addr.clone(), \u0026query_msg)\n        .unwrap();\n\n    assert_eq!(playlist.assets.len(), 1);\n\n    // Remove an asset from a playlist\n    let remove_asset_msg = ExecuteMsg::PlaylistRemoveAsset {\n        publish_id: publish_id.clone(),\n        channel_id: channel_id.clone(),\n        playlist_name: \"My Playlist\".to_string(),\n    };\n\n    let res = app\n        .execute_contract(\n            collector.clone(),\n            channel_contract_addr.clone(),\n            \u0026remove_asset_msg,\n            \u0026[],\n        )\n        .unwrap_err();\n\n    let typed_err = res.downcast_ref::\u003cContractError\u003e().unwrap();\n    assert_eq!(typed_err, \u0026ContractError::Unauthorized {});\n}\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>