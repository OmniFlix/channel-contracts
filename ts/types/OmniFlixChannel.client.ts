/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Addr, Uint128, InstantiateMsg, Coin, ExecuteMsg, AssetType, Binary, QueryMsg, Asset, ArrayOfAsset, ChannelDetails, String, ArrayOfChannelDetails, ChannelConractConfig, Boolean, ArrayOfString, Playlist, ArrayOfPlaylist } from "./OmniFlixChannel.types";
export interface OmniFlixChannelReadOnlyInterface {
  contractAddress: string;
  isPaused: () => Promise<Boolean>;
  pausers: () => Promise<ArrayOfString>;
  channelDetails: ({
    channelId,
    userName
  }: {
    channelId?: string;
    userName?: string;
  }) => Promise<ChannelDetails>;
  channels: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfChannelDetails>;
  channelId: ({
    userName
  }: {
    userName: string;
  }) => Promise<String>;
  playlist: ({
    channelId,
    playlistName
  }: {
    channelId: string;
    playlistName: string;
  }) => Promise<Playlist>;
  playlists: ({
    channelId,
    limit,
    startAfter
  }: {
    channelId: string;
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfPlaylist>;
  config: () => Promise<ChannelConractConfig>;
  assets: ({
    channelId,
    limit,
    startAfter
  }: {
    channelId: string;
    limit?: number;
    startAfter?: string;
  }) => Promise<ArrayOfAsset>;
  asset: ({
    channelId,
    publishId
  }: {
    channelId: string;
    publishId: string;
  }) => Promise<Asset>;
}
export class OmniFlixChannelQueryClient implements OmniFlixChannelReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.isPaused = this.isPaused.bind(this);
    this.pausers = this.pausers.bind(this);
    this.channelDetails = this.channelDetails.bind(this);
    this.channels = this.channels.bind(this);
    this.channelId = this.channelId.bind(this);
    this.playlist = this.playlist.bind(this);
    this.playlists = this.playlists.bind(this);
    this.config = this.config.bind(this);
    this.assets = this.assets.bind(this);
    this.asset = this.asset.bind(this);
  }

  isPaused = async (): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_paused: {}
    });
  };
  pausers = async (): Promise<ArrayOfString> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pausers: {}
    });
  };
  channelDetails = async ({
    channelId,
    userName
  }: {
    channelId?: string;
    userName?: string;
  }): Promise<ChannelDetails> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channel_details: {
        channel_id: channelId,
        user_name: userName
      }
    });
  };
  channels = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfChannelDetails> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channels: {
        limit,
        start_after: startAfter
      }
    });
  };
  channelId = async ({
    userName
  }: {
    userName: string;
  }): Promise<String> => {
    return this.client.queryContractSmart(this.contractAddress, {
      channel_id: {
        user_name: userName
      }
    });
  };
  playlist = async ({
    channelId,
    playlistName
  }: {
    channelId: string;
    playlistName: string;
  }): Promise<Playlist> => {
    return this.client.queryContractSmart(this.contractAddress, {
      playlist: {
        channel_id: channelId,
        playlist_name: playlistName
      }
    });
  };
  playlists = async ({
    channelId,
    limit,
    startAfter
  }: {
    channelId: string;
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfPlaylist> => {
    return this.client.queryContractSmart(this.contractAddress, {
      playlists: {
        channel_id: channelId,
        limit,
        start_after: startAfter
      }
    });
  };
  config = async (): Promise<ChannelConractConfig> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  assets = async ({
    channelId,
    limit,
    startAfter
  }: {
    channelId: string;
    limit?: number;
    startAfter?: string;
  }): Promise<ArrayOfAsset> => {
    return this.client.queryContractSmart(this.contractAddress, {
      assets: {
        channel_id: channelId,
        limit,
        start_after: startAfter
      }
    });
  };
  asset = async ({
    channelId,
    publishId
  }: {
    channelId: string;
    publishId: string;
  }): Promise<Asset> => {
    return this.client.queryContractSmart(this.contractAddress, {
      asset: {
        channel_id: channelId,
        publish_id: publishId
      }
    });
  };
}
export interface OmniFlixChannelInterface extends OmniFlixChannelReadOnlyInterface {
  contractAddress: string;
  sender: string;
  pause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unpause: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setPausers: ({
    pausers
  }: {
    pausers: string[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  publish: ({
    assetType,
    channelId,
    isVisible,
    playlistName,
    salt
  }: {
    assetType: AssetType;
    channelId: string;
    isVisible: boolean;
    playlistName?: string;
    salt: Binary;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unpublish: ({
    channelId,
    publishId
  }: {
    channelId: string;
    publishId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  assetUpdateDetails: ({
    channelId,
    isVisible,
    publishId
  }: {
    channelId: string;
    isVisible: boolean;
    publishId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  playlistCreate: ({
    channelId,
    playlistName
  }: {
    channelId: string;
    playlistName: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  playlistDelete: ({
    channelId,
    playlistName
  }: {
    channelId: string;
    playlistName: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  playlistAddAsset: ({
    assetChannelId,
    channelId,
    playlistName,
    publishId
  }: {
    assetChannelId: string;
    channelId: string;
    playlistName: string;
    publishId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  playlistRemoveAsset: ({
    channelId,
    playlistName,
    publishId
  }: {
    channelId: string;
    playlistName: string;
    publishId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  playlistRefresh: ({
    channelId,
    playlistName
  }: {
    channelId: string;
    playlistName: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  channelCreate: ({
    collaborators,
    description,
    salt,
    userName
  }: {
    collaborators?: string[];
    description: string;
    salt: Binary;
    userName: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  channelDelete: ({
    channelId
  }: {
    channelId: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  channelUpdateDetails: ({
    channelId,
    description
  }: {
    channelId: string;
    description: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  setConfig: ({
    admin,
    channelCreationFee,
    feeCollector
  }: {
    admin?: string;
    channelCreationFee?: Coin[];
    feeCollector?: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addReservedUsernames: ({
    usernames
  }: {
    usernames: string[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  adminChannelCreate: ({
    collaborators,
    description,
    recipient,
    salt,
    userName
  }: {
    collaborators?: string[];
    description: string;
    recipient: string;
    salt: Binary;
    userName: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class OmniFlixChannelClient extends OmniFlixChannelQueryClient implements OmniFlixChannelInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.pause = this.pause.bind(this);
    this.unpause = this.unpause.bind(this);
    this.setPausers = this.setPausers.bind(this);
    this.publish = this.publish.bind(this);
    this.unpublish = this.unpublish.bind(this);
    this.assetUpdateDetails = this.assetUpdateDetails.bind(this);
    this.playlistCreate = this.playlistCreate.bind(this);
    this.playlistDelete = this.playlistDelete.bind(this);
    this.playlistAddAsset = this.playlistAddAsset.bind(this);
    this.playlistRemoveAsset = this.playlistRemoveAsset.bind(this);
    this.playlistRefresh = this.playlistRefresh.bind(this);
    this.channelCreate = this.channelCreate.bind(this);
    this.channelDelete = this.channelDelete.bind(this);
    this.channelUpdateDetails = this.channelUpdateDetails.bind(this);
    this.setConfig = this.setConfig.bind(this);
    this.addReservedUsernames = this.addReservedUsernames.bind(this);
    this.adminChannelCreate = this.adminChannelCreate.bind(this);
  }

  pause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pause: {}
    }, fee, memo, _funds);
  };
  unpause = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unpause: {}
    }, fee, memo, _funds);
  };
  setPausers = async ({
    pausers
  }: {
    pausers: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_pausers: {
        pausers
      }
    }, fee, memo, _funds);
  };
  publish = async ({
    assetType,
    channelId,
    isVisible,
    playlistName,
    salt
  }: {
    assetType: AssetType;
    channelId: string;
    isVisible: boolean;
    playlistName?: string;
    salt: Binary;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      publish: {
        asset_type: assetType,
        channel_id: channelId,
        is_visible: isVisible,
        playlist_name: playlistName,
        salt
      }
    }, fee, memo, _funds);
  };
  unpublish = async ({
    channelId,
    publishId
  }: {
    channelId: string;
    publishId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unpublish: {
        channel_id: channelId,
        publish_id: publishId
      }
    }, fee, memo, _funds);
  };
  assetUpdateDetails = async ({
    channelId,
    isVisible,
    publishId
  }: {
    channelId: string;
    isVisible: boolean;
    publishId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      asset_update_details: {
        channel_id: channelId,
        is_visible: isVisible,
        publish_id: publishId
      }
    }, fee, memo, _funds);
  };
  playlistCreate = async ({
    channelId,
    playlistName
  }: {
    channelId: string;
    playlistName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      playlist_create: {
        channel_id: channelId,
        playlist_name: playlistName
      }
    }, fee, memo, _funds);
  };
  playlistDelete = async ({
    channelId,
    playlistName
  }: {
    channelId: string;
    playlistName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      playlist_delete: {
        channel_id: channelId,
        playlist_name: playlistName
      }
    }, fee, memo, _funds);
  };
  playlistAddAsset = async ({
    assetChannelId,
    channelId,
    playlistName,
    publishId
  }: {
    assetChannelId: string;
    channelId: string;
    playlistName: string;
    publishId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      playlist_add_asset: {
        asset_channel_id: assetChannelId,
        channel_id: channelId,
        playlist_name: playlistName,
        publish_id: publishId
      }
    }, fee, memo, _funds);
  };
  playlistRemoveAsset = async ({
    channelId,
    playlistName,
    publishId
  }: {
    channelId: string;
    playlistName: string;
    publishId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      playlist_remove_asset: {
        channel_id: channelId,
        playlist_name: playlistName,
        publish_id: publishId
      }
    }, fee, memo, _funds);
  };
  playlistRefresh = async ({
    channelId,
    playlistName
  }: {
    channelId: string;
    playlistName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      playlist_refresh: {
        channel_id: channelId,
        playlist_name: playlistName
      }
    }, fee, memo, _funds);
  };
  channelCreate = async ({
    collaborators,
    description,
    salt,
    userName
  }: {
    collaborators?: string[];
    description: string;
    salt: Binary;
    userName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      channel_create: {
        collaborators,
        description,
        salt,
        user_name: userName
      }
    }, fee, memo, _funds);
  };
  channelDelete = async ({
    channelId
  }: {
    channelId: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      channel_delete: {
        channel_id: channelId
      }
    }, fee, memo, _funds);
  };
  channelUpdateDetails = async ({
    channelId,
    description
  }: {
    channelId: string;
    description: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      channel_update_details: {
        channel_id: channelId,
        description
      }
    }, fee, memo, _funds);
  };
  setConfig = async ({
    admin,
    channelCreationFee,
    feeCollector
  }: {
    admin?: string;
    channelCreationFee?: Coin[];
    feeCollector?: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_config: {
        admin,
        channel_creation_fee: channelCreationFee,
        fee_collector: feeCollector
      }
    }, fee, memo, _funds);
  };
  addReservedUsernames = async ({
    usernames
  }: {
    usernames: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_reserved_usernames: {
        usernames
      }
    }, fee, memo, _funds);
  };
  adminChannelCreate = async ({
    collaborators,
    description,
    recipient,
    salt,
    userName
  }: {
    collaborators?: string[];
    description: string;
    recipient: string;
    salt: Binary;
    userName: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      admin_channel_create: {
        collaborators,
        description,
        recipient,
        salt,
        user_name: userName
      }
    }, fee, memo, _funds);
  };
}